**1.** **什么是好系统设计**

- 好的系统设计不是炫技，而是 **满足需求**。
- 目标是 **简单、健壮、易于理解、可维护**。
- 设计应当考虑权衡，而不是追求“完美架构”。

  

**2.** **系统设计的原则**

**(1)** **从需求出发**

- 明确系统要解决什么问题。
- 需求分为：

- **功能性需求** **(Functional requirements)**：系统必须完成的事。
- **非功能性需求** **(Non-functional requirements)**：系统必须满足的质量指标，如性能、可靠性、扩展性等。

**(2) KISS** **原则**

- **Keep It Simple, Stupid**
- 简单往往比复杂更好：复杂度是系统失败的最大风险。

**(3) YAGNI** **原则**

- **You Ain’t Gonna Need It(You are not going to need it)**
- 不要为了未来的可能性过度设计。只构建当前需求所需的功能。

**(4)** **容错性**

- 假设系统的每个组件最终都会失败。
- 关键是 **隔离失败、快速恢复**，而不是避免失败。

**(5)** **扩展性**

- 横向扩展 (scale out) 比纵向扩展 (scale up) 更现实。
- 设计要考虑未来增长，但不要过度优化。

**(6)** **权衡**

- 没有免费的午餐，每个设计都有成本。
- 例如：

- 一致性 vs 可用性
- 延迟 vs 吞吐量
- 开发速度 vs 系统复杂度

  

**3.** **系统设计的实践步骤**

**Step 1:** **明确需求**

- 问清楚：用户想要什么？规模多大？关键性能指标是什么？

**Step 2:** **建立简单模型**

- 首先用最简单的架构满足需求（单机 + 数据库）。
- 逐步增加复杂度，而不是一开始就设计“大规模分布式系统”。

**Step 3:** **识别瓶颈**

- 系统最薄弱的部分决定了扩展能力。
- 常见瓶颈：

- 数据库读写
- 网络带宽
- 磁盘 IO
- 内存

**Step 4:** **增量优化**

- 针对瓶颈做出优化，而不是一次性大规模重构。
- 常见手段：

- 缓存 (Cache)
- 分区/分片 (Partitioning, Sharding)
- 复制 (Replication)
- 队列 & 异步处理 (Queue, Async)

  

**4.** **常见设计模式**

**(1)** **缓存** **(Caching)**

- 提高性能、降低数据库压力。
- 要考虑缓存一致性。

**(2)** **数据库扩展**

- **垂直扩展**：升级硬件。
- **水平扩展**：

- **复制** **(Replication)**：提高可用性和读取性能。
- **分片** **(Sharding)**：分散写入负载。

**(3)** **队列** **(Queues)**

- 解耦系统、平滑流量高峰。
- 异步处理可以减少用户请求延迟。

**(4)** **冗余** **(Redundancy)**

- 多副本、跨区部署，确保高可用。

**(5)** **监控** **&** **报警**

- 必须实时监控，快速发现问题。
- 没有监控的系统等于瞎子。

  

**5.** **好系统设计的标准**

- **简单**：能被新人快速理解。
- **健壮**：即使部分失败也能继续运行。
- **可扩展**：能随着用户和数据量的增加而演进。
- **可观测**：有良好的监控和日志，方便排查问题。
- **渐进式演化**：能根据需求逐步演进，而不是推倒重来。

  

**6.** **核心结论**

- 复杂度是最大敌人。
- 设计系统时，要从需求出发，保持简单，容忍失败，逐步演化。
- 最终的目标：**好用、稳定、能扩展，而不是炫技。**