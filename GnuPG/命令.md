## 创建新的密钥对
*   `--gen-key` 简单交互生成密钥，算法默认
*   `--full-gen-key`
*   `--expert` 更精细的交互

```
gpg --full-gen-key --expert
```
## 删除公钥
`--delete-key <key>`
## 删除私钥
`--delete-secret-key <key>`
## 列出公钥环中的密钥
- `--list-keys`
- `--list-key`
- `-k`
## 列出密钥环中的密钥
- `--list-secret-keys`
- `-K`
## 输出公钥指纹
打印用户`UserID`的公钥指纹，如果省略`UserID`则打印所有用户的
- `--fingerprint <UserID>`
## 导出公钥
`gpg --export --armor <User Name> --output public.key`
- `--export`
* `-a, --armor`
* `-o, --output`
## 导出私钥
`gpg --export-secret-keys -a <User Name> -o private.key`
- `--export-secret-keys`
## 导入公钥
- `--import public.key`
## 导入私钥
注：`gpg --allow-secret-key-import --import private.key` 指令由于 `--allow-secret-key-import` 已经废除，故无效。 

正确步骤如下:
1.  `gpg --import private.key`
2.  `gpg --edit-key KEY`
3. `gpg>  trust`
5. `gpg>  quit`
## 补充

```bash
gpg --edit-key id  //对导入秘钥签名
gpg> fpr  显示指纹
gpg> sign  签名
gpg> quit
```
## 上传公钥到公钥服务器
`gpg --send-keys “KEY ID”
## 在公钥服务器搜索并导入指定ID的公钥
`gpg --keyserver keyserver.ubuntu.com --search-keys <key>`
*   `--keyserver hkp://subkeys.pgp.net`指定搜索的服务器对象，缺省为gpg默认的服务器
* 下载公钥后建议使用`gpg --fingerprint`验证指纹是否符合，若是错误的公钥则删除
* `gpg --sign-key [KEYID]`签收公钥（即\[完全\]信任该公钥）
## 直接根据KeyID导入公钥
`--recv-keys KeyID`
## 更新所有公钥
`--refresh-keys`
## 加密文件
`gpg -a -r “Receiver” -o output.enc -e filename`
*   `-r/--recipient <Receiver>` 用于指定接收用户，可多次使用`-r xxx`以实现对多个用户的加密，也可省略该项，会有交互式指令来添加。
*   `-e/--encrypt`指定加密的文件名，经测试该项必须放于最后。
## 解密文件
`gpg -o mydata.dec -d mydata.gpg`
*   `-d/--decrypt` 指定解密的文件名，经测试该项必须放于最后。
## 签名
有三种签名方式
注：以下三种方法都可以用参数`--local-user UserID`或`-u UserID`来指定使用哪个用户来签名，适用于你的电脑中有多个用户的情况，前提是你有那个用户的私钥(废话)
1.  `–detach-sign` 或 `-b` 表示单独生成签名文件
```sh
gpg -o file.asc -b data
# 验证方式: 
gpg --verify file.asc data
```
2. `–clearsign` 和 `–clear-sign` 在原文件保持明文的基础上加入签名
```sh
gpg -o file --clearsign data
# 特点：此选项用于 ASCII（文本）数据
验证方式:
gpg --verify test 
# 或
gpg -d test (推荐前者，会检测是不是分离签名)
# 另 
gpg -o output -d test 可以将签名中的数据单独提取到 output 文件中
```
3. `–sign` （很少单独使用） 此选项最常与加密一起使用（ `--encrypt` ）；但是它可以单独使用（这种情况很少见） 特点：不存在明文（但是实际上没有加密），可以使用 `--verify` 验证签名，但是看不到明文。使用 `gpg -d` 时能看到明文与签名。很少单独使用，常见用法见下一项。
### 签名并加密文件
`gpg -r User1 -r User2 -s -o data.enc -e data` 以 User1，User2 为接收者，签名并加密文件 data，输出加密后的文件到 data.enc 中
```bash
gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt demo.txt
```
- --local-user 指定用发信者的私钥签名 
- --recipient 指定用接收者的公钥加密 
- --armor 表示采用ASCII码形式显示 
- --sign 表示需要签名 
- --encrypt 表示指定源文件。
## 吊销
### 修改密钥相关数据
`gpg --edit-key [USERID]` 进入交互式窗口，输入`help`获取帮助 以下为常用指令:
*   `passwd` 修改密码
*   `uid` 选择用户标识 N(可以使用索引和ID)
*   `key` 选择子密钥 N(可以使用索引和ID)
*   `expire` 变更密钥或所选子密钥的使用期限
*   `primary` 标记所选的用户标识为主要
*   `trust` 修改对该密钥的信任程度（会立即更新信任数据库，无需保存）
*   `delkey` 删除选定的子密钥
*   `revsig` 吊销所选用户标识上的签名
*   `revuid` 吊销选定的用户标识
*   `revkey` 吊销密钥或选定的子密钥
*   `save` 保存并退出
*   `quit` 退出交互式终ļ
### 使用交互终端吊销
进入交互式窗口
1. 使用 `list` 查看需要吊销的子密钥ID
2. 使用 `key <ID>` 选中子密钥（或者使用索引），被选中的子密钥ssb后会有 `*`号
3. 输入 `revkey` 吊销选定的子密钥，如果公钥上传到了服务器上，在本地吊销后还需使用 `gpg --send-keys [​​USER_NAME​]` 发布吊销信息。
### 使用吊销证书吊销
1.  `gpg --gen-revoke USER_NAME > revoke` 生成 USER_NAME 的吊销证书，输出到revoke文件中
2.  `gpg --import revoke` 从本地文件 revoke 导入吊销证书，此时本地对应的密钥已经是吊销状态
3.  `gpg --send-keys [USER_NAME]` 如果之前已经发布到密钥服务器上，需要发布吊销信息
## 子密钥
### 生成
1.  `gpg --expert --edit-key` ​`UserID`​ 
	 - `--expert`可以启用更多调整选项，可以不启用 
	 - `--edit-key` 编辑已经生成好的主密钥，进入 `gpg` 提示符模式
2.  输入 `addkey`，添加子密钥
	- 美国国家标准与技术研究院（NIST）系列椭圆曲线、Brainpool系列椭圆曲线、secp256k1都存在不同的安全风险，不予考虑。
	- 25519椭圆曲线是最快的椭圆曲线之一，而且没有专利壁垒，是公有领域的产品，25519 曲线作为 P-256 的成功替代者，被众多应用广泛使用，支持良好。 
	- 设置过期时间，子密钥过期时间可以较短，这里设置为3年，之后的确认，输入密码即可。 
	- 同理创建分别用于E,S,A的三个子密钥，save 保存并退出
### 备份
`gpg -a --export-secret-subkeys [​​UserID] > subkeys` 备份所有子密钥到文件 subkeys
### 导入
此部分与普通密钥相同，使用`--imporrt`
### 删除
此部分与普通密钥相同，使用`--delete-keys ID` 如果`gpg -K`看不到子密钥ID，可使用`gpg -K --keyid-format short`
### 吊销
与密钥吊销部分相同，使用`--edit-key UserID`进入终端来吊销，参看使用交互终端吊销章节。
注：GPG 不允许用户生成子密钥的吊销证书，而是把变更都放在唯一的公钥中，简洁且不易出错。你只需要编辑主公钥，将子密钥单独吊销，然后重新发布公钥即可，这样大家就都知道了。
## `change-usage`
```
gpg> change-usage 修改密钥权限
```