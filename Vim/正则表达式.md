关于 magic，vim 中有个 magic 的设定。默认设置是 magic，vim 也推荐大家都使用 magic 的设置，在有特殊需要时，直接通过 `\v` `\m` `\M` `\V` 即可。设定方法为：
```
:set magic " 设置magic
:set nomagic " 取消magic
:h magic " 查看帮助
```
vim 规定，正则表达式的元字符必须用反斜杠进行转义，但是，像 `*` 这种极其常用的元字符，都加上反斜杠就太麻烦了。所以 **magic 就是设置哪些元字符要加反斜杠哪些不用加**的。 简单来说：

*   magic(\m)：除了 `$ . * ^` 之外其他元字符都要加反斜杠。
*   nomagic(\M)：除了 `$ ^` 之外其他元字符都要加反斜杠。

这个设置也可以在正则表达式中通过 `\m` `\M` 开关临时切换。 `\m` 后面的正则表达式会按照 magic 处理，`\M` 后面的正则表达式按照 nomagic 处理， 而忽略实际的 magic 设置。另外还有更强大的 `\v` 和 `\V`。

*   `\v` （即 very magic 之意）：任何元字符都不用加反斜杠
*   `\V` （即 very nomagic 之意）：任何元字符都必须加反斜杠

例如：
```
/\v(a.c){3}$ # 查找行尾的abcaccadc
/\m(a.c){3}$ # 查找行尾的(abc){3}
/\M(a.c){3}$ # 查找行尾的(a.c){3}
/\V(a.c){3}$ # 查找任意位置的(a.c){3}$
```

对于比较熟悉正则表达式的朋友来说, `\v` 自然是上上之选.
## 量词
本文下面使用的元字符都是 magic 模式(除了 `$ . \* ^`之外其他元字符都要加反斜杠)下的,在 very magic 模式下,只需要将 `\` 去掉即可.

| 元字符      | 意义                                              |
| -------- | ----------------------------------------------- |
| *        | 匹配0个或多个(匹配优先)                                   |
| `\+`     | 匹配1个或多个(匹配优先)                                   |
| `\?或=`   | 0个或1个(匹配优先)，?不能在 ? 命令（逆向查找）中使用                  |
| `\{n,m}` | 匹配n个到m个(匹配优先),如\\d{1, 3}可以匹配1到3个数字,类似11, 1, 333 |
| `\{n,}`  | 最少n个(匹配优先)                                      |
| `\{,m}`  | 最多m个(匹配优先)                                      |
| `\{n}`   | 恰好n个                                            |
说明一下,用于限定数量的元字符不单可以用于字符,同时也可以用于模式,举个例子:`\(123\)\{2}`可以匹配123123.

### 常用的元字符

| 元字符 | 说明  |
| --- | --- |
| .   | 匹配任意一个字符,如p\*p可以匹配字符串pep, pip或者pcp |
| \[abc\] | 匹配方括号中的任意一个字符。可以使用-表示字符范围 |
| \[a-z0-9\] | 匹配小写字母和阿拉伯数字 |
| \[^abc\] | 在方括号内开头使用^符号，表示匹配除方括号中字符之外的任意字符 |
| \\a | 所有的字母字符. 等同于\[a-zA-Z\] |
| \\A |     |
| \\b |     |
| \\d | 匹配阿拉伯数字，等同于\[0-9\] |
| \\D | 匹配阿拉伯数字之外的任意字符，等同于\[^0-9\] |
| \\e |     |
| \\f |     |
| \\F |     |
| \\h |     |
| \\H |     |
| \\i |     |
| \\I |     |
| \\k |     |
| \\K |     |
| \\l | 小写字母\[a-z\] |
| \\L | 非小写字母\[^a-z\] |
| \\o |     |
| \\O |     |
| \\p |     |
| \\P |     |
| \\r |     |
| \\s | 匹配空白字符，等同于\[ \\t\] |
| \\S | 匹配非空白字符，等同于\[^ \\t\] |
| \\t | 匹配字符 |
| \\u | 大写字母 \[A-Z\] |
| \\U | 非大写字幕\[^A-Z\] |
| \\w | 匹配单词字母，等同于\[0-9A-Za-z\_\] |
| \\W | 匹配单词字母之外的任意字符，等同于\[^0-9A-Za-z\_\] |
| \\x | 匹配十六进制数字，等同于\[0-9A-Fa-f\] |
| \\X |     |
| \\~ |     |

*   \[:alnum:\] 字符数字
*   \[:ascii:\] asscii字符
*   \[:backspace:\] 退格
*   \[:cntrl:\] 控制字符
*   \[:escape:\]
*   \[:graph:\] 打印字符+ \[^\\s\]
*   \[:print:\]
*   \[:punct:\] 功能符号
*   \[:return:\] 行末符号
*   \[:black:\] \\s
*   \[:space:\]
*   \[:tab:\]
*   \[:upper:\]
*   \[:lower:\]
*   \[:alpha:\]
*   \[:digit:\]
*   \[:xdigit:\] 16进制

### 元字符的转义:

| 元字符 | 意义  |
| --- | --- |
| \\\* | 匹配 \* 字符 |
| \\. | 匹配 . 字符 |
| \\/ | 匹配 / 字符 |
| \\\|匹配\\字符 |     |
| \\\[ | 匹配 \[ 字符 |

### 表示位置的符号

| 元字符 | 含义  |
| --- | --- |
| $   | 匹配行尾,如here:$只会匹配出位于一行结尾的here:. |
| ^   | 匹配行首,如^Part只会匹配出位于一行开头的Part. |
| \\< | 会匹配出以某些字符开头的(\\<)单词. |
| \\> | 会匹配出以某些字符结尾的(\\>)单词. |

### 非贪婪匹配

| 元字符 | 意义  |
| --- | --- |
|     | \\{-n, m} |
|     | \\{-} |
|     | \\{-1,} |
|     | \\{-,1} |

### 环视/正向预查/反向预查

| 元字符 | 意义  |
| --- | --- |
| @=  | 顺序环视 |
| @!  | 顺序否定环视 |
| @<= | 逆序环视 |
| @   | 逆序否定环视 |
| @>  | 固化分组 |
| %(atom) | 非捕获型括号 |

vim 中使用零宽度断言，包括

| 符号  | vim 表符号 | 描述  | 示例  | vim 示例 |
| --- | --- | --- | --- | --- |
| `?=` | `\@=` | 正先行断言 - 存在 | `foo(?=bar)` | `foo\(bar\)\@=` |
| `?!` | `\@!` | 负先行断言 - 排除 | `foo(?!bar)` | `foo\(bar\)\@!` |
| `?<=` | `\@<=` | 正后发断言 - 存在 | `(?<=foo)bar` | `\(foo\) \@<=bar` |
| `?<!` | `\@<!` | 负后发断言 - 排除 | `(?<!foo)bar` | `\(foo\) \@<!bar` |

零宽度断言（前后预查）
-----------

先行断言和后发断言都属于**非捕获簇**（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。

例如，我们想要获得所有跟在 `$` 符号后的数字，我们可以使用正后发断言 `(?<=\$)[0-9\.]*`。 这个表达式匹配 `$` 开头，之后跟着 `0,1,2,3,4,5,6,7,8,9,.` 这些字符可以出现大于等于 0 次。

### `?=...` 正先行断言

`?=...` 正先行断言，表示第一部分表达式之后必须跟着 `?=...`定义的表达式。

返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 `()`. 在括号内部使用一个问号和等号：`(?=...)`。

正先行断言的内容写在括号中的等号后面。 例如，表达式 `(T|t)he(?=\sfat)` 匹配 `The` 和 `the`, 在括号中我们又定义了正先行断言 `(?=\sfat)` , 即 `The` 和 `the` 后面紧跟着 `\nfat`。

"(T|t)he(?=\\sfat)" => **[The](https://breezetemple.github.io/2019/10/16/vim-regex-positive-negative/#learn-regex)** fat cat sat on the mat.

### `?!...` 负先行断言

负先行断言 `?!` 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 `正先行断言` 定义和 `负先行断言` 一样，区别就是 `=` 替换成 `!` 也就是 `(?!...)`。

表达式 `(T|t)he(?!\sfat)` 匹配 `The` 和 `the`, 且其后不跟着 `\nfat`。

"(T|t)he(?!\\sfat)" => The fat cat sat on **[the](https://breezetemple.github.io/2019/10/16/vim-regex-positive-negative/#learn-regex)** mat.

### `?<= ...` 正后发断言

正后发断言 记作`(?<=...)` 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 `(?<=(T|t)he\s)(fat|mat)` 匹配 `fat` 和 `mat`, 且其前跟着 `The` 或 `the`。

"(?<=(T|t)he\\s)(fat|mat)" => The **[fat](https://breezetemple.github.io/2019/10/16/vim-regex-positive-negative/#learn-regex)** cat sat on the **[mat](https://breezetemple.github.io/2019/10/16/vim-regex-positive-negative/#learn-regex)**.

### `?<!...` 负后发断言

负后发断言 记作 `(?<!...)` 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 `(?<!(T|t)he\s)(cat)` 匹配 `cat`, 且其前不跟着 `The` 或 `the`。

"(?<!(T|t)he\\s)(cat)" => The cat sat on **[cat](https://breezetemple.github.io/2019/10/16/vim-regex-positive-negative/#learn-regex)**.

## 正则
零宽断言-正则环视(与perl相比，(?换成了@，并且这个符号应该跟在匹配模式的后边。)

* `@=` (?= 顺序环视 eg:查找后面是sql的my`: /my(sql)@=`
* `@!` (?! 顺序否定环视 eg:查找后面不是sql的my`: /my(sql)@!`
* `@<=` (?<= 逆序环视 eg: 查找前面是my的sql`: /(my)@<=sql`
* `@<!` (?<! 逆序否定环视 eg:查找前面不是my的sql`: /(my)@<!sql`
* `@>` (?> 固化分组
* `%(atom)` (?: 非捕获型括号 eg:将mysqlok替换为ok`: %s/%(my)sql(ok)/\\1`