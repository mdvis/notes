# 错误处理
错误
--

错误
--

错误
--

一个良好的程序永远不应该出发 panic 异常;对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为 ok;通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此， 额外的返回值不再是简单的布尔类型，而是error类型 通常，当函数返回 non-­nil 的 error 时，其他的返回值是未定义的(undefined),这些未定义的返回值应该被忽略。然而，==有少部分函数在发生错误时，仍然会返回一些有用的返回值==。比如，当读取文件发生错误时，Read 函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。==因此对函数的返回值要有清晰的说明==，以便于其他人使用 在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误 Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。因此，Go使用控制流机制（如if和return）处理异常，这使得编码人员能更多的关注错误处理。

### 错误处理策略

#### 错误处理常用的五种方式

1.  传播错误，函数中某个子程序的失败，会变成该函数的失败;

*   http.Parse 失败时不会直接返回HTTP错误
*   缺少两条重要信息：1. 错误发生在解析器 2. url 已经被解析 这些信息有助于错误处理
*   构造新的错误信息，fmt.Errorf 使用 fmt.Sprintf 格式化错误信息并返回
*   使用该函数前缀添加额外上下文信息到原始错误信息
*   错误信息应提供清晰的从原因到后果的因果链,错误信息经常以链式组合在一起的，所以避免大写和换行
*   如果是很长的错误信息，可以通过 grep 工具处理
*   要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性
*   即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的
*   一般而言，被调函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息

```go
// http.Get 调用失败时直接返回这个HTTP错误
resp, err:=http.Get(url)
if err != nil {
    return nil, err
}

// http.Parse 失败时不会直接返回HTTP错误
doc, err :=html.Parse(resp.Body)
resp.Body.Close()
if err!=nil{
    return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
}
```

1.  有条件的重试（设置时间间隔或重试次数）

```go
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries :=0; time.Now().Before(deadline);tries++{
        _,err:=http.Head(url)
        if err == nil {
            return nil
        }
        log.Printf("server not responding (%s);retrying...", err)
        time.Sleep(time.Second << unit(tries))
    }
    return fmt.Errorf("server %s failed to respond after %s",url,timeout)
}
```

1.  输出错误信息并结束程序（需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。）

```go
if err := WaitForServer(url); err != nil {
    fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
    os.Exit(1)
}

// 同样效果

if err := WaitForServer(url); err != nil {
    log.Fatalf("Site is down: %v\n", err)
}
```

1.  不需要中断程序，只输出错误信息（通过 log 包相关函数或标准错误流输出错误信息）

```go
if err := Ping(); err != nil {
    log.Printf("ping failed: %v; networking disabled", err)
}

if err := Ping(); err != nil {
    fmt.Fprintf(os.Stderr, "ping failed : %v; networking disabled\n", err)
}
```

1.  直接忽略错误

```go
dir, err := ioutil.TempDir("", "scratch")
if err != nil {
    return fmt.Errorf("failed to create temp dir: %v", err)
}
os.RemoveAll(dir) // 此处没有错误处理因为系统会定期清理临时目录，不会对逻辑造成影响
```

在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。

### 文件结尾错误 EOF

io包保证任何由文件结束引起的读取失败都返回同一个错误 —— io.EOF，只需简单的比较就可以检测出这个错误

```go
package io

import "errors"

var EOF = errors.New("EOF")
```

```go
in := bufio.NewReader(os.Stdin)
for {
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break
    }
    if err != nil {
        return fmt.Errorf("read feiled: %v", err)
    }
}
```

因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错 误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的 错误信息 一个良好的程序永远不应该出发 panic 异常;对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为 ok;通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此， 额外的返回值不再是简单的布尔类型，而是error类型 通常，当函数返回 non-­nil 的 error 时，其他的返回值是未定义的(undefined),这些未定义的返回值应该被忽略。然而，==有少部分函数在发生错误时，仍然会返回一些有用的返回值==。比如，当读取文件发生错误时，Read 函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。==因此对函数的返回值要有清晰的说明==，以便于其他人使用 在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误 Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。因此，Go使用控制流机制（如if和return）处理异常，这使得编码人员能更多的关注错误处理。

### 错误处理策略

#### 错误处理常用的五种方式

1.  传播错误，函数中某个子程序的失败，会变成该函数的失败;

*   http.Parse 失败时不会直接返回HTTP错误
*   缺少两条重要信息：1. 错误发生在解析器 2. url 已经被解析 这些信息有助于错误处理
*   构造新的错误信息，fmt.Errorf 使用 fmt.Sprintf 格式化错误信息并返回
*   使用该函数前缀添加额外上下文信息到原始错误信息
*   错误信息应提供清晰的从原因到后果的因果链,错误信息经常以链式组合在一起的，所以避免大写和换行
*   如果是很长的错误信息，可以通过 grep 工具处理
*   要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性
*   即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的
*   一般而言，被调函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息

```go
// http.Get 调用失败时直接返回这个HTTP错误
resp, err:=http.Get(url)
if err != nil {
    return nil, err
}

// http.Parse 失败时不会直接返回HTTP错误
doc, err :=html.Parse(resp.Body)
resp.Body.Close()
if err!=nil{
    return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
}
```

1.  有条件的重试（设置时间间隔或重试次数）

```go
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries :=0; time.Now().Before(deadline);tries++{
        _,err:=http.Head(url)
        if err == nil {
            return nil
        }
        log.Printf("server not responding (%s);retrying...", err)
        time.Sleep(time.Second << unit(tries))
    }
    return fmt.Errorf("server %s failed to respond after %s",url,timeout)
}
```

1.  输出错误信息并结束程序（需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。）

```go
if err := WaitForServer(url); err != nil {
    fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
    os.Exit(1)
}

// 同样效果

if err := WaitForServer(url); err != nil {
    log.Fatalf("Site is down: %v\n", err)
}
```

1.  不需要中断程序，只输出错误信息（通过 log 包相关函数或标准错误流输出错误信息）

```go
if err := Ping(); err != nil {
    log.Printf("ping failed: %v; networking disabled", err)
}

if err := Ping(); err != nil {
    fmt.Fprintf(os.Stderr, "ping failed : %v; networking disabled\n", err)
}
```

1.  直接忽略错误

```go
dir, err := ioutil.TempDir("", "scratch")
if err != nil {
    return fmt.Errorf("failed to create temp dir: %v", err)
}
os.RemoveAll(dir) // 此处没有错误处理因为系统会定期清理临时目录，不会对逻辑造成影响
```

在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。

### 文件结尾错误 EOF

io包保证任何由文件结束引起的读取失败都返回同一个错误 —— io.EOF，只需简单的比较就可以检测出这个错误

```go
package io

import "errors"

var EOF = errors.New("EOF")
```

```go
in := bufio.NewReader(os.Stdin)
for {
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break
    }
    if err != nil {
        return fmt.Errorf("read feiled: %v", err)
    }
}
```

因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错 误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的 错误信息 一个良好的程序永远不应该出发 panic 异常;对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为 ok;通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此， 额外的返回值不再是简单的布尔类型，而是error类型 通常，当函数返回 non-­nil 的 error 时，其他的返回值是未定义的(undefined),这些未定义的返回值应该被忽略。然而，==有少部分函数在发生错误时，仍然会返回一些有用的返回值==。比如，当读取文件发生错误时，Read 函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。==因此对函数的返回值要有清晰的说明==，以便于其他人使用 在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误 Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。因此，Go使用控制流机制（如if和return）处理异常，这使得编码人员能更多的关注错误处理。

### 错误处理策略

#### 错误处理常用的五种方式

1.  传播错误，函数中某个子程序的失败，会变成该函数的失败;

*   http.Parse 失败时不会直接返回HTTP错误
*   缺少两条重要信息：1. 错误发生在解析器 2. url 已经被解析 这些信息有助于错误处理
*   构造新的错误信息，fmt.Errorf 使用 fmt.Sprintf 格式化错误信息并返回
*   使用该函数前缀添加额外上下文信息到原始错误信息
*   错误信息应提供清晰的从原因到后果的因果链,错误信息经常以链式组合在一起的，所以避免大写和换行
*   如果是很长的错误信息，可以通过 grep 工具处理
*   要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性
*   即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的
*   一般而言，被调函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息

```go
// http.Get 调用失败时直接返回这个HTTP错误
resp, err:=http.Get(url)
if err != nil {
    return nil, err
}

// http.Parse 失败时不会直接返回HTTP错误
doc, err :=html.Parse(resp.Body)
resp.Body.Close()
if err!=nil{
    return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
}
```

1.  有条件的重试（设置时间间隔或重试次数）

```go
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries :=0; time.Now().Before(deadline);tries++{
        _,err:=http.Head(url)
        if err == nil {
            return nil
        }
        log.Printf("server not responding (%s);retrying...", err)
        time.Sleep(time.Second << unit(tries))
    }
    return fmt.Errorf("server %s failed to respond after %s",url,timeout)
}
```

1.  输出错误信息并结束程序（需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。）

```go
if err := WaitForServer(url); err != nil {
    fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
    os.Exit(1)
}

// 同样效果

if err := WaitForServer(url); err != nil {
    log.Fatalf("Site is down: %v\n", err)
}
```

1.  不需要中断程序，只输出错误信息（通过 log 包相关函数或标准错误流输出错误信息）

```go
if err := Ping(); err != nil {
    log.Printf("ping failed: %v; networking disabled", err)
}

if err := Ping(); err != nil {
    fmt.Fprintf(os.Stderr, "ping failed : %v; networking disabled\n", err)
}
```

1.  直接忽略错误

```go
dir, err := ioutil.TempDir("", "scratch")
if err != nil {
    return fmt.Errorf("failed to create temp dir: %v", err)
}
os.RemoveAll(dir) // 此处没有错误处理因为系统会定期清理临时目录，不会对逻辑造成影响
```

在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。

### 文件结尾错误 EOF

io包保证任何由文件结束引起的读取失败都返回同一个错误 —— io.EOF，只需简单的比较就可以检测出这个错误

```go
package io

import "errors"

var EOF = errors.New("EOF")
```

```go
in := bufio.NewReader(os.Stdin)
for {
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break
    }
    if err != nil {
        return fmt.Errorf("read feiled: %v", err)
    }
}
```

因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错 误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的 错误信息