# 数据类型
整型
--

### 有符号

int8, int16, int32(rune), int64

> rune 和 init32 等价，通常表示一个 Unicode 码点

### 无符号

uint8(byte), uint16, uint32, uint64

> byte 和 unit8 等价，通常用于强调数值是一个原始的数据而不是一个小的整数

### int 和 uint

一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint;其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设;因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

### uintptr

没有指定具体 bit 大小但是足以容纳指针，只有在底层编程时才需要

### 算数运算符

| 优先级1 | 优先级2 | 优先级3 | 优先级4 | 优先级5 |
| --- | --- | --- | --- | --- |
| `*` | `+` | \== | `&&` | \|  |
| `/` | `-` | `!=` |     |     |
| `%` | \| or | `<` |     |     |
| `<<` | `^` xor | `<=` |     |     |
| `>>` |     | `>` |     |     |
| `&` and |     | `>=` |     |     |
| `&^` and not |     |     |     |     |

*   算术上 `<<n` 等价于乘以 2n, ​​`>>n`​​ 等价于除以 2n
*   按位置零(AND NOT):如果对应 y 中 bit 位为 1 的话, 表达式 z = x &^ y 结果 z 的对应的 bit 位为 0，否则 z 对应的 bit 位等于 x 相应的 bit 位的值。
*   同优先级使用左优先结合规则
*   `%` 取模运算符的符号和被取模数的符号总是一致的
*   `/` 除法运算的行为则依赖于操作数是否全为整数

```text-plain
-5%3=-2
-5%-3=-2

5.0/4.0=1.25
5/4=1 // 整数除法会向着0方向截断余数
```

*   \==计算结果溢出，高位丢弃，有符号最左侧为符号为，可能最终结果是负数==

```text-plain
var u uint8 = 255
// 1111 1111, 0000 0000, 0000 0001
fmt.Println(u, u+1, u*u) // "255 0 1"

var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 ‐128 1"
```

\==无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。== 一般来说，需要一个显式的转换将一个值从一种类型转化位另一种类型，并且算术和逻辑运算的二 元操作中必须是相同的类型。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关 的问题，而且也使得程序容易理解。

```text-plain
var a int16 = 1
var b int32 = 2
var compote int = a + b // err

var compote int = int(a) + int(b) // ok
```

任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。

```text-plain
o:=0666
fmt.Printf("%d %[1]o %#[1]o\n", o)
```

请注意 fmt 的两个使用技巧。通常 Printf 格式化字符串包含多个 `%` 参数时将会包含对应相同数量的额外操作数，但是 `%` 之后的 `[1]` 副词告诉 Printf 函数再次使用第一个操作数。第二，`%` 后的 `#` 副词告诉 Printf 在用 `%o`、`%x` 或 `%X` 输出时生成 0、0x 或 0X 前缀。

浮点数

* * *

Go 提供两种浮点数，float32 和 float64，math.MaxFloat32 表示 float32 最大值，math.MaxFloat64 表示 float64 最大值 算数规范由 IEEE754 浮点数国际标准定义，IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现） 一个 float32 （单精度，1个符号位，8个指数位，23个尾数位）类型的浮点数可以提供大约 6 个十进制数的精度，而 float64（双精度，1个符号位，11个指数位，52个尾数位）则可以提供约 15 个十进制数的精度;通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且能精确表示的正整数并不是很大(译注:因为 float32 的有效 bit 位只有 23 个，其它的 bit 位用于指数 float32 和符号;当整数大于 23bit 能表达的范围时，float32 的表示将出现误差)

根据算数规范IEEE754

复数
--

两种复数类型 complex64 和 complex128 对应 float32 和 float64 两种浮点数精度 我们把形如z=a+bi（a、b均为实数）的数称为复数。其中，a称为[实部](https://baike.baidu.com/item/%E5%AE%9E%E9%83%A8/53626919?fromModule=lemma_inlink)，b称为虚部，i称为虚数单位。当z的虚部b＝0时，则z为实数；当z的[虚部](https://baike.baidu.com/item/%E8%99%9A%E9%83%A8/5231815?fromModule=lemma_inlink)b≠0时，实部a＝0时，常称z为[纯虚数](https://baike.baidu.com/item/%E7%BA%AF%E8%99%9A%E6%95%B0/3386848?fromModule=lemma_inlink)。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。 内置函数：

*   complex 用于构建复数
*   real 用于返回复数实部
*   imag 用于返回复数虚部

```text-plain
x := complex(1,2) // 1+2i
x := 1 + 2i // 1+2i
x := 2i + 1 // 1+2i
```

复数也可以使用 `==` 和 `!=` 进行比较，`math/cmplx` 包提供复数处理函数

布尔 bool

* * *

```text-plain
s != "" && s[0] == "x"
```

这样表达式总是安全的，`s[0]` 操作如果作用与空字符串将会导致 panic 异常

布尔值不会隐式转换为数值 0 或 1，反之亦然

```text-plain
i := 0
if b {
    i = 1
}

func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}

// 数字到布尔型的逆转换则非常简单, 不过为了保持对称, 我们也可以包装一个函数:

func itob(i int) bool { return i != 0 }
```

常量
--

常量表达式在编译器计算，而不是在运行期，当操作数是常量时，一些运行时的错误也可以在编译期发现，常量的所有算术运算、逻辑运算和比较运算结果也是常量。

*   len
*   cap
*   real
*   imag
*   complex
*   unsafe.Sizeof 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始 化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。

```text-plain
const (
    a = 1
    b
    c=2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"
```

### iota

生成一组相似规则初始化的常量，不用每行都写一遍初始化表达式

```text-plain
type Weekday int

const (
    Sunday Weekday = iota // 0
    Monday // 1
    Tuesday // 2
    Wednesday // 3
    Thursday // 4
    Friday // 5
    Saturday // 6
)

type Flags uint

const (
    FlagUp Flags = 1 << iota
    FlagBroadcast
    FlagLoopback
    FlagPointToPoint
    FlagMulticast
)

const (
    _   = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 << 64)
    YiB // 1208925819614629174706176
)
```

### 无类型常量

六种未明确类型的常量类型（为没有明确基础类型的常量提供比基础类型更高精度的类型）

1.  无类型的布尔型
2.  无类型的整型
3.  无类型字符
4.  无类型浮点数
5.  无类型复数
6.  无类型字符串 通过延迟明确常量具体类型，无类型常量==可以提供更高的运算精度，可以直接用于更多的表达式而不需要显示的类型转换。== 比如说上例中的 YIB、ZIB 超出任何整数类型的表达范围，但依然是合法常量 还比如 math.Pi，无类型常量可以用于任何需要浮点数的常量赋值给 float32、float64，complex128 类型，如果 math.Pi 被确定为指定类型那精度就不一样了同时对其他类型还要进行转换

```text-plain
var x float32 = math.Pi
var x float64 = math.Pi
var x complex128 = math.Pi

const Pi64 float64 = math.Pi
var x float32 = float32(Pi64)
var x float64 = Pi64
var x complex128 = complex128(Pi64)
```

除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达 式可能对应不同的结果:

```text-plain
var f float64 = 212

fmt.Println((f ‐ 32) * 5 / 9) // "100"; (f ‐ 32) * 5 is a float64 
fmt.Println(5 / 9 * (f ‐ 32)) // "0"; 5/9 is an untyped integer, 0 
fmt.Println(5.0 / 9.0 * (f ‐ 32)) // "100"; 5.0/9.0 is an untyped float
```

只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语 句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式 转换为对应的类型，如果转换合法的话。 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和 复数，可能会有舍入处理 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变 量指定明确的类型

### 分组

```text-plain
const i = 100
const pi = 3.14
const prefix = "Go_"

// 分组
const (
    i = 100
    pi = 3.14
    prefix = "Go_"
)
```

错误类型

* * *

```text-plain
err := errors.New("emit macho dwarf: elf header corrupted")
if(err != nil){
    fmt.Print(err)
}
```

数组
--

有==固定长度==的==特定类型元素==组成的序列，由于长度固定所以很少直接使用，Slice是可以增长和收缩的动态序列，更灵活，但要理解 slice 需要先理解数组

*   元素可通过索引下标访问，索引从零开始，len 函数返回数组元素个数
*   数组每个元素会被初始化为元素类型的零值，也可使用一组值来初始化`[3]int{1,2,3}`​
*   数组字面值中出现 `...`​ 表示长度有初始化元素个数决定 `[...]int{1,2,3}`​
*   数组长度是数组类型的一部分 `[3]int`​ 和 `[4]int`​ 是不同类型
*   数组、slice、map、struct 字面值的写法很相似，直接提供初始值序列，或者指定索引和对应值的方式初始化 `[3]int{0:0,1:1,2:2}`​ 定义一个含有 100 个元素的数组 `[...]int{99: -1}`​ 第 100 个元素初始化为 -1 其他为零值
*   一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的(必须是同类型数组，所有元素相等才相等)

```text-plain
[2][4]int{ [4]int{1,2,3,4}, [4]int{1,2,3,4} }

[2][4]{ {1,2,3,4}, {1,2,3,4} }
```

Slice 动态数组

* * *

和数组一样，只是没有长度声明 `var fslice []int`​

*   切片代表变长的序列，元素为相同类型，一般写作 `[]T`​；
*   类似数组，无固定长度，slice 是数组子序列，底层引用一个底层数组；
*   一个 slice 有三部分构成：指针、长度、容量；
*   指针指向 slice 第一个元素对应底层数组元素的地址；长度对应 slice 元素个数，不能超过容量；容量为 slice 开始的位置到底层数组的结尾位置；len 和 cap 分别返回长度和容量

### 切片操作

*   ​`s[i:j] 0 <= i <= j <= cap(s)`​
*   从第 i 元素开始，到 j - 1 个元素结束，长度 j - i
*   i 被省略将从 0 开始，j 被省略将从 len(s) 开始
*   字符串的切片操作和 \[\]byte 字节类型切片的切片操作是类似的
*   x\[m:n\]切片操作对于字符串则生成一个新字符串，如果x是\[\]byte的话则生成一个新的\[\]byte
*   一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数，第一次是反转开头的n 个元素，然后是反转剩下的元素，最后是反转整个slice的元素。(如果是向右循环旋转，则将第三 个函数调用移到第一个调用位置就可以了
*   和数组不同的是，slice之间不能比较，因此我们不能使用操作符来判断两个slice是否含有全部相 等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等 (\[\]byte)，但是对于其他类型的slice，我们必须自己展开每个元素进行比较
*   slice唯一合法的比较操作是和nil比较
*   通过 len(s) == 0 来判断 slice 是否为空，不应使用是否为 nil 判断
*   使用 make 创建时，cap 可以省略 `make([]T, len)`​ `make([]T, len, cap)`​

```text-plain
var s []int // nil
s = nil // nil
s = []int(nil) // nil
s = []int{} // != nil
```

### append

*   用来向 slice 追加元素，append 过程中，先检测 slice 底层数组 cap 是否足够容纳新增元素，如果足够直接扩展 slice，将新元素直接复制到扩展的空间，新老 slice 共用一个底层数组。如果 cap 不足以容纳新元素，会先分配一个足够大的 slice，将原来的值和新增的值都添加到新的 slice，新老 slice 不会共用一个底层数组
*   copy 函数第一个参数是要复制的目标 slice，第二个参数是源 slice，目标和源的位置顺序和 dst = src 复制语句是一致的。会返回成功复制的元素个数（等于两个 slice 中长度较小的那个）
*   为了提高内存使用效率，新分配的数组一般略大于保存被操作的两个 slice 所需要的最低大小。通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间

```text-plain
func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    if zlen <= cap(x) {
        z = x[:zlen]
    } else {
        zcap := zlen
        if zcap < 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x)
    }
    copy(z[len(x):], y)
    return z
}
```

内置的append函数可能使用比appendInt更复杂的内存扩展策略。因此，通常我们并不知道append 调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的 底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是 将append返回的结果直接赋值给输入的slice变量`a = append(a, b)`​ 要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是 slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样 一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型

```text-plain
type Slice struct {
    array unsafe.Pointer
    len, cap int
}
```

### copy

Copy from one slice to another

```text-plain
var s = make([]int, 3)
n := copy(s, []int{0, 1, 2, 3}) // n == 3, s == []int{0, 1, 2}
```

Copy from a slice to itself

```text-plain
s := []int{0, 1, 2}
n := copy(s, s[1:]) // n == 2, s == []int{1, 2, 2}
```

Copy from a string to a byte slice (special case)

```text-plain
var b = make([]byte, 5)
copy(b, "Hello, world!") // b == []byte("Hello")
```

### 内存技巧

```text-plain
// pop
top := stack[len(stack) - 1]
stack = stack[:len(stack) - 1]

// splice(slice,b)
copy(slice[b:],slice[b+1:])
slice[:len(slice)-1]
```

Map

* * *

哈希表是是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的 key 可以在常数时间复杂度内检索、更新或删除对应的value。 一个 map 就是是个哈希表的引用，map\[K\]V，所有 key 都有相同类型，所有 value 也有相同类型；key 必须是支持 == 比较运算符的数据类型。

```text-plain
// 创建一个 map

// make 创建
make(map[string]string)

// 字面值创建
map[string]int{
    "name": "deve",
    "age": "34",
}

// 创建空 map
map[string]int{}

// 删除元素
delete(theMap, theKey)

theMap[theKey]+=1
theMap[theKey]++
```

#### 声明

```text-plain
var myMap map[string] PersonInfo
var <var_name> map[key_type>] <val_type>
```

#### 创建

```text-plain
myMap = make(map[string] PersonInfo)
myMap = make(map[string] PersonInfo, 100)
myMap = map[string] PersonInfo {
    "123": PersonInfo{"12", "jack", "Room 444,..."}
}
```

#### 赋值

```text-plain
myMap["123"] = PersionInfo{"1","jack","Room 595,..."}
```

#### 删除

```text-plain
delete(myMap, 'key')
```

#### 查找

```text-plain
value, ok := myMap["key"] // 使用ok-idiom获取值，可知道key/value是否存在
if ok {}
```

所谓ok-idiom模式，是指在多返回值中用一个名为ok的布尔值来标示操作是否成功。因为很多操作默认返回零值，所以须额外说明

向 map 存数据前必须先创建，零值 nil 的 map 写入元素会导致 panic 要注意的是 map 的元素并不是一个变量，所以不能对 map 的元素进行取址操作 `&theMap[theKey]`​ 禁止对 map 元素取址的原因是随着 map 元素数量的增长 map 可能会重新分配更大的内存空间，导致之前地址无效。 遍历可以使用 `range`​ 和 slice 类似，遍历顺序每次不同（每次都使用随机的遍历顺序可以强制 要求程序不会依赖具体的哈希函数实现），要按顺序遍历可以先对 key 排序 `sort.Strings([]string)`​

```text-plain
for key, value := range theMap {}
```

map 中区分元素值为 0 时，是零值的 0，还是真是存在的 0

```text-plain
age, ok := theMap[theKey]
if !ok {/* 这时说明是零值的 0 */}

if age, ok := theMap[theKey];!ok {}
```

和 slice 一样，除了值为 nil 的 map 也不能进行比较

```text-plain
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false 
    }
    for k, xv := range x {
        // 判断 map 间元素是否相同，
        // 不能只单纯比较 value（xv != yv)
        // 值为零，和值为零值是要区分
        // 需使用 !ok || xv != yv
        if yv, ok := y[k]; !ok || yv != xv { 
            return false
        }
    }
    return true
}

equal(map[string]int{"A": 0}, map[string]int{"B": 42}) // map1,map2 的 A 值都为零，但性质不一样
```

使用 slice 作为 key，绕过 map 的 key 必须是可比较的限制

1.  定义一个将 slice 转为 map 对应的 string 类型的 key 的函数，确保 key1 和 key2 相等时 f(key1) == f(key2) 才成立
2.  创建一个 key 为 string 类型的 map，每次对 map 操作时先用辅助函数将 slice 转为 string

make

* * *

make 用于内建类型（slice/map/channel）的内存分配

*   make 只能创建 slice/map/channel 并返回有初始值（非零）的 T 类型，而不是 `*T`​
*   指向数据结构的引用在使用前必须被初始化，如 slice 是一个包含指向数据（内部 array ）的指针、长度、容量的三项描述符在这些被初始化之前，slice 为 nil，make 初始化了数据结构填充适当的值，返回初始化后的（非零）值。

### slice

make(T, len\[, cap = len\])

### map

make(T \[, init\_space\])

### channel

make(T \[, buffer\_size\])

new

* * *

new 用于各种类型的内存分配，本质上和其他语言中的同名函数一样，new（T）分配了零值填充的 T 类型的内存空间，返回其地址 `*T`​ (返回的是指针) ==零值== int,int8,int32,int64,float32,float64 0 unit 0x0 rune 0 byte 0x0 bool false string ""

‍# base 基本
综合基础

* * *

\[TOC\]

关键字

* * *

| 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- |
| break | default | func | interface | select | case | defer |
| go  | map | struct | chan | else | goto | package |
| switch | const | fallthrough | if  | range | type | continue |
| for | import | return | var |     |     |     |

变量
--

变量是一段或多段用来存储数据的内存。变量的生命和初始化是分开的，运行时内存分配操作会确保变量自动初始化为二进制零值，避免不可预测行为发生。显示提供初始值可省略类型由编译器推断

### 变量声明

支持类型推断，明确的基础类型划分有助于编写跨平台应用。

var 关键字

```go
var <variable_name> <type>
var v1 int
var v2 string
var v3 [10]int
var v4 []int
var v5 struct {
    f int
}
var v6 *int
var v7 map[string]int
var v8 func(a int)int
var (
    v9 int
    v10 string
)
```

### 变量初始化

go 指定类型不是必须的，可以根据右值推导出 ==只能用在函数内部== ==只能用在函数内部== ==只能用在函数内部==

```go
var v1 int = 10
// 一下两种可以自动推导类型
var v2 = 10

// 简短模式
// 冒号和等号的组合 :=
// 用于明确表达同时进行变量声明和初始化的工作。
// 定义变量，同时显示初始化
// 不能提供数据类型
// 只能用在函数内部
v3 := 10
```

#### 退化为赋值操作

\==退化赋值的前提条件是：最少有一个新变量被定义，且必须为同一作用域==

\==在处理函数错误时，退化赋值允许我们重复使用err变量==

```
// 退化为赋值操作
// 退化赋值的前提条件是：最少有一个新变量被定义，且必须为同一作用域
x := 1
x, y:=2,4 // 由于前面以声明x，这里x退化为赋值操作，只有y是变量定义，

x:=1
x:=2 // err: no new variables on left side of :=

x:=1
{
x, y := 3,4 // err: 不同作用域，全部为新变量定义
}
```

### 变量赋值

多重赋值

```go
var v1,v2 int = val1, val2
var v1,v2 = val1, val2
```

### 匿名变量, 空标识符

\_ 是特殊变量，所有赋给 \_ 的值都会被丢弃，无法读取内容

用来临时规避编译器对未使用变量和导入包的错误检查

\==预置成员，不能重新定义==

```go
func GetName() (firstName, lastName, nickName string){
    return 'May', 'Chan', 'Chibi' //多重返回
}

_, _, nickName := GetName() //匿名变量
```

### 类型转换

```go
[]byte(s) // 将s转换为[]byte类型
srting(c) 将c转换为string类型
```

### 类型断言

`v.(T)` v 不为 nil，且 v 可以转换为 T 类型，就断言==成功，返回 T 类型的值==，如果 T 不是接口类型，则要求 x 的类型就是 T，如果 T 是一个接口，要求 x 实现了 T 接口。

常量
--

常量通常是一些字面量，常量值必须是编译期可确定的字符、字符串、数字或布尔值，或者编译器可以计算出结果的表达式。不曾使用的常量不会引发编译错误。

不同于变量在运行期分配存储内存（非优化内存），常量通常会被编译器在预处理阶段直接展开，做为指令数据使用。

```go
const y = 0x200

pringln(&y) // error: cannot take the address of y

// 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址
```

```go
const x=100         // 无类型声明的常量
const y byte=x       // 直接展开x，相当于const y byte=100

const a int=100      // 显式指定常量类型，编译器会做强类型检查
const b byte=a       // 错误:cannot use a(type int)as type byte in const initializer
```

常量组初始化时如果不指定类型，则与上一行非空常量右值相同

```go
const (
x int = 1
y  // 与上一行x类型右值相同 也是int
z = "a"
s // string
)
```

### 字面常量 literal

所谓字面常量（literal），是指程序中硬编码的常量，如：

\-12 3.14159265358979323846 // 浮点类型的常量 3.2+12i // 复数类型的常量 true // 布尔类型的常量 "foo" // 字符串常量

### 常量定义

const 关键字

```go
const Pi float64 = 3.141592654
```

常量定义的右值也可以是一个在编译期运算的常量表达式，比如`const mask = 1 << 3`

由于常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达 式，比如试图以如下方式定义常量就会导致编译错误：`const Home = os.GetEnv("HOME")`原因很简单，os.GetEnv()只有在运行期才能知道返回结果，在编译期并不能确定，所以 无法作为常量定义的右值。

### 预定义常量

Go语言预定义了这些常量：true、false和iota

iota比较特殊，可以被认为是一个可被编译器修改的常量，在每一个const关键字出现时被 重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字会自动增1。

```go
const (
    c0 = iota // iota被重设为0
    c1 = iota
    c2 = iota
)

const (
    a = 1 << iota //iota 每个const开头被重置成0
    b = 1 << iota
    c = 1 << iota
)
```

如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。因此，上面的两个const语句可简写为：

```go
const (
    c0 = iota // iota被重设为0
    c1
    c2
)

const (
    a = 1 << iota //iota 每个const开头被重置成0
    b
    c
)
```

### 枚举

枚举指一系列相关的常量，可以用在const后跟一对圆括号的方式定义一组常量，这种定义法在Go语言中通常用于定义枚举值。Go语言并不支持众多其他语言明确支持的enum关键字。需要借助**iota**标识符实现一组自增常量值来实现枚举功能。

下面是一个常规的枚举表示法，其中定义了一系列整型常量：

```go
const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    numberOfDays // 这个常量没有导出
)
```

同Go语言的其他符号（symbol）一样，**以大写字母开头的常量在包外可见**。 以上例子中numberOfDays为包内私有，其他符号则可被其他包访问。

```go
const (
    _,_ = iota, iota*10 // 0, 0*10
    a,b  // 1, 1*10
    c,d  // 2, 2*10
)

// 默认int
const (
a = iota //int
b float32 = iota
c = iota // 名有明确指定类型和b一样
)

// 自定义类型
type color  byte

const (
black color = iota
red
)
```

类型
--

| 类型  | 长度  | 默认  | 说明  |
| --- | --- | --- | --- |
| bool | 1   | false |     |
| byte | 1   | unit8 |     |
| int,uint | 4,8 | 默认整数类型，平台相关 |     |
| int8,uint8 | 1   | \-128-127，0-255 |     |
| int16,uint16 | 2   | \-32768-32767，0-65535 |     |
| int32,uint32 | 4   | \-21亿-21亿，0-42亿 |     |
| int64,uint64 | 8   |     |     |
| float32 | 4   | 0.0 |     |
| float64 | 8   | 0.0 | 默认浮点数类型 |
| complex64 | 8   |     |     |
| complex128 | 16  |     |     |
| rune | 4   | 0   | Unicode Code Point，int32 |
| uintptr | 4,8 | 0   | 足以存储指针的uint |
| string |     | ""  | 字符串，默认为空字符串，而非NULL |
| array |     |     | 数组  |
| struct |     |     | 结构体 |
| function |     | nil | 函数  |
| interface |     | nil | 接口  |
| map |     | nil | 字典，引用类型 |
| slice |     | nil | 字典，引用类型 |
| channel |     | nil | 字典，引用类型 |

**strconv 库可在不同进制（字符串）间转换**,静态类型，强类型（类型决定内存长度和存储格式）

*   基础类型
    *   布尔类型：bool
    *   整型：int8、byte、int16、int、uint、uintptr等
    *   浮点类型：float32、float64
    *   复数类型：complex64、complex128
    *   字符串：string
    *   字符类型：rune
    *   错误类型：error
*   复合类型
    *   指针（pointer）
    *   数组（array）
    *   切片（slice）
    *   字典（map）
    *   通道（chan）
    *   结构体（struct）
    *   接口（interface）

对于常规的开发来说，用int 和uint就可以了，没必要用int8之类明确指定长度的类型，以免导致移植困难。

### 别名

专门提到两个别名

*   byte alias for uint8
*   rune alias for int32

别名类型无需转换，可直接赋值

```go
var a byte = 0x11
var b uint8 = a
```

### 引用类型

所为引用类型特指slice map channel这三种预定义类型

**相比数字、数组等类型，引用类型拥有更复杂的存储结构。除分配内存外，它们还须初始化一系列属性，诸如指针、长度，甚至包括哈希分布、数据队列等。**

内置函数new按指定类型长度分配零值内存，返回指针，并不关心内部构造和初始化方式。而引用类型必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。

除new/make函数外，也可使用初始化表达式，编译器生成的指令基本相同。

当然，new函数也可为引用类型分配内存，但这是不完整创建。以字典（map）为例，它仅分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。

### 转换类型

除常量、别名类型以及未命名类型外，Go要求强制使用显示类型转换。加上不支持重载，所以总能明确确定语句及表达式的明确含义。

### 语法歧义

如果转换的目标是指针、单向通道或没有返回值的函数类型，那么必须使用括号，以避免造成语法分解错误。

```go
(*int)(p)          --> 如果没有括号 -->  *(int(p))
(<-chan int)(c)                <-(chan int(c))
(func())(x)                       func()x

func()int(x)           --> 有返回值的函数类型可省略括号，但依然建议使用。
(func()int)(x)                  使用括号后，更易阅读
```

### 自定义类型

使用 type 关键字定义用户自定义类型，包括基于现有基础类型创建，或者是结构体，函数类型等。

```go
type flag byte
```

type 类型像var const 一样，也可以合并成组

```go
type (
    user struct {}
    event func(string) bool
)
```

即便指定了基础类型，也只表明它们有相同底层数据结构，两者间不存在任何关系，属完全不同的两种类型。除操作符外，自定义类型不会继承基础类型的其他信息（包括方法）。不能视作别名，不能隐式转换，不能直接用于比较表达式。

```go
func main() {
   type data int
   var d data=10

   var x int=d       // 错误:cannot use d(type data)as type int in assignment
   println(x)

   println(d==x)      // 错误:invalid operation:d==x(mismatched types data and int)
}
```

### 未命名类型

与有明确标识符的bool、int、string等类型相比，**数组、切片、字典、通道等类型与具体元素类型或长度等属性有关，故称作未命名类型（unnamed type）** 。当然，可用type为其提供具体名称，将其改变为命名类型（named type）。

具有相同声明命的未名类型被视作同一类型

*   具有相同基类型的指针
*   具有相同元素类型和长度的数组
*   具有相同元素类型的切片
*   具有相同键值类型的字典
*   具有相同数据类型及操作方向的通道
*   具有相同字段序列（字段名 字段类型 标签 及字段顺序）的结构体
*   具有相同签名（参数和返回值列表，不包括参数名）的函数
*   具有相同方法集（方法名 方法签名 不包括顺序）的接口

需要注意的是struct tag也属于类型组成部分，不只是数据描述。函数的参数顺序也属于签名组成部分

```go
var a struct {x string 'tag'} // 匿名结构体
var b struct {x string}

a=b //error->tag

var a func(int,string)
var b func(string,int)

a=b //error->顺序
```

未命名转换规则

*   所属类型相同
*   基础类型相同，且其中一个是未命名类型
*   基础类型相同，将双向通道赋值给双向通道，且其中一个为未命名类型
*   将默认值nil赋值给切片 字典 通道 指针 函数或接口
*   对象实现了目标接口

### 整型

| 类型  | 长度（字节） | 值范围 |
| --- | --- | --- |
| int8 | 1   | 128 ~ 127 |
| uint8（即byte） | 1   | 0 ~ 255 |
| int16 | 2   | 32768 ~ 32767 |
| uint16 | 2   | 0 ~ 65535 |
| int32 | 4   | 2147483 648 ~ 2147483 647 |
| uint32 | 4   | 0 ~ 4294967295 |
| int64 | 8   | 9223372036854775808~9223372036854775807 |
| uint64 | 8   | 0 ~ 18446744073709551615 |
| int | 平台相关 | 平台相关 |
| uint | 平台相关 | 平台相关 |
| uintptr | 同指针 | 在32位平台下为4字节，64位平台下为8字节 |

### 类型表示

### 数值运算 (+,-,\*,/,%)

### 比较运算 (>,<,==,>=,<=,!=)

两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但 各种类型的整型变量都可以直接与字面常量（literal）进行比较

```go
var i int32
var j int64

i,j = 1,2

if i == j {} //编译错误 类型不同
if i == 1 {} //编译通过 字面量
```

### 位运算

*   <<
*   ^ 异或 x ^ y
*   &
*   |
*   ^ 取反 ^x

### 浮点类型

表示包含小数点的数据 go语言中的float32 float64分别对应c语言的float double 类型推导会将浮点类型自动推导为float64

#### 浮点数比较

因为浮点数不是一种精确的表达方式，所以像整型那样直接用==来判断两个浮点数是否相等 是不可行的，这可能会导致不稳定的结果。推荐使用

```go
import math

// p 为自定义的比较精度, 如 0.00001
func IsEqual(f1,f2,p float 64) bool {
    return math.Fdim(v1,v2) < p
}
```

### 复数类型

#### 复数表示

复数实际上由两个实数(在计算机中用浮点数表示)构成，一个表示实部(real)，一个表示虚部(imag)

我们把形如 z=a+bi（a、b均为实数）的数称为复数。其中，a 称为实部，b 称为虚部，i 称为虚数单位。当 z 的虚部 b＝0 时，则 z 为实数；当 z 的虚部 b≠0 时，实部 a＝0 时，常称 z 为纯虚数。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。

```go
v1 := 3.2 + 12i  // v1是complex128类型
v2 := complex(3.2, 12) // 同上
```

#### 实部与虚部

```go
z = complex(x,y)
real(z) // 获得实部x
imag(z) // 获得虚部y
```

### 字符串

双引号或反引号包裹

*   len
*   Printf
*   Println

#### 字符串操作

*   x + y
*   len
*   s\[ind\]

#### 字符串遍历

```go
for i := 0; i < n; i++ {
    ch := str[i]
    fmt.Println(i, ch)
}

// 中文在utf-8中站三个字节长度是3

for i, ch := range str {
    fmt.Println(i, ch)
}
```

### 字符类型

在Go语言中支持两个字符类型

*   一个是byte（实际上是uint8的别名），代表UTF-8字符串
*   一个是rune，代表单个Unicode字符

### 数组

#### 声明方法

*   \[32\] byte // 长度32的数组，每个元素一字节
*   \[2 \* N\] struct {x, y init32} // 复杂类型数组
*   \[1000\] \* float64 // 指针数组
*   \[3\] \[5\] int // 二维数组
*   \[2\] \[2\] \[2\] float64 // 等同 \[2\] ( \[2\] ( \[2\] float64))

在Go语言中，数组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量 表达式（常量表达式是指在编译期即可计算结果的表达式）。数组的长度是该数组类型的一个内 置常量，可以用Go语言的内置函数len()来获取。

#### 元素访问

*   下标
*   range 关键字

```go
array := [2] int

for i, v := range array {}
```

需要特别注意的是，在Go语言中数组是一个值类型（value type）。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。

### 数组切片

每次传递都将产生一份副本。显然这种数据结构无法完全满足开发者的真实需求。

切片拥有自己的数据结构，而不仅仅是个指针。数组切片的数据结构可以抽象为以下3个变量：

*   一个指向原生数组的指针
*   数组切片中的元素个数
*   数组切片已分配的存储空间

数组切片实际上仍然使用数组来管理元素，基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致所管理的元素被重复复制。

#### 创建数组切片

1.  基于数组 `var myslice []int = myarray[:5]`
2.  直接创建

```go
    // make 内置函数 可以用于创建切片
    myslice := make([]int, 5) // 初始元素个数为5的数组切片，元素初始值为0
    myslice := make([]int, 5, 10)  // 初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间
    myslice := []int{1,2,3,4,5}  // 初始化包含5个元素的数组切片
```

#### 遍历

#### 动态增减

与数组相比，数组切片多了一个存储能 力（capacity）的概念，即元素个数和分配的空间可以是两个不同的值。

*   cap // 分配空间的大小
*   len // 存储元素的个数
*   append // 追加元素

```go
myslice = append(myslic, 1,2,3)

myslice2 := []int{1,2,3}
myslice = append(myslice, myslice2...) // 数组后面三个点...打散数组
```

#### 基于切片创建切片

#### 内容复制

*   copy 数组切片支持Go语言的另一个内置函数copy()，用于将内容从一个数组切片复制到另一个 数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行 复制。# express
表达式

* * *

\[TOC\]

保留字

* * *

| 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- |
| break | default | func | interface | select |
| case | defer | go  | map | struct |
| chan | else | goto | package | switch |
| const | fallthrough | if  | range | type |
| continue | for | import | return | var |

运算符

* * *

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| ()  | \-  | ^   | \*= | <<= | ++  | \-- | !   |
| +   | .   | &   | +=  | &=  | &&  | \== | !=  |
| \|  | \-= | \|= | \|  | <   | <=  | \[\] | \*  |
| ^=  | <-  | \>  | \>= | {}  | /   | <<  | /=  |
| \=  | :=  | ,   | ;   | %   | \>> | %=  | \>>= |
| ... | :   | &^  | &^= |     |     |     |     |

幂等 math.Pow 绝对值 math.Abs

位移右操作数必须是无符号整数，或可以转换的无显示类型常量。非常量位移表达式，会优先将无显式类型的常量左操作数转型

*   AND &
*   OR |
*   XOR a^b
*   NOT ^a
*   AND NOT(按位清除) &^
*   LEFT SHIFT(位左移) <<
*   RIGHT SHIFT >>

位清除：左右操作数对应二进制位都为1的重置为0

```go
const( 
   read  byte=1<<iota
   write
   exec
   freeze
) 

func main() { 
   a:=read|write|freeze
   b:=read|freeze|exec
   c:=a&^b     // 相当于a^read^freeze，但不包括exec

   fmt.Printf("%04b&^ %04b= %04b\n",a,b,c) 
}
```

自增 自减不再是运算符。只能作为独立语句，不能用于表达式

指针
--

*   不能将内存地址与指针混为一谈
*   内存地址：内存中每个字节单元的唯一编号
*   指针： 一个实体，会分配内存空间，相当于一个专门用来保存地址的整型变量
*   取址运算符 “&” 用于获取对象地址
*   指针运算符 “\*” 用于间接引用目标对象
*   二级指针\*\_T，如包含包名则可写成\_package.T

并非所有对象都能进行取地址操作，但变量总是能正确返回（addressable）。指针运算符为左值时，我们可更新目标对象状态；而为右值时则是为了获取目标状态。

初始化

* * *

复合类型（arr, splice, map,struct)

*   初始化表达式必须含类型标签
*   左花括号必须在类型尾部，不能另起一行
*   多个成员初始值以逗号分隔
*   允许多行，但每行须以逗号或右花括号结束

流控制

* * *

### if

初始化语句支持，可定义块局部变量或执行初始函数，局部变量的有效范围包含整个if/else块

```go
if xinit();x==0{}
if a,b:=x,y;a<b{}
```

### switch

*   switch 也支持初始化语句
*   省略switch条件默认值为true
*   空case不构成多条件匹配，隐式 break，case执行完毕后自动中断。
*   **如须贯通后续case（源码顺序），须执行fallthrough，但不再匹配后续条件表达式。**
*   fallthrough 必须在case结尾，可使用breake阻止

```go
switch x：=5， x {
    case a,b: // 多条件满足其一即可OR
    ...
    case 5:
    fallthrough
    case 6:
    ...
    case 7：
    if x > 10 {
    break
    }
    fallthrough
    default:
    ...
}
```

### for

初始化语句仅被执行一次。条件表达式中如有函数调用，须确认是否会重复执行。可能会被编译器优化掉，也可能是动态结果须每次执行确认。

for...range 迭代支持字符串 数组 数组指针 切片 字典 通道 返回索引和键值数据

### goto continue break

*   goto 使用goto前必须先定义标签，区分大小写 不能跳转到其他函数或内层代码块
*   break 用于 Switch for select，终止整个语句块执行
*   continue 仅用于for，终止后续逻辑，进入下次循环

break 和 continue 可以配合标签在多层嵌套中指定目标层级

```go
func main() { 
outer: 
   for x:=0;x<5;x++ { 
       for y:=0;y<10;y++ { 
           if y>2{ 
               println() 
               continue outer
            } 
           if x>2{ 
               break outer
            } 

           print(x, ":",y, " ") 
        } 
    } 
}
```

二级指针

```go
func test(p **int){
    x:=100
    *p =&x
}
func main(){
var i *int
test(&i)
fmt.Println(*i)
}
```

函数参数过多建议使用一个复合结构类型

```go
type serverOption struct{ 
   address string
   port  int
   path  string
   timeout time.Duration
   log    *log.Logger
} 

func newOption() *serverOption{ 
   return &serverOption{             // 默认参数 
       address: "0.0.0.0", 
       port:   8080, 
       path:    "/var/test", 
       timeout:time.Second*5, 
       log:    nil, 
    } 
} 

func server(option *serverOption) {} 

func main() { 
   opt:=newOption() 
   opt.port=8085         // 命名参数设置 

   server(opt) 
}
```

变参
--

变参本质上是一个切片，只能接收同类型参数，在最尾部

```go
func test(s string, a ...int){}
```

变参中，参数是数组时需要转为切片，切片需要展开传入

```go
a := [2]int{1,2}
test(a[:]...)
```

既然变参是切片，那么参数复制的仅是切片自身，并不包括底层数组，也因此可修改原数据。如果需要，可用内置函数copy复制底层数据

```go
a:=[]int{1,2}
test(b ...int){b[1]=10}
println(a) //[]int{1,10}
```

返回值

* * *

```go
func F1() (int,error){}
// 命名返回值
func F1() (i int, err error){
  return  // 相当于 return i,err 隐式返回
}
```

命名返回值和参数一样，可当做局部变量使用，最后由return隐式返回 如果返回值类型能明确表明其含义，就尽量不要对其命名

匿名函数

* * *

```go
func a(){
    func (s int){}(1) // 自执行
    b:=func(){} // 赋值给变量
    func test(f func()){f()}
    test(func(){}) // 作为参数
    return func(){} // 作为返回值
}
```

将匿名函数赋值给变量，与为普通函数提供名字标识符有着根本的区别。当然，编译器会为匿名函数生成一个“随机”符号名。

普通函数和匿名函数都可作为结构体字段，或经通道传递。

```go
type A struct {
    F func(x,y int)int
}
x:=A{F:func(x,y int)int{return x+y}}
```

### 闭包

闭包是函数和引用环境的组合体，闭包让我们不用传递参数就可读取或修改环境状态，当然也要为此付出额外代价。对于性能要求较高的场合，须慎重使用。

延迟调用

* * *

defer 常用于资源释放 解除锁定以及错误处理等

延迟调用注册的是调用，参数值在注册时被复制并缓存起来，如对状态敏感可用指针

```go
func main(){
    x,y:=1,2
    defer func(a int){
        a,y // 1,202
    }(x) // 注册时就被缓存
    x=101
    y=202
    x,y // 101,202
}
```

编译器通过插入额外指令来实现延迟调用执行，而return和panic语句都会终止当前函数流程，引发延迟调用。另外，return语句不是ret汇编指令，它会先更新返回值。

延迟调用需要额外开销，对性能有要求的地方应避免使用

错误处理

* * *

在最后一个参数返回error类型的错误状态

```go
type error interface{
    Error()string
}
```

错误变量通常以err作为前缀，且字符串内容全部小写，没有结束标点，以便于嵌入到其他格式化字符串中输出。

*   errors.New
*   fmt.Errorf 返回一个格式化内容的错误对象

自定义错误类型, 自定义错误类型通常以Error为后缀

```go
type DivError struct{              // 自定义错误类型 
   x,y int
} 

func(DivError)Error()string{          // 实现error接口方法 
   return"division by zero" 
} 

func div(x,y int) (int,error) { 
   if y==0{ 
       return 0,DivError{x,y}            // 返回自定义错误类型 
    }
    return x/y,nil
} 

func main() { 
   z,err:=div(5,0) 

   if err!=nil{ 
       switch e:=err.(type) {            // 根据类型匹配 
       case DivError: 
           fmt.Println(e,e.x,e.y) 
       default: 
           fmt.Println(e) 
        } 

       log.Fatalln(err) 
    } 

   println(z) 
}
```

大量的函数方法返回error，使得调用代码变得很难看，一堆堆检查语句充斥在代码行间。解决思路

*   使用专门的检查函数处理错误逻辑(比如记录日志)简化检查代码
*   在不影响逻辑的情况下，使用defer延后处理错误状态（err退化赋值）
*   在不中断逻辑的情况下，将错误作为内部状态保存，等最终提交时在处理

### panic recover

与error相比，panic、recover使用上像try/catch结构化异常

panic 会立即中断当前函数流程，执行延迟调用。延迟调用中可以使用recover捕获panic返回的提交的错误对象，panic会一直沿着调用栈向外传递。要么被捕获要么程序崩溃

连续多次调用panic仅最后一个会被recover捕获

在延迟函数中panic，不会影响后续延迟调用执行。而recover之后panic，可被再次捕获。另外，**recover必须在延迟调用函数中执行才能正常工作。**

调试阶段，可使用runtime/debug.PrintStack函数输出完整调用堆栈信息。

建议：除非是不可恢复性、导致系统无法正常工作的错误，否则不建议使用panic 例如：文件系统没有操作权限，服务端口被占用，数据库未启动等情况。在 Go (Golang) 中，`struct` 标签（Tag）用于为字段指定额外的元数据。这些标签通常以字符串形式写在结构体字段的后面，括在反引号 \` 中，并常用于控制序列化/反序列化、数据库映射和验证等操作。

以下是 `struct` 标签解析不同类型数据时的常见选项及其用途：
## 1. 通用格式
标签的格式通常如下：
```
`key1:"value1" key2:"value2"`
```
多个键值对可以用空格分隔。不同库会解析特定的键值。
## 2. JSON 标签
**作用**：控制结构体与 JSON 数据的映射。
### 用法：
```
type Example struct {
	Name string `json:"name"`
	Age  int    `json:"age,omitempty"`
	ID   string `json:"-"`
}
```
#### 选项说明：
- `json:"name"`：将字段映射为 JSON 中的 `name`。
- `json:"age,omitempty"`：`omitempty` 表示如果字段值是零值（如空字符串、零、`nil` 等），则在序列化时忽略该字段。
- `json:"-"`：完全忽略该字段，既不会被序列化，也不会被反序列化。
## 3. XML 标签
**作用**：控制结构体与 XML 数据的映射。
### 用法：
```
type Example struct {
	Name  string `xml:"name"`
	Age   int    `xml:"age,omitempty"`
	Inner struct {
		ID string `xml:"id,attr"`
	} `xml:"inner"`
}
```
### 选项说明：
- `xml:"name"`：将字段映射为 XML 中的 `<name>`。
- `xml:"age,omitempty"`：`omitempty` 同样表示忽略零值字段。
- `xml:"id,attr"`：`attr` 指定字段为 XML 属性（如 `<inner id="value">`）。
- `xml:"-"`：忽略该字段。
## 4. GORM 标签
**作用**：控制结构体与数据库表字段的映射。
### 用法：
```
type User struct {
	ID        uint   `gorm:"primaryKey"`
	Name      string `gorm:"column:username;size:100;not null"`
	CreatedAt time.Time
}
```
### 选项说明：
- `primaryKey`：定义主键。
- `column:username`：将字段映射到数据库中的 `username` 列。
- `size:100`：设置字段长度限制为 100 个字符。
- `not null`：设置字段为非空。
## 5. Validator 标签
**作用**：定义结构体字段的校验规则。
### 用法：
```
type User struct {
	Name  string `validate:"required"`
	Email string `validate:"required,email"`
	Age   int    `validate:"gte=18,lte=60"`
}
```
### 选项说明：
- `required`：字段是必填项。
- `email`：字段必须是有效的电子邮件地址。
- `gte=18`：字段值必须大于或等于 18。
- `lte=60`：字段值必须小于或等于 60。
## 6. SQL/SQLX 标签
**作用**：控制与 SQL 查询的字段映射。
### 用法：
```
type User struct {
	ID    int    `db:"id"`
	Name  string `db:"username"`
	Email string `db:"email_address"`
}
```
### 选项说明：
- `db:"id"`：字段映射到数据库中的 `id` 列。
- 标签的键通常是 `db`，用于 SQL 和 SQLX 库。
## 7. Form 标签
**作用**：控制结构体与表单数据的映射。
### 用法：
``type LoginForm struct {     Username string `form:"username"`     Password string `form:"password"` }``
### 选项说明：
- `form:"username"`：将字段映射到表单中的 `username` 键。
- 常用于 Web 框架如 `gin` 或 `echo`。
## 8. YAML 标签
**作用**：控制结构体与 YAML 数据的映射。
### 用法：
```
type Config struct {
	Server   string `yaml:"server"`
	Port     int    `yaml:"port"`
	Timeout  int    `yaml:"timeout,omitempty"`
}
```
### 选项说明：
- `yaml:"server"`：将字段映射到 YAML 中的 `server` 键。
- `omitempty`：忽略零值字段。
## 9. Protobuf 标签
**作用**：定义结构体字段与 Protocol Buffers 的映射。
### 用法：
```
type User struct {
	ID    int32  `protobuf:"varint,1,opt,name=id"`     
	Name  string `protobuf:"bytes,2,opt,name=name"`     
	Email string `protobuf:"bytes,3,opt,name=email"`
}
```
### 选项说明：
- `varint,1,opt,name=id`：
    - `varint`：字段类型。
    - `1`：字段编号。
    - `opt`：字段是可选的。
    - `name`：字段名称。
## 10. **Custom 标签**
开发者也可以自定义标签来实现特定功能。例如：
```
type Example struct {
	Field string `custom:"custom_value"`
}
```
然后通过 `reflect` 包解析：
```
import "reflect"

func ParseTags(v interface{}) {
	t := reflect.TypeOf(v)
	
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get("custom")
		fmt.Println(field.Name, tag)
	} 
}
```
## 标签解析的常用工具包
- **`encoding/json`**：JSON 序列化/反序列化。
- **`encoding/xml`**：XML 序列化/反序列化。
- **`gopkg.in/yaml.v2`**：YAML 解析。
- **`github.com/go-playground/validator/v10`**：校验工具。
- **`gorm.io/gorm`**：ORM 工具。
- **`reflect`**：用于自定义标签解析。
如果需要了解某一标签的具体细节或有其他疑问，可以进一步讨论！# 断言
断言格式 `value, ok := x.(T)` x 表示一个接口的类型，T 表示一个具体的类型，返回 x 的值和一个 bool 值，可以判断 x 是否为 T 类型

_类型_​ _\__​_前添加一个_​ _\__​_波浪线_ ~ ，表示的是衍生\_类型\_，即使用 type 自定义的\_类型\_也可以被识别到( type MyInt int )，底层\_类型\_一致即可