# file read write
file\_read\_write

* * *

写入
--

### 直接覆盖

```go
// 新覆盖旧，文件不存在会创建
// io/ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error

// 基于
os.OpenFile(filename string, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm os.FileMode)
f.Write(data []byte)
f.Close()
```

### 常规写入

```go
// 灵活，操作性强
// os
// flag
// O_RDONLY 只读
// O_WRONLY 只写
// O_RDWR   读写
// O_APPEND 追加
// O_CREATE 不存在时创建
// O_EXCL   配合 O_CREATE，创建文件必须不存在
// O_SYNC   开启同步 I/O
// O_TRUNC  截断常规可写文件

// 可读写模式创建
func Create(name string) (file *File, err error)
// 只读模式打开
func Open(name string) (file *File, err error)
// 综合 Create 和 Open 通用文件打开函数
func OpenFile(name string, flag init, perm os.FileMode) (file *File, err error)
// 写入字节
func (f *File) Write(b []byte) (n int, err error)
// 写入字符串
func (f *File) WriteString(s string) (ret int, err error)
func (f *File) Close() error
```

### 带缓冲区的写入

```go
// 先写入缓存，在写入文件
// 设置缓存大小，存储更多数据一次写入
// bufio
// 使用默认大小 4096，新建 Writer
func NewWriter(w io.Writer) *Writer
// 使用自定大小新建 Writer
func NewWriterSize(w io.Writer, size int) *Writer
// 字节写入
func (b *Writer) Write(p []byte) (n int, err error)
// 字符串写入
func (b *Writer) WriteString(s string) (int,error)
// 单字节写入
func (b *Writer) WriterByte(c byte) error
// 写入一个 unicode 码值
func (b *Writer) WriteRune(r rune) (size int, err error)
// 缓冲的数据写入下层 io.Writer 接口
func (b *Writer) Flush() error
```

### 复制操作的文件写入

```go
// io
func Copy(dst Writer,src Reader)(written int64, err error)
func CopyBuffer(dst Writer, src Reader, buf []byte)(written int64, err error)
```

读取
--

### 整体读取

```go
// ioutil
// 直接读取 []byte
func ReadFile(path string) ([]byte, error)

// os
func Open(name string)(file *File, err error)
func (f *File) Stat()(fi FileInfo, err error) 
func (f *File) Read(b []byte)(n int, err error)
```

### 分片读取

上一步中多个小 buff `buf:=make([]byte, size)`

### 逐行读取

```go
func Open(name string)(file *File, err error)
func NewReader(rd io.Reader) *Reader
func (b *Reader) ReadLine()(line []byte, isPrefix bool, err error)
```# flag
内置 flag 包实现命令行参数的解析，使得开发命令行工具更简单

os.Args

* * *

简单的获取命令行参数

flag

* * *

### 参数类型

| flag类型 | 有效值 |
| --- | --- |
| 字符串(String) | 字符串 |
| 整数(Int,int64,Uint,Uint64) | 12，064，0x88，复数等 |
| 浮点数(Float64) | 浮点数 |
| 布尔类型(Bool) | 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False |
| 时间段(Duration) | ns/us/ms/s/m/h,eg. -1.5h, 30ms |

### 定义 flag

```go
flag.<Type>(flag_name, default_value, help_message) *Type

name := flag.String("name", "张三", "姓名")
age := flag.Int("age", "18", "年龄")
```

```go
flag.<Type>Var(*Type, flag_name, default_value, help_message)

var name string
var age int
flag.StringVar(&name, "name", "张三", "姓名")
flag.IntVar(&age, "age", "18", "年龄")
```

flag.Parse()

* * *

参数解析，支持的参数格式如下（布尔类型必须使用等号方式）

*   `-flag xxx`
*   `--flag xxx`
*   `-flag=xxx`
*   `--flag=xxx`

Parse 解析在第一个非 flag 参数停止，或者终止符 “-” 后停止

### flag.Args()

其他参数

### flag.NArg()

其它参数个数

### flag.NFlag()

使用的参数个数# fmt
fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为**向外输出**内容和**获取输入**内容两大部分。

向外输出

* * *

标准库fmt提供了以下几种输出相关函数。

#### Print Print

系列函数会将内容输出到系统的标准输出

*   Print函数直接输出内容
*   Printf函数支持格式化输出字符串
*   Println函数会在输出内容的结尾添加一个换行符

```go
func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
```

#### Fprint Fprint

系列函数会将内容输出到一个io.Writer接口类型的变量中，我们通常用这个函数往文件中写入内容。

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
```

#### Sprint Sprint

系列函数会把传入的数据生成并返回一个字符串。

```go
func Sprint(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
func Sprintln(a ...interface{}) string
```

#### Errorf Errorf

函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。

```go
func Errorf(format string, a ...interface{}) error
```

格式化占位符

* * *

#### 通用占位符

| 占位符 | 说明  |
| --- | --- |
| `%v` | 值的默认格式表示 |
| `%+v` | 类似`%v`，但输出结构体时会添加字段名 |
| `%#v` | 值的 Go 语法表示 |
| `%T` | 打印值的类型 |
| `%%` | 百分号 |

示例代码如下：

```go
struct {age int} {98}
%v {98}
%+v {age: 98}
%#v struct {age int} {age: 98}
%T struct {age int}
```

#### 布尔型

| 占位符 | 说明  |
| --- | --- |
| `%t` | true 或 false |

#### 整型

| 占位符 | 说明  |
| --- | --- |
| %b  | 表示为二进制 |
| %c  | 该值对应的unicode码值 |
| %d  | 表示为十进制 |
| %o  | 表示为八进制 |
| %x  | 表示为十六进制，使用a-f |
| %X  | 表示为十六进制，使用A-F |
| %U  | 表示为Unicode格式：U+1234，等价于`”U+%04X”` |
| %q  | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 |

#### 浮点数与复数

| 占位符 | 说明  |
| --- | --- |
| %b  | 无小数部分、二进制指数的科学计数法，如-123456p-78 |
| %e  | 科学计数法，如-1234.456e+78 |
| %E  | 科学计数法，如-1234.456E+78 |
| %f  | 有小数部分但无指数部分，如123.456 |
| %F  | 等价于%f |
| %g  | 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） |
| %G  | 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） |

#### 字符串和\[\]byte

| 占位符 | 说明  |
| --- | --- |
| %s  | 直接输出字符串或者\[\]byte |
| %q  | 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 |
| %x  | 每个字节用两字符十六进制数表示（使用a-f |
| %X  | 每个字节用两字符十六进制数表示（使用A-F） |

```go
a:="a"
%s a
%q "a" 
```

#### 指针

| 占位符 | 说明  |
| --- | --- |
| %p  | 表示为十六进制，并加上前导的0x |

示例代码如下：

```
a := 18
fmt.Printf("%p\n", &a)
fmt.Printf("%#p\n", &a)
```

输出结果如下：

```
    0xc000054058
    c000054058
```

#### 宽度标识符

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下

| 占位符 | 说明  |
| --- | --- |
| %f  | 默认宽度，默认精度 |
| %9f | 宽度9，默认精度 |
| %.2f | 默认宽度，精度2 |
| %9.2f | 宽度9，精度2 |
| %9.f | 宽度9，精度0 |

宽度和精度格式化控制的是Unicode码值的数量（不同于C的printf，它的这两个因数指的是字节的数量）。两者任一个或两个都可以使用`'*'`号取代，此时它们的值将被对应的参数（按`'*'`号和verb出现的顺序，即控制其值的参数会出现在要表示的值前面）控制，这个操作数必须是int类型。

```go
fmt.Printf("%*s%s", depth, aft, str) // %*S 中的 * 会在字符串之前填充一些空格（填充数量为depth）再输出 aft，最后输出 str
```

对于大多数类型的值，宽度是输出字符数目的最小数量，如果必要会用空格填充。对于字符串，精度是输出字符数目的最大数量，如果必要会截断字符串。

对于整数，宽度和精度都设置输出总长度。采用精度时表示右对齐并用0填充，而宽度默认表示用空格填充。

对于浮点数，宽度设置输出总长度；精度设置小数部分长度（如果有的话），除了%g和%G，此时精度设置总的数字个数。例如，对数字123.45，格式%6.2f 输出123.45；格式%.4g输出123.5。%e和%f的默认精度是6，%g的默认精度是可以将该值区分出来需要的最小数字个数。

对复数，宽度和精度会分别用于实部和虚部，结果用小括号包裹。因此%f用于1.2+3.4i输出(1.200000+3.400000i)。

示例代码如下：

```
n := 88.88
fmt.Printf("%f\n", n)
fmt.Printf("%9f\n", n)
fmt.Printf("%.2f\n", n)
fmt.Printf("%9.2f\n", n)
fmt.Printf("%9.f\n", n)
```

输出结果如下：

```
    88.880000
    88.880000
    88.88
        88.88
           89
```

#### 其他falg

| 占位符 | 说明  |
| --- | --- |
| ’+’ | 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； |
| ’ ‘ | 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 |
| ’-’ | 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； |
| ’#’ | 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； |
| ‘0’ | 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； |

举个例子：

```
s := "枯藤"
fmt.Printf("%s\n", s)
fmt.Printf("%5s\n", s)
fmt.Printf("%-5s\n", s)
fmt.Printf("%5.7s\n", s)
fmt.Printf("%-5.7s\n", s)
fmt.Printf("%5.2s\n", s)
fmt.Printf("%05s\n", s)
```

输出结果如下：

```
    枯藤
       枯藤
    枯藤
       枯藤
    枯藤
       枯藤
    000枯藤
```

获取输入

* * *

#### Scan 系列

*   fmt.Scan 从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。
*   fmt.Scanf 从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。本函数返回成功扫描的数据个数和遇到的任何错误。
*   fmt.Scanln 类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。本函数返回成功扫描的数据个数和遇到的任何错误。

```go
func Scan(a ...interface{}) (n int, err error)
func Scanf(format string, a ...interface{}) (n int, err error)
func Scanln(a ...interface{}) (n int, err error)
```

```
func main() {
    var (
        name    string
        age     int
        married bool
    )
    fmt.Scan(&name, &age, &married)
    fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)

    fmt.Scanf("1:%s 2:%d 3:%t", &name, &age, &married)
    fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)

    fmt.Scanln(&name, &age, &married)
    fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
}
```

#### bufio.NewReader

有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现。示例代码如下：

```
func bufioDemo() {
    reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
    fmt.Print("请输入内容：")
    text, _ := reader.ReadString('\n') // 读到换行
    text = strings.TrimSpace(text)
    fmt.Printf("%#v\n", text)
}
```

#### Fscan系列

这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据。

```
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

#### Sscan系列

这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。

```
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
```