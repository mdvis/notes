# 流程控制
if
--

*   无需括号将条件包裹
*   {}必须存在
*   左{必须与if else 处于同一行
*   if 后，条件前，可以添加变量初始化语句，使用；间隔
*   有返回值的函数，不允许将“最终的”return语句包含在if...else...结构中

```go
if x > 10 {}
if x > 10 {} else {}
// Go语言的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了
if x := sum(); x > 10 {}
if x == 3 {} else if x < 3 {} else {}
```

for

* * *

Go语言中的循环语句只支持for关键字，而不支持while和do-while 结构

```
for [变量声明或函数调用的返回值（开始时）];[条件判断];[变量声明或函数调用的返回值（结束时）] {

}
```

```go
sun := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

无限循环(while)

```go
sum := 0
for {
    sum++
    if sum > 100 {
        break
    }
}

for a < 5 {...}
```

条件多重赋值

```go
a := []init{1,2,3}
for i,j := 0, len(a) -1; i<j; i,j=i+1,j-1 {
a[i],a[j] = a[j], a[i]
}
```

*   左花括号{必须与for处于同一行
*   Go语言中的for循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量
*   Go语言的for循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环

```go
for j := 0; j<5;j++{
    for i := 0; i<10; i++ {
        if i>5{
            break JLoop
        }
        fmt.Println(i)
    }
}
JLoop:
```

```go
for i,v := range varible {...}
```

switch

* * *

*   左花括号{必须与switch处于同一行
*   条件表达式不限制为常量或者整数
*   单个case中，可以出现多个结果选项
*   与C语言等规则相反，Go语言不需要用break来明确退出一个case
*   **只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case**
*   可以不设定 switch 之后的条件表达式， 在此种情况下， 整个 switch 结构与多个 if...else...的逻辑作用等同。

```go
switch sExpr {
  case expr 1:
      ...
  case expr 1:
      ...
  default:
      ...
}
```

每个case后默认自带 break

```go
switch i {
  case 1:
      ...
  case 2,3,4:
      ...
  default:
      ...
}
```

可以使用 fallthrough 强制执行后续

```go
switch i {
  case 1:
      ...
      fallthrough
  case 2,3,4:
      ...
      fallthrough
  default:
      ...
}
```

switch 后可以没有表达式

```go
switch {
    case a==0:
        fmt.Printf()
    default:
        fmt.Printf()
}
```# 函数
函数是一个语句序列打包单元，其他地方多次调用，函数用来分解任务，对用户隐藏实现细节;函数声明包括函数名，形参列表，返回值列表及函数体

```go
func add(x int, y int) int { return x + y }
func sub(x, y int) (z int) { z = x - y }
func first(x int, _ int) int { return x }
func zero(int, int) int { return 0 }
```

*   无需前置声明,不支持命名嵌套定义,不支持同名函数重载,不支持默认参数
*   blank identifler (即 `_` 符号)
*   函数的类型被称为函数的标识符，==函数形参和返回列表变量类型一一对应==，就认为有相同类型和标识符，==形参和返回值的变量名不影响函数标识符==，也不影响是否可以省略参数类型的形式表示
*   函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中
*   实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice (切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改
*   遇到没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符
*   **函数只能和nil比较，不能和其他任何比较**在编程语言的编译优化原理中，分析指针动态范围的方法称之为逃逸分析。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。
*   函数返回局部变量指针是安全的，编译器会通过逃逸分析来决定是否在堆内存上分配内存
*   不支持有默认值的可选参数
*   不支持命名实参
*   必须按签名顺序传递指定类型和数量的实参
*   参数相当于函数的局部变量，不能在相同层次定义同名变量
*   形参是**函数定义**中的参数，实参是**函数调用**时所传递的参数
*   所有参数都是值拷贝传递，不管是指针、引用类型还是其他类型参数，区别是拷贝目标对象还是拷贝指针，调用前为形参和返回值分配内存，并将实参拷贝到形参内存。

多返回值

* * *

*   如果一个函数将所有的返回值都显示的变量名，那么该函数的 return 语句可以省略操作数。这称之为 bare return，使用 bare return 在多返回值时可以减少代码重复，但会使得代码难以理解不宜过度使用

可变参数

* * *

参数数量可变的函数称为为可变参数函数。在声明可变参数函数时，需要在==参数列表的最后一个参数类型之前==加上省略符号'...',这表示该函数会接收任意数量的该类型参数

可变参数函数经常被用于格式化字符串

```
func myfunc(arg ...int){}
arg []int
```

#### 不定参数类型

不定参数是指函数传入的参数个数为不定数量。为了做到这点，首先需要将函数定义为接受 不定参数类型：

```go
//使用不定参数
func myfunc(args ...int) { //函数接受不定参数，且类型全是int
    for _, arg := range args {
        fmt.Println(arg)
    }
}
myfunc(2, 3, 4)

从函数的实现角度来看，这没有任何影响，该怎么写就怎么写。但从调用方来说，情形则完 全不同：

// 不使用不定参数，正常写
func myfunc2(args []int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
myfunc2([]int{1, 3, 7, 13})
```

*   ...type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。
*   它是一 个语法糖（syntactic sugar），即这种语法对语言的功能并没有影响，但是更方便程序员使用。通 常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的机会
*   类型...type本质上是一个数组切片，也就是\[\]type，这也是为 什么上面的参数args可以用for循环来获得每个传入的参数。

#### 不定参数传递

```go
func myfunc(args ...int) {
    // 按原样传递
    myfunc3(args...)

    // 传递片段，实际上任意的int slice都可以传进去
    myfunc3(args[1:]...)
}
```

#### 任意类型的不定参数

```go
func Printf(format string, args ...interface{}) { // ...

}
```

用interface{}传递任意类型数据是Go语言的惯例用法。使用interface{}仍然是类型安 全的

```go
package main import "fmt"

func MyPrintf(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
            case int:
                fmt.Println(arg, "is an int value.")
           case string:
                fmt.Println(arg, "is a string value.")
            case int64:
                fmt.Println(arg, "is an int64 value.")
            default:
                fmt.Println(arg, "is an unknown type.")
        }
    }
}

func main() {
var v1 int = 1
var v2 int64 = 234
var v3 string = "hello"
var v4 float32 = 1.234
MyPrintf(v1, v2, v3,v4)
}
```

传值与传指针

* * *

函数调用始终是对参数值得复制，参数为值复制的是对应的值，参数为指针复制的是对应的指针

*   传指针可以使得多个函数操作同一个对象；
*   传指针比较轻量（8bytes），只有内存地址，可以用指针传递较大的结构体
*   string，slice，map类型的实现类似指针，所以可以直接传递，而不用传指针，函数需要改变slice长度除外

Deferred

* * *

你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在==一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。== defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿 名函数可以访问该函数包括返回值变量在内的所有变量，所以，==对匿名函数采用defer机制，可以使其观察函数的返回值。== 被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值

```go
func triple(x int) (result int) {
    defer func (){result += x}()
    return double(x)
}
```

函数值，类型

* * *

函数被看作第一类值（first­class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用

*   函数的零值是 nil，调用零值函数会引起 panic 错误
*   函数可以与 nil 比较
*   函数值之间不能比较，也不能用作 map 的 key
*   函数值能够通过数据来参数化函数，也可以通过行为

```go
// strings.Map
// func Map(mapping func(rune) rune, s string) string
// 将s的每一个unicode码值r都替换为mapping(r)，返回这些新码值组成的字符串拷贝。
// 如果mapping返回一个负值，将会丢弃该码值而不会被替换。（返回值中对应位置将没有码值）

func add1(r rune) rune {return r + 1}
fmt.Println(string.Map(add1, "abc")) // "bcd"
fmt.Println(string.Map(add1, "HAL-9000")) // "IBM.:111"
fmt.Println(string.Map(add1, "Admix")) // "Benjy"
```

在Go语言中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值。有了类型就可以把有类型的函数当值传递

```
type typeName func(arg1 arg1Type[,...])(result resultType[,...])
```

Panic

* * *

程序中应该没有或者很少有 panic 的东西。其可以中断原有的控制流程，进入一个恐慌的流程中。

*   有些错误只能在运行时检查，如数组访问边界、空指针引用等。运行时错误会引起 panic 异常。
*   panic 异常发生时程序会中断，并立即执行该 goroutine 的延迟函数(defer 机制)，随后程序崩溃输出日志信息。信息包含 panic value 和函数调用的堆栈跟踪信息。
*   panic value 通常是某种错误信息
*   每个 goroutine 日志信息中都会有与之相对的发生 panic 时的函数调用堆栈跟踪信息。通常不需要再次运行程序去定位问题，日志已提供足够诊断依据
*   因此，填写问题报告时，一般会将 panic 异常和日志信息一并记录
*   直接调用内置的 panic 函数也会引发 panic 异常，panic 函数接受任何值作为参数，当某些不该发生的场景发生时，就应该调用 panic。比如程序到达了某条逻辑不可达的路径

```go
switch s := suit(drawCard()); s {
    case "Spades":
    case "Hearts":
    case "Diamonds":
    case "Clubs":
    dafault:
        panic(fmt.Sprintf("invalid suit %q", s))
}

// 滥用，没必要
func Reset(x *Buffer){
    if x == nil {
        panic("x is nil")
    }
    x.elements = nil
}
```

*   断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非能提供更多错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器会在运行时帮你检查代码。
*   Go 的 panic 类似其他语言的异常，但适用场景有些不同。panic 会引起程序崩溃，所以 panic 用于严重错误，如程序内部逻辑不一致。一般应该使用 Go 提供的错误机制而不是 panic，尽量避免程序崩溃，健壮的程序中任何可以预料的错误都应用 Go 的错误机制优雅的处理。
*   Go 的 panic 机制中，延迟函数的调用在释放堆栈信息之前。runtime 包允许程序员输出堆栈信息 ==runtime.Stack== 。

Recover

* * *

通常不该对 panic 异常做任何处理，但有时可以从异常中恢复，至少在崩溃前做一些操作，recover 仅在 defer 函数中有效，正常流程中调用 recover 会返回 nil，且再无其他任何效果

> 举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。

*   deferred 函数中调用了内置函数 recover，并且定义该 defer 语句的函数发生了 panic 异常，recover 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 recover，recover 会返回 nil。
*   不加区分的恢复所有的 panic 异常，不是可取的做法；因为在 panic 之后，无法保证包级变量的状态仍然和我们预期一致。
*   作为被广泛遵守的规范，你不应该试图去恢复其他包引起的 panic。也不应该恢复一个由他人开发的函数引起的 panic，但有时很难遵守规范，基于以上原因，安全的做法是有选择的 recover，只恢复应该恢复的 panic 异常，可以设置特殊的 panic value 标记那些 panic 应该被恢复

> 举个例子，net/http 包中提供了一个 web 服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的 panic 异常，杀掉整个进程；web 服务器遇到处理函数导致的 panic 时会调用 recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为 recover 操作，导致其他问题。

```
var user = os.Getenv("USER")
func init(){
  if user == "" {
    panic("no value for $USER")
  }
}

func throwsPanic(f func()) (b bool){
    defer func(){
      if x := recover(); x != nil {
          b = true
      }	
    }()
    f()
    return
}
```

error 接口

* * *

```go
type error interface {
    Error() string
}

func Foo(param int) (n int, err error){}
```

实际代码来示范如何使用自定义的error类型。 首先，定义一个用于承载错误信息的类型。因为Go语言中接口的灵活性，你根本不需要从 error接口继承或者像Java一样需要使用implements来明确指定类型和接口之间的关系

```go
type PathError struct {
    Op string
    Path string
    Err error
}

func (e *PathError) Error() string {
    return e.Op + e.Path + e.Err.Error()
}

func Stat(name string) (fi FileInfo, err error){
    var stat syscall.Stat_t
    err = syscall.Stat(name, &stat)
    if err != nil {
        return nil, &PathError{"","",""}
    }
    return fileInfoFromStat(&stat, name), nil
}

fi, err := os.Stat("a.txt")

if err != nil {
 if e, ok := err.(*os.PathError); ok && e.Err != nil {}
}
```

main 函数和 init 函数

* * *

程序的初始化和执行都起始于main包。如果main包还导入了其他的包，那么在编译时就会将它们依次导入。有时一个包被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其他的包，那么会先将其他包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依此类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。

import

* * *

```go
// goroot 下
import (
    "fmt"
)
// 相对路径，当前文件同目录，不建议使用
import "./model"
// 绝对路径，加载 gopath/src/shorturl/model 下
import "shorturl/model"
import (
    // . 操作，省略报名直接调用函数
    . "fmt"
    // 别名操作
    f "fmt"
    // _ 操作，引入包，不直接使用包内函数，调用包的 init 函数
    _ "fmt"
)
```

递归
--

函数可以直接或间接的调用自身，大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与之相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。

匿名函数

* * *

\==拥有函数名的函数只能在包级语法块中被声明==，通过函数字面量（function literal，func 关键字后无函数名），我们可以绕过这一限制，在任何一个表达式中表示一个函数。函数值字面量是一种表达式，他的值被称为匿名函数(anonymous function)。 函数字面量允许我们使用时再定义它。`strings.Map(func (r rune) rune {return r + 1},"HAL-9000")` 更重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量（即和 js 中闭包，延长变量生命周期一样）

```go
func squares() func () int {
    var x int
    return func () int {
        x++
        return x * x
    }
}
f := squares()
f() //1 
f() //4
f() //9
```

捕获迭代变量

goto

* * *

goto 跳转到==当前函数内==定义的标签

```
func Fun1{
    i:=0
Here:
    fmt.Printf()
    i++
    goto Here
}
```

‍# generics
泛型多类型

* * *

```go
func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {}
```

*   K 和 V 你可以理解为类型别名，在中括号之间进行定义，作用域也只在此函数内，可以在形参、函数主体、返回值类型 里使用
*   \==comparable== 是 Go 语言预声明的类型，是那些可以比较（可哈希）的类型的集合，通常用于定义 map 里的 key 类型
*   int64 | float64 意思是 V 可以是 int64 或 float64 中的任意一个
*   map\[K\]V 就是使用了 K 和 V 这两个别名类型的 map

调用时移除类型参数

* * *

```go
SumIntsOrFloats(ints)
```

类型约束

* * *

类型的类型称为约束

```go
// T 称为类型参数
// any 给类型参数指定类型，这种类型的类型称为约束, any 即没有约束

func Print[T any](s []T){}

type Number interface {
    int64 | float64
}

func SumNumbers[K comparable, V Number](m map[K]V) V {}
```

泛型类型（可以有自己的方法）

* * *

```
type Lockable[T any] struct {
    sync.Mutex
    Data T
}

var a Lockable[bool]
var b Lockable[string]


func (l *Lockable[T]) Do(f func(T)){}

func (l *Lockable[_]) Nothing(){}  _表示未使用
```# fuzzing
‍