# JSON
Javascript 对象表示法（JSON）用于发送和接收结构化信息的标准协议，类似的还有 XML、ASN、Google 的 Protocol Buffers 都是；由于简洁性、可读性、流行程度等，JSON 是应用最广泛的一个。

*   encoding/json
*   encoding/xml
*   encoding/asn1
*   github.com/golang/protobuf

JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它 可以用有效可读的方式表示第三章的基础数据类型和本章的数组、slice、结构体和map等聚合数据 类型。

### 编组

Go 数据转 JSON 的过程叫编组，通过 json.Marshal 函数完成

*   json.Marshal 紧凑格式的输出
*   json.MarshalIndent 缩进的输出
*   只有导出的（大写开头）结构体成员才会被编码

```go
func Marshal(v any) ([]byte, error)
// prefix 每行输出的前缀，indent 每个层级的缩进
func Marshal(v any, prefix, indent string) ([]byte, error)
```

#### Tag

*   一个构体成员 Tag 是和在编译阶段关联到该成员的元信息字符串
*   结构体的成员 Tag 可以是任意的字符串面值，通常是用空格分隔的 key:"value" 键值对序列；值中含有双引号字符，==成员 Tag 一般用**原生字符串面值**的形式书写==。
*   json 开头键名对应的值用于控制 encoding/json 包的编码和解码的行为，并且 encoding/... 下面其它的包也遵循这个约定。
*   成员 Tag 中 json 对应值的第一部分用于指定 JSON 对象的名字,额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象

```go
type Move struct {
    Title string
    Year int `json:"released"`
    Color bool `json:"color,omitempty"`
    Actors []string
}

var movies = []Move{
    {Title: "A", Year: 1900, Color: false, Actors: []string{"E"}}
    {Title: "B", Year: 1878, Color: true, Actors: []string{"F"}}
}

data,err:=json.MarshalIndent(movies, "", "    ")
if err != nil {log.Fatalf("failed: %s", err)}
fmt.Printf("%s\n", data)
```

```json
[
    {
        "Title": "A",
        "released"": 1900,
        "Actors": [
            "E"
        ]
    {
        "Title": "B",
        "released": 1878,
        "color": true,
        "Actors": [
            "F"
        ]
]
```

### 解码

将 json 解码为 Go 数据结构（go 中一般叫 unmarshaling）,`json.Unmarshal` 完成

```go
func Unmarshal(data []byte, v any) error
```

*   通过定义合适的 Go 数据结构，可以选择性的解码 JSON 中成员

```go
var titles []struct{Title string}
if err:=json.Unmarshal(data, &titles);!err == nil {}
```

即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理

*   url.QueryEscape
*   json.NewDecoder
*   json.Decode
*   json.Encode

```go
func NewDecoder(r io.Reader) *Decode
func (dec *Decoder) Decode(v interface{}) error
func NewEncoder(w io.Writer) *Encoder
func (enc *Encoder) Encode(v interface{}) error
func QueryEscape(s string) string // QueryEscape函数对s进行转码使之可以安全的用在URL查询里
```

文本和HTML模板

* * *

提供了一个将变量值填充到一个文本或HTML格式的模板的机制

*   text/template
*   html/template
*   一个模板是一个字符串或一个文件，里面包含由双花括号包含的 {{action}}对象
*   actions 包含了一个用模板语言书写的表达式
*   模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流 if­else 语句和 range 循环语句，还有其它实例化模板等诸多特性
*   action，都有一个当前值的概念，对应点操作符，写作“.”。当前值“.”最初被初始化为调用模板时的参数
*   action中，`|`操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。

```go
const templ = `{{.TotalCount}} issues:
{{range .Items}}‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
Number: {{.Number}}
User: {{.User.Login}}
Title: {{.Title | printf "%.64s"}}
Age: {{.CreatedAt | daysAgo}} days
{{end}}`

report, err := template.New("report").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ)
if err != nil {
    log.Fatal(err)
}

// report = template.Must(template.New("issuelist").
//	Funcs(template.FuncMap{"daysAgo": daysAgo}).
//  Parse(templ))

func main(){
result, err:=github.SearchIssues(os.Args[1:])
    if err != nil {
        log.Fatal(err)
    }
    if err := report.Execute(os.Stdout, result);err!=nil{
        log.Fatal(err)
    }
}
```

生成模板的输出需要两个处理步骤

1.  分析模板并转为内部表示

分析模板一般只需要执行一次。方法调用链的顺序：template.New 先创建并返回一个模板；Funcs 方法将 daysAgo 等自定义函数注册到模板中，并返回模板；最后调用 Parse 函数分析模板。

因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。template.Must辅助 函数可以简化这个致命错误的处理：它接受一个模板和一个error类型的参数，检测error是否为 nil（如果不是nil则发出panic异常），然后返回传入的模板

1.  基于指定的输入执行模板

*   template.Must
*   template.New
*   template.Funcs
*   template.FuncMap
*   template.Parse
*   template.Execute

```go
type FuncMap map[string]any
func Must(t *Template, err error) *Template
func New(name string) *Template
func (t *Template) Funcs(funcMap FuncMap) *Template
func (t *Template) Parse(text string) (*Template, error)
func (t *Template) Execute(wr io.Writer, data any) error
```

html/template模板包。增加了一个将字符串自动转义特性，这可以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。# data
数据
--

\[TOC\]

字符串

* * *

不可变的字节序列，是一个复合结构。头部指针指向字节数组，但没有NULL结尾。默认UTF8编码存储Unicode字符。

unsafe.Pointer 用于指针类型转换

```go
type stringStruct struct {
    str unsafe.Pointer
    len int
}
```

*   字符串默认值为“”，而非nil。
*   使用"\`"定义不做转义的原始字符串，支持跨行。
*   编译器不会解析原始字符串内的注释语句，且前置缩进空格也属字符串内容。
*   支持 != == < > + +=，换行时符号在行尾
*   允许用索引号访问字节数组（非字符），但不能获取元素地址
*   以切片语法返回子串时，其内部依旧指向原字节数组
*   使用for遍历时，分为byte和rune两种方式

### 转换

修改字符串需要将其转换为可变类型\[\]rune 或 \[\]byte,完成后再转换回来，重新分配内存，并复制数据

*   rune
*   reflect.Pointer
*   unsafe
*   unsafe.Pointer
*   uintptr

有时候类型转换可以依靠unsafe非安全指针的方式进行提升性能避免，避免数据复制。

1.  指针类型，存储内存地址，地址指向内存空间
2.  unsafe.Pointer类型，实现定位和读写内存的基础，可以和任意类型指针相互转换，可以和uintptr类型相互转换
3.  unitptr类型，存储指针的整型，可以做指针运算，依赖平台，不同平台占用存储空间不同，运算时不同平台偏移量不同

### 性能

类型转换，动态构建字符串也容易造成性能问题。

拼接字符串时每次都必须重新分配内存。操作大字符串时会出现性能问题；**改进思路是预分配足够的内存空间，string.Join函数，会统计所有参数长度一次性完成内存分配**

*   copy
*   bytes.Buffer
*   string.Join

少量字符串拼接

*   fmt.Sprintf
*   text
*   template
*   zero-garbage

字符串操作通常在堆上分配内存，这对web等高并发应用会造成较大影响，会有大量字符串对象要做垃圾回收。建议使用\[\]byte缓存池，或者在栈上自行拼装等方式实现zero-garbage

*   zero-garbage

字符串的只读特性转换时会复制数据分配新内存。有时候编译器也做一些优化，避免额外复制分配内存

*   将\[\]byte转换为string key，去map\[string\]查询的时候
*   将string转换为\[\]byte，进行for range迭代时，直接取字节赋值给局部变量

### unicode

rune类型专门用来存储Unicode马甸，他是int32的别名，相当于UCS-4/UTF-32编码格式，使用单引号字面量，其默认类型就是rune

```go
func main(){
r:='我'
}
```

除了\[\]rune外，还可以直接在rune，byte，string间转换

```go
r:='t'
a:=string(r)
b:=byte(r)
c:=string(b)
d:=rune(b)
```

string直接追加到\[\]byte

```go
var bs []byte
append(bs, "abc"...)
```

*   utf8.RuneCountInString

数组
--

定义数组时数组长度必须是非负整型常量表达式。长度是类型组成部分。即是说长度不同的数组不属于同一类型。

```go
var d1 [2]int
var d2 [3]int
d1=d2 //error
```

初始化

```go
var a[4]int
b:=[4]int{2,4}
c:=[4]int{5,3:10} // 初始化指定索引
d:=[...]int{1,2,3} // 根据初始值决定数组长度

type user struct {
    name string
    age byte
}

d:=[...]user{
    {"tom",20}
}
```

定义多维数组时只允许第一层使用 ...

```go
c:=[...][2][2]{
    {
        {1,2},
        {3,4},
    }
}
```

len 和 cap 都可以返回第一维度长度 如果元素类型支持 == != 操作符，那么数组也支持此操作

```go
c:=[2]int{1,2}
d:=[2]int{3,4}
c!=d

var e,f [2]map[string] int
e==f // error
```

### 指针

要分清指针数组和数组指针的区别，指针数组是指元素为指针类型的数组，数组指针是获取数组变量的地址\*\*一定注意区分数组和切片）

### 复制

Go数组是值类型，赋值和传参操作都会复制整个数组数据。指针或切片可避免数据复制。

切片
--

切片是一个右半开区间，以开始和结束索引位置确定所引用的数组片段

```go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

*   cap 表示切片所引用数组片段的真实长度
*   len 用于限定可读的写元素数量。
*   数组必须addressable
*   因为是引用类型，需使用make函数或显示初始化语句，它会自动完成底层数组内存分配

```go
make([]int,3,5) // 指定len, cap 底层数组初始化为0,[0,0,0]
make([]int,3) // 省略cap 和 len相等, [0,0,0]
[]int{10,20,5:30} // [10,20,0,0,0,30]
```

### reslice

基于切片创建新切片，\[cap\]slice 不能超出 cap 不受 len 限制

```go
stack := make([]int,0,5)
stack = [:5] // 最大5不能超出之前的cap5
```

### append

向切片尾部（slice\[len\]）添加数据返回新的切片对象

```go
a:=make([]int,0,5)
append(a,1)
append(a,3,4)
```

使用append时插入数据追加到原底层数组，如果超出cap，则为新切片对象重新分配数组。

*   超出切片cap限制，而非地城数组长度限制，cap可能小于数组长度
*   新分配数组是原cap两倍,或者四分之一倍，以节省内存，不是原数组的
*   向nil切片追加数据时，会为其分配底层数组内存

正因为存在重新分配底层数组的缘故，在某些场合建议预留足够多的空间，避免中途内存分配和数据复制开销。

### copy

两个切片对象间复制数组，允许指向统一底层数组，允许目标区间重叠。最终复制长度以较短的切片长度为准,返回复制元素个数。

```go
s1:=[]int{1,2,3}
s2:=[]int{4,5,6,7,8}
copy(s1,s2) // s1:[4,5,6]
copy(s2,s1) // s2:[1,2,3,7,8]
copy(s2[1:3], s2[2:4]) // s2:[4,6,7,7,9]
```

可以从字符串复制数据到\[\]byte

如果切片长时间引用大数组中很小的片段，那么建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收。

map

* * *

字典的key必须是可以支持相等运算符（== ！=）的数据类型，数字 字符串 指针 数组 结构体 接口

map只能和nil比较，除此之外均不可

字典是引用类型，使用make函数或初始化表达语句来创建；访问不存在的键值默认返回0，不会引发错误。推荐使用ok-idiom模式，毕竟通过0值无法判断值是否存在，或许存的值是0

```go
make(map[string]int)

map[int]struct{
    x int
}{
    1: {x:2},
}

v,o := v[1]
```

len返回当前键值对数量，cap 不接受字典。由于内存安全和哈希算法等缘故，字典是not addressable，不能直接修改value成员（结构或数组）

```go
m[1].age = 1 // error

v:=m[1]
v.age=1
m[1]=v

m[key]++ // 是合法的相当于 m[key]=m[key]+1
```

nil字典不能进行写操作，但是可以读

```go
var m map[string]int // map[] == nil
m['a'] // 0
m['a'] = 1 // err

m2:=map[string]int{} // map[] != nil 已初始化，make
```

### 安全

迭代是删除和新增键值是安全的的

```go
m:=make(map[int]int)
for i:=0;i<10;i++ {
    m[i]=i+10
}
for k:=range m{
    if k==5 {
        m[100]=100
    }
    delete(m,k)
    fmt.Println(k,m)
}
```

就此例而言，不能保证迭代操作会删除新增的键值。

运行时会对字典并发操作做出检测。如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃。

```go
go run -race <filename> // 数据竞争 data race 检查这种问题
```

*   sync.RWMutex

```go
func main() {
 var lock sync.RWMutex
 m := make(map[string]int)
 go func() {
  for {
   lock.Lock()
   m["a"] += 1
   lock.Unlock()
   time.Sleep(time.Microsecond)
  }
 }()

 go func() {
  for {
   lock.RLock()
   _ = m["b"]
   lock.RUnlock()
   time.Sleep(time.Microsecond)
  }
 }()
 select {}
}
```

### 性能

字典对象本身就是指针包装，传参时无需再去取地址。创建时预先分配足够空间有助于提升性能，减少扩张时的内存分配和重新哈希操作。

对于海量小对象，应直接用字典存储键值数据拷贝，而非指针。这有助于减少需要扫描的对象数量，大幅缩短垃圾回收时间。另外，字典不会收缩内存，所以适当替换成新对象是必要的。

结构
--

结构体将多个不同类型命名字段序列到宝成一个复合类型。字段名必须唯一，可用"\_"补位，支持使用自身指针类型成员。字段名、排列顺序属于类型组成部分。除对齐处理外，编译器不会优化、调整内存布局。

```go
type node struct {
    _ int
    id int
    next *node
}

n1:=node{
    id:1,
}
n2:=node{
    id:2,
}
```

按顺序初始化全部字段，或使用命名方式初始化指定字段。

```go
type user struct {
    name string
    age byte
}

user{"Tom",12}
user{"Tom"} // error few values
user{name:"Tom"}
```

推荐使用命名初始化。这样在扩充结构字段或调整字段顺序时，不会导致初始化语句出错。

可直接定义匿名结构类型变量，或用做字段类型。**但因其缺少类型表示，在作为字段类型时无法直接初始化。**

```go
type file struct {
    name string
    attr struct {
        size int
        owner int
    }
}

f:=file{
    name: "n.txt",
    // attr : {       error: missing type in composite literal
    //    size:5
    //    owner:3
    // }
}
f.attr.size=2
f.attr.owner=2
```

### 空结构

没有字段的结构类型，不管他自身还是作为数组元素类型，其长度都为0,没有分配数组内存，但依然可以操作元素，对应len和cap属性也正常。

```go
var a struct{}
var b[100]struct{}

unsafe.Sizeof(a) //0
unsafe.Sizeof(b) //0

s:=b[:]
d[1]=struct{}{}
s[2]=struct{}{}
len(s) // 100
cap(s) // 100

a:=[10]struct{}{}
b:=a[:] // 底层数组指向zerobase， 而非slice
```

*   runtime.zerobase

空结构可以作为通道元素类型，用于事件通知。

```go
exit := make(chan struct{})

go func(){
    exit <-struct{}{}
}()

<- exit
```

### 匿名字段

所谓匿名字段是指没有名字，仅有类型的字段，也被称作嵌入字段或嵌入类型。编译的角度来看，这只是隐式的以类型名作为字段名。可直接引用匿名字段的成员，但是初始化时须当作独立字段。

```go
f:=file{
    name:'test.txt',
    attr:attr{
        perm:0775,
    }
}

f.perm=755
println(f.perm)

// 嵌入其他包中的类型，隐式字段名字不包括包名
type data struct {
    os.File
}
d:=data{
    File: os.File()
}
```

除了接口指针和多级指针以外的任何命名类型都可以作为你名字段,未命名类型没有名字标识，自然无法作为匿名字段

```go
type data struct {
    *int
    string
}

d:=data{
    int: &x,
    string: "",
}

//
data{
int:(*int)(0xc097978099sd),
string: "",
}
```

虽然可以像普通字段那样访问匿名字段成员，但会存在重名问题。默认情况下，编译器从当前显式命名字段开始，逐步向内查找匿名字段成员。如匿名字段成员被外层同名字段遮蔽，那么必须使用显式字段名。

### 字段标签

字段标签不是注释，而是用来对字段进行描述的元数据。尽管他不属于数据成员，但却是类型的组成部分。

运行期间可用反射获取标签信息。他常用做函数校验，数据库关系映射等。

```go
type user struct {
    name string `名称`
    sex byte `性别`
}

u:=user{"Tom",1}
v:=reflect.ValueOf(u)
t:=v.Type()

for i,n:=0,t.NumField();i<n;i++ {
    fmt.Printf("%s: %v\n", t.Field(i).Tag, v.Field(i))
}
```

### 内存布局

字段在相邻的地址空间按定义的顺序排列。内存一次性分配。对于引用类型、字符串和指针，结构内存中只包含其基本（头部）数据。匿名字段成员也包含在内。

```go
type point struct {
    x,y int
}

type value struct {
    id int
    name string
    data []byte
    next *value
    point
}

v:=value{
    id: 1,
    name:"test",
    data:[]byte{1,2,3,4},
    point: point{x:10,y:10}
}
```

*   unsafe.Offsetof 参数是一个字段，返回字段对于对象的地址偏移量
*   unsafe.Sizeof 操作数在内存中字节大小
*   unsafe.Alignof 返回对应参数类型需要对齐的倍数# data convert
data\_convert

* * *

string \[\]byte

* * *

```go
// 标椎转换
[]byte(str)
string(bt)

// 强制转换
// unsafe 和 reflect
```# SQL
database/sql

* * *

Go语言没有官方提供数据库驱动，而是为开发者开发数据库驱动定义了一些标准接口，开发者可以根据定义的接口来开发相应的数据库驱动

这样做有一个好处，只要按照标准接口开发的代码，以后需要迁移数据库时，不需要任何修改。

### sql.Register 注册数据库驱动

当第三方开发者开发数据库驱动时，都会实现 init 函数，在 init 里面会调用这个 `Register(name string, driver driver.Driver)` 完成本驱动的注册

database/sql/driver 提供的接口基础上定义了一些更高阶的方法，用以简化数据库操作，同时内部还建议性的实现一个 conn pool ( freeConn )

```text-plain
type DB struct {
    driver driver.Driver
    dsn string
    mu sync.Mutex
    freeConn []driver.Conn
    closed bool
}
```

Open 函数返回 DB 对象， 里面有 freeConn， 是个简易连接池。当执行 Db.prepare 时会 defer db.putConn(ci,err)，把链接放入链接池，调用conn时hv先判断 freeConn 长度，大于0 说明有可以复用的conn，不大于0 则创建conn，然后返回他

```text-plain
func Open(driverName, dataSourceName string) (*DB, error)
```

### driver.Driver

```text-plain
type Driver interface {
    Open(name string) (Conn, error) // 返回的 Conn 只能用来做一次 goroutine 的操作
}
```

第三方驱动都会定义这个函数，解析 name 参数获取数据库相关链接信息，使用此信息初始化 Conn 并返回

### driver.Conn

Conn 只能用于一个 goroutine，不能用于多个 Conn，否则无法判断是哪个 goroutine 发起的，从而造成混乱

```text-plain
type Conn interface {
    Prepare(query string) (Stmt, error)  // 返回当前链接相关的执行 SQL 语句的准备状态，可以删除查询等
    Close() error  // 关闭连接，清理链接拥有的资源（清理工作，释放资源）
    Begin() (Tx, error)  // 返回一个代表事务处理的Tx，可以用于查询更新等操作，或对事务进行回滚，提交
}
```

因为驱动实现了database/sql里面建议的conn pool，所以读者不用再去实现缓存conn之类的，这样会容易引起问题。

### driver.Stmt

Stmt 是一种准备好的状态，和 Conn 相关，只能用于一个 goroutine

```text-plain
type Stmt interface {
    Close() error  // 关闭当前连接状态，如果正在执行 query，query 还是有效返回 rows 数据
    NumInput() init  // 函数返回当前预留参数的个数，返回 >= 0 时数据库驱动会智能检查调用者的参数。数据库不知道预留参数时返回 -1
    Exec(args []Value) (Result, error) // 执行 Prepare 准备好的 sql，传入参数执行 update/insert 等操作，返回 Result 数据
    Query(args []Value) (Rows, error)  // 执行 Prepare 准备好的 sql，传入需要的参数执行 select 操作，返回 Rows 结果集
}
```

### driver.Tx

事务处理一般就两个过程，递交或回滚。

```text-plain
type Tx interface {
    Commit() error
    Rollback() error
}
```

### driver.Execer

Conn 可选择实现的接口

```text-plain
type Execer interface {
    Exec(query string, args []Value) (Result, error)
}
```

此接口如果未定义，执行 DB.Exec 会首先调用 Prepare 返回 Stmt, 然后执行 Stmt 的 Exec ，最后关闭 Stmt

### driver.Result

执行 Update/Insert 等操作返回的结果接口定义

```text-plain
type Result interface {
    LastInsertId()(int64, error) // 返回有数据库执行插入操作得到的自增 ID 号
    RowsAffected()(int64, error) // 返回query操作影响的数据条目数
}
```

### driver.Rows

执行查询返回结果集接口定义

```text-plain
type Rows interface {
    Columns() []string // 返回查询数据库表的字段信息，返回的 slice 和 sql 查询字段一一对应，而不返回整个表所有字段
    Close() error // 关闭 Rows 迭代器
    Next(dest []Value) error // 返回下一条数据，把数据赋值给dest，dest 里面元素必是 driver，Value 返回的数据中所有string必须转为[]byte,无数据后Next返回io.EOF
}
```

### driver.RowsAffected

其实是一个int64别名，但实现了 Result 接口，以底层实现 Result 的表示方式

```text-plain
type RowsAffected int64
func (RowsAffected) LastInsertId()(int64, error)
func (v RowsAffected) RowsAffected()(int64, error)
```

### driver.Value

是一个可以容纳任何数据的空接口,driver 的 Value 是驱动必须能够操作的 Value，要么是 `nil`，要么是 `int64` `float64` `bool` `[]byte` `string` `time.Time` 之一

```text-plain
type Value interface {}
```

### driver.ValueConverter

定义如何将普通值转化成driver.Value的接口,开发数据库驱动包中实现这个接口的函数在很多地方会使用，有很多好处

*   转化 driver.value 到数据库表响应字段（如int64数据如何转化成数据库表uint16字段）
*   把数据库查询结果转化成 driver.Value 值
*   在 scan 函数里面如何吧 driver.Value 值转化成用户定义值

```text-plain
type ValueConverter interface {
    ConvertValue(v interface{}) (Value, error)
}
```

### driver.Valuer

定义一个返回 driver.Value 的方式

```text-plain
type Valuer interface {
    Value()(Value, error)
}
```

很多类型都实现这个 Value 方法，用来自身与 driver.Value 的转化

关键函数

* * *

*   sql.Open(driverName, DSN) 打开一个注册过的数据库驱动
    *   DSN(Data Source Name)

```text-plain
  [username[:password]@][protocol[(address)]]/dbname[?param1=value1&...&paramN=valueN]
  // user@unix(/path/to/socket)/dbname?charset=utf8
  // user:passwd@tcp(localhost:8088)/dbname?charset=utf8
  // user:passwd@/dbname
  // user:passwd@tcp([de:ad:be:ef::ca:fe]:80)/dbname
```

*   db.Prepare 用来返回准备要执行的SQL操作，然后返回执行完毕的执行状态，参数都是=？的形式，一定程度可以防止SQL注入
*   db.Query 用来执行SQL返回Rows结果
*   stmt.Exec用来执行stmt准备好的SQL

```text-plain
sql.Open -> DB
db.Prepare -> stmt
stmt.Exec -> res
res.LastInsertId -> id
res.RowsAffected -> count

db.Query -> rows
rows.Next
rows.Scan
```- [是否匹配](#%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D)
- [解析正则表达式](#%E8%A7%A3%E6%9E%90%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
- [其他辅助函数](#%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0)
## 是否匹配
判断 `pattern` 是否和输入源匹配，若匹配，就返回 `true`，如果解析正则出错，则返回 `error`。
- `func Match(pattern string, b []byte) (matched bool, error error)` 输入源为 byte slice
- `func MatchReader(pattern string, r io.RuneReader) (matched bool, error error)` 输入源为 RuneReader
- `func MatchString(pattern string, s string) (matched bool, error error)` 输入源为 string
## 解析正则表达式
`CompilePOSIX` 和 `Compile` 的不同点在于前者必须使用`POSIX`语法，它使用最左最长方式搜索，而后者则只采用最左方式搜索（例如，`\[a-z\]{2,4}` 这样一个正则表达式，应用于 "aa09aaa88aaaa" 这个文本串时，`CompilePOSIX` 返回了 `aaaa`，而Compile返回的是aa）
- `func Compile(expr string) (*Regexp, error)`
- `func CompilePOSIX(expr string) (*Regexp, error)`

前缀有 `Must` 的函数表示，在解析正则语法的时候，如果匹配模式串不满足正确的语法，则直接 `panic`，而不加 `Must` 的则只是返回错误

- `func MustCompile(str string) *Regexp`
- `func MustCompilePOSIX(str string) *Regexp`
## 查找函数
一共 18 个函数，分为 8 类，只是输入源为 `byte slice`、`string` 和 `RuneReader` 的区别
- `func (re *Regexp) Find(b []byte) []byte` 查找匹配的第一个
- `func (re *Regexp) FindAll(b []byte, n int) [][]byte`
- `func (re *Regexp) FindAllIndex(b []byte, n int) [][]int`
- `func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte`
- `func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int`
- `func (re *Regexp) FindIndex(b []byte) (loc []int)`
- `func (re *Regexp) FindSubmatch(b []byte) [][]byte`
- `func (re *Regexp) FindSubmatchIndex(b []byte) []int`
* * *
- `func (re *Regexp) FindAllString(s string, n int) []string`
- `func (re *Regexp) FindAllStringIndex(s string, n int) [][]int`
- `func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string`
- `func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int`
- `func (re *Regexp) FindString(s string) string`
- `func (re *Regexp) FindStringIndex(s string) (loc []int)`
- `func (re *Regexp) FindStringSubmatch(s string) []string`
- `func (re *Regexp) FindStringSubmatchIndex(s string) []int`
* * *
- `func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)`
- `func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int`
---
- `func (re *Regexp) Match (b []byte) bool`
- `func (re *Regexp) MatchReader (r io. RuneReader) bool`
- `func (re *Regexp) MatchString(s string) bool`
## 替换函数
