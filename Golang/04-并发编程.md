# 并发
*   并发：逻辑上具备同时处理多个任务的能力
*   并行：物理上在同一时刻执行多个并发任务 通常说的并发设计指的是多个任务同时执行，但实际上并不一定真在同一时刻发生。单核处理器以间隔方式切换执行。并行则依赖多核处理器在物理上真正同一时刻执行。他代表当前程序运行状态。并行是并发的理想模式。
*   通常用多进程来实现分布式和负载均衡，减轻单进程垃圾回收压力
*   用多线程(LWP)抢夺更多的处理器资源
*   用协程来提高处理器时间片利用率 整个运行时完全并发化设计，凡是你能看到的，几乎都在以goroutine方式运行。

并发基础

* * *

串行程序运行时，只有一个执行上下文，一个调用栈。并发则意味着程序在运行时有多个执行上下文，对应着多个调用栈。每个进程都有自己调用的堆和栈，有一个完整的上下文，操作系统会保存进程的上下文，等进程获得时间片以后，再恢复上下文到系统中。

多线程或多进程是并行的基本条件，但单线程也可用协程（coroutine）做到并发。

并发主流的实现模型：

1.  多进程 - 简单，进程间相互不影响，开销大（所有进程都由内核管理）（进程间互不影响，靠消息通信）
2.  多线程 - 属于系统层面的并发模式，使用最多且有效的一种模式。开销依旧较大，高并发模式下影响效率
3.  基于回调的非阻塞/异步IO - 通过事件驱动方式使用异步IO，但这种模式，编程比多线程要复杂，因为他把流程做了分割，对问题本身反应不够自然
4.  协程 - 协程（Coroutine）本质上是一种用户态线程，不需要操作系统来进行抢占式调度， 且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器。目前，原生支持协程的语言还很少。

并发模式：

1.  共享内存系统=线程+共享内存(传统并发模型：多线程共享内存)
2.  消息传递系统=线程+消息传递(现代并发模型：顺序通信进程(CSP))

线程间通信只能采取共享内存的方式，共享内存有死锁、资源竞争等缺点不好解决

消息传递系统中进程间共享状态的各种操作都被封装在线程之间传递的消息中，这要求：发送消息是对状态进行复制，并且在消息传递的边界上交出这个状态的所有权。逻辑上这个操作与共享内存系统中执行的原子更新操作相同（所谓==原子操作==是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch（切换到另一个线程）），但从物理上看则不同。由于需要复制操作，所以大多数消息传递实现在性能上并不优越，但线程中的状态管理工作通常会变得更简单。

协程
--

执行体是个抽象的概念，在操作系统层面有多个概念与之对应，比如操作系统自己掌管的进程（process）、进程内的线程（thread）以及进程内的协程（coroutine，也叫轻量级线程）。

之所以叫轻量级线程，协程创建上百万也不会导致系统资源衰竭，而线程和进程通常也不能过万。

goroutine

* * *

goroutine 运行时会创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。更像多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理器能力。

goroutine 更像多线程和协程的综合体

Go 语言在语言级别支持轻量级线程，叫 goroutine。**Go 语言标准库提供的所有系统调用操作（当然也包括所有同步 IO 操作），都会出让 CPU 给其他 goroutine。** 这让事情变得非常简单，让轻量级线程的切换管理不依赖于系统的线程和进程，也不依赖于CPU的核心数量。

go 关键字，函数调用加 go 关键字这次调用就会在一个新的 goroutine 中并发执行。函数返回，goroutine 自动结束，但是如果函数有返回值会被丢弃。

go 关键字并非执行并发操作，而是创建一个并发单元。新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发执行顺序。

每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内空间。相比系统默认MB级别线程，goroutine自定义栈初始只有2KB，所以能创建成千上万的并发任务。自定义栈按需分配策略，在需要时进行扩容，最大能到GB规模。

*   一个并发的执行单元叫做一个 goroutine一个程序启动
*   其主函数即在一个单独的 goroutine（main goroutine) 中运行
*   goroutine 使用 go 关键字创建, go 语句本身会迅速完成
*   主程序（main）返回，所有的 goroutine 都会被直接打断，程序退出
*   除了主函数退出或终止程序外，没有其他编程方法能够打断 goroutine 执行

goroutine因延迟执行而立即执行计算并复制执行参数。

```go
package main
import "fmt"
func Add(x, y int) {
    z := x + y
    fmt.Println(z)
}

func main() {
    for i := 0; i < 10; i++ {
        go Add(i, i)
    }
}
```

**Go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出， 且程序并不等待其他goroutine（非主goroutine）结束。**

并发通信

* * *

并发编程的难度在于协调，并发单元间的通信是最大问题。两种最常见的并发通信模型：共享数据和消息

共享数据是指多个并发单元分别保持对同一个数据的引用，实现对该数据的共享。最常见的共享数据就是内存，也就是前面提到的共享内存。

go 使用的是消息机制，而非共享内存作为通信方式。

消息机制（channel）认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发单元间这些变量不共享。每个单元的输入输出只有一种，那就是消息。

“不要通过共享内存来通信，而应该通过通信来共享内存。”

channel

* * *

通道类型和值

* * *

*   `chan T` 元素类型为T的双通道
*   `chan<- T` 元素类型为T的单向发送通道
*   `<-chan T` 元素类型为T的单向接收通道

### 容量属性

`make(chan type, integer)`

*   非缓冲通道（容量属性为0）
*   缓冲通道（容量属性不为0）

go鼓励使用CSP（Communicating Sequential Process）通道，以通信来代替内存共享，实现并发安全。(不要通过共享内存通信，而是通过通信共享内存)

CSP(Communicating Sequential Process)通信顺序进程是 gorutine 推荐通信方式，是一种并发编程模式，**有序阻塞和可预测的并发模型**

通过消息来避免竞态的模型有CSP 和 Actor 两种

CSP

* * *

*   作为 CSP 核心，通道是显示的
*   操作双方必须知道数据类型和具体通道
*   如果其中一端为准备妥当，或消息未及时处理，会阻塞当前端

Actor

* * *

*   Actor 是透明的，不在乎数据类型及通道，只要知道接收者信箱
*   默认是异步方式，发送方对消息是否被接收和处理不关心

通道只是一个队列（FIFO)。同步模式下，发送和接收双方配对，然后直接复制数据给对方。如配对失败，则置入等待队列，直到另一方出现后才被唤醒。异步模式抢夺的则是数据缓冲槽。发送方要求有空槽可供写入，而接收方则要求有缓冲数据可读。需求不符时，同样加入等待队列，直到有另一方写入数据或腾出空槽后被唤醒。

除传递消息外，通道还常被用作事件通知。

```go
done:=make(chan struct{})
c:=make(chan string)

go func(){
    s:=<-c
    println(s)
    close(done)
}()
c<-"hi"
<-done
```

*   同步模式必须有配对操作的goroutine出现，否则会一直阻塞。
*   而异步模式在缓冲区未满或数据未读完前，不会阻塞。
*   多数时候异步通道有助于提升性能，减少排队阻塞。
*   缓冲区大小仅是属性，不属于类型组成部分
*   通道本身是指针，可用相等操作符判断是否是同一对象，或nil
*   传递指针避免数据复制，但注意数据并发安全
*   内置行数cap和len返回缓冲区大小和当前以缓冲数量
*   同步通道cap和len均返回0，可以判断通道是否是同步

异步模式貌似就是有缓冲区的通道。

### 收发

*   写入读取操作符
*   ok-idom或range模式
*   及时使用close函数关闭通道引发结束通知，否则可能会死锁

一次性事件用close效率更好，没多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用sync.Cond实现单播或广播事件

对于closed或nil通道，发送和接收操作都有相应规则

*   向已关闭通道发送数据，引发panci
*   从已关闭通道接收数据，返回以缓冲数据或零值
*   无论收发，nil通道都会阻塞

重复关闭，或关闭nil通道都会引发panic错误。

单向
--

通常使用类型转换来获取单向通道，并分别赋予操作双方

通过make创建单向通道没有意义

```go
c:=make(chan int) 
var send chan <-int = c
var recv <-chan int = c
```

close函数只能用于写入端

单通道无法转换为双通道

选择
--

同时处理多个通道可用select语句。他随即选择一个通道做收发操作

```go
var wg sync.WaitGroup
wg.Add(1)
a,b:=make(chan int),make(chan int)

go func(){
    defer wg.Done()

    for{
        var (
            name string
            x int
            ok bool
        )
        select {
            case x,ok = <-a
                name = "a"
            case x,ok = <-b
                name = "b"
        }

        if!ok{
            return
        }
    }
}()

go func(){
    defer wg.Done()
    defer close(a)
    defer close(b)

    for i:=0;i<10;i++ {
        select {
            case a<-i:
            case b<-i*10
        }
    }

}()

wg.Wait()
```

等通道全部处理结束（closed）可将已完成通道置为nil，这样就不会被阻塞，不再被select选中

当所有通道都不可用时，select会执行default语句。可避开select阻塞，但需注意处理外层循环，以免空耗。也可以用default处理一些默认逻辑。

```go
done:=make(chan struct{})
c:=make(chan int)

go func(){
    defer close(done)

    for {
        select {
            case x,ok:=<-c:
            if !ok {
                return
            }
            println("data:",x)
            default: // 避免select阻塞
        }
        println(time.Now())
        time.Sleep(time.Second)
    }
}()

time.Sleep(time.Second*5)
c<-100
close(c)
<-done
```

模式
--

通常使用工厂方法将goroutine和通道绑定。

```go
type receiver struct {
    sync.WaitGroup
    data chan int
}

func newRecevier() *receiver {
    r:=&receiver{
        data: make(chan int),
    }

    r.Add(i)

    go func(){
        defer r.Done()
        for x:=range r.data{
            println("recv:",x)
        }
    }()
    return r
}

r:=newReceiver()
r.data<-1
r.data<-2
close(r.data)
r.Wait()
```

通道本身是一个并发安全队列，可做ID generator、Pool等用途

```go
type pool chan[]byte

func newPool(cap int) pool {
    return make(chan []byte,cap)
}

func(p pool) get() []byte {
    var v[]byte

    select {
        case v=<-p:
        default:
            v=make([]byte,10)
    }
    return v
}

func(p pool)put(b[]byte){
    select {
        case p<-b:
        default:
    }
}
```

通道实现信号量

```go
runtime.GOMAXPROCS(4)
var wg sync.WaitGroup

sem:=make(chan struct{},2) // 最多两个并发

for i:=0;i<5;i++{
    wg.Add(1)
    go func(){
        defer wg.Done()

        sem<-struct{}{}
        defer func(){<-sem>}()
        time.Sleep(time.Second*2)
        fmt.Println(id, time.Now())
    }(i)
}
wg.Wait()
```

*   time.After
*   time.Tick

捕获INT、TERM信号，顺便实现一个简易的atexit函数

```go
var exits=&struct{
    sync.RWMutex
    funcs []func()
    signals chan os.Signal
}{}

func atexit(f func()){
    exits.Lock()
    defer exits.Unlock()
    exits.funcs=append(exits.funcs,f)
}

func waitExit(){
    if exits.signals==nil{
        exits.signals=make(chan os.Signal)
        signal.Notify(exits.signals,syscall.SIGINT,syscall.SIGTERM)
    }
    exits.RLock()

    for _,f:=range exits.funcs{
        defer f()
    }

    exits.RUnlock()
    <-exits.signals
}

atexit(func(){})
atexit(func(){})
waitExit()
```

性能
--

*   将发往通道的数据打包，减少次数
*   实现上来看，通道队列依旧使用锁同步机制，单次获取更多数据（批处理），可改善因频繁加锁造成的性能问题

资源泄露

* * *

goroutine leak 指 goroutine处于发送或接收阻塞状态,但一直未被唤醒。垃圾回收器并不收集此类资源，导致他们会在等待队列里长久休眠，形成资源泄露。

使用channel与goroutine实现通信代替内存共享的CSP模型

channel 是语言级别提供的多个 goroutine 间通信方式。

跨进程通信，我们建议用 分布式系统的方法来解决，比如使用Socket或者HTTP等通信协议。

channel是类型相关的。也就是说，一个channel只能传递一种类型的值，这个类型需要在声 明channel时指定。

channel 的发送和接收是阻塞的，无缓冲 channel 是多个 goroutine 间同步很好的工具

### range

### close

注：记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic。 另外，channel不像文件之类需要经常去关闭，只有当你确实没有任何数据发送了，或者你想显式的结束range循环之类的操作。

### 基本语法

```go
package main

import "fmt"

func Count(ch chan int, i int){
    ch <- i
}

func main(){
    chs := make([]chan int, 10)
    for i:=0; i < 10; i++ {
      chs[i] = make(chan int)
      go Count(chs[i], i)
    }
    for _, ch := range(chs){
        chval := <-ch
        fmt.Println(chval)
    }
}
```

```js
// 声明 var <chan_name> chan <chan_ele_type>

var chanName chan ElementType

// 初始化  make方法

ch := make(chan int)

// 写入

ch <- value  // 写入数据通常会导致程序阻塞，直到有其他goroutine从这个chinnel中读取数据

// 读出

val := <-ch
```

#### close

channel 的 close 操作用于关闭 channel，已关闭的操作不能发送，但是可以读取已经发送的值，如果已经没有数据了会产生一个零值数据 因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调 用close函数，因此对一个只接收的channel调用close将是一个编译错误。

### Wait

进程退出时不会等待并发任务结束，可用通道阻塞，然后发出退出信号。

*   关闭通道 exit
*   写入数据

等待多个任务结束推荐使用**sync.WaitGroup** 通过设定计数器，让每个goroutine在退出前递减，直至归零解除阻塞。

*   Add 要等待完成的goroutine个数 Add(n) 或 n次Add(1)
*   Done 表示goroutine完成，使计数器减1
*   Wait 计数器为0前，一直阻塞当前goroutine

```go
exit := make(chan struct{}) // 只用作通知，数据无意义

go func (){
    time.Sleep(time.Second)
    println("done")

    close(exit)
}()

println("main...")
<-exit // 通道关闭，解除阻塞
println("exit...)
```

```go
var wg sync.WaitGroup

for i:=0;i<10;i++{
    wg.Add(1)

    go func(){
        defer wg.Done()
        time.Sleep(time.Second)
        println("gorountine", id, "done.")
    }(i)
}
println("main ...)
wg.Wait()
pringln("main exit.")
```

WaitGroup.Add 实现了原子操作，但建议在goroutine外累加计数器，以免没Add没执行，Wait以退出。Wait可以在多处使用，他们能都收到通知

### GOMAXPROCS

运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用runtime.GOMAXPROCS函数（或环境变量）修改。如参数小于2，GOMAXPROCS仅返回当前设置值，不做任何调整。

### local storage

不同与线程，goroutine任务

1.  无法设置优先级
2.  无法获取编号
3.  没有局部存储（TLS)
4.  返回值会被抛弃

除获取优先级外其他都可轻易实现

```go
var wg sync.WaitGroup
var gs [5]struct{ // 用于实现类似TLS功能
    id int // 编号
    result int // 返回值
}

for i:=0;i<len(gs);i++ {
    wg.Add(1)

    go func(id int){
        defer wg.Done()
        gs[id].id=id
        gs[id].result=(id+1)*100
    }(i)
}

wg.Wait()
```

### Gosched

暂停，释放线程去执行其他任务。当前任务被放回队列，等待下次调度时恢复执行

```go
runtime.GOMAXPROCS(1)
exit:=make(chan struct{})

go func (){ // task b
    defer close(exit)

    go func(){  // task b, a 先执行
        println("b")
    }()

    for i:=0;i<4;i++ {
        println("a:",i)
        if i==1{ // 让出当前进程,调度执行b
            runtime.Gosched()
        }
    }
}()

<-exit
```

该函数很少被使用，因为运行时会主动向长时间运行（10 ms）的任务发出抢占调度。只是当前版本实现的算法稍显粗糙，不能保证调度总能成功，所以主动切换还有适用场合。

### Goexit

立即终止当前任务，运行时确保所有已注册延迟调用被执行。该函数不会影响其他并发任务，不会引发panic，自然也就无法捕获

```go
exit:=make(chan struct{})

go func(){
    defer close(exit) // 执行
    defer println("a") // 执行

    func(){
        defer func(){
            println("b", recover()==nil) // 执行，recover 返回 nil
        }()

        func(){ // 在多层调用中执行Goexit
            println("c")
            runtime.Goexit() // 立即终止整个调用堆栈
            println("c done.") // 不会执行
        }()

        println("b done.") // 不会执行
    }()
        println("b done.") // 不会执行
}()

<-exit>
```

main 中调用Goexit会等待其他任务结束，然后直接让进程崩溃。Goexit无论处在那一层，都能立即终止整个调用栈，这与return仅退出当前函数不同。

### select

多个 channel 可以使用 select 监听。select 默认是阻塞的，只有监听的 channel 中发送或接收可以进行时才会运行，多个 channel 都准备好时会随机选择一个，还可以有 default 语句 select 的用法与switch语言非常类似，由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。与 switch 语句可以选择任何可使用相等比较的条件相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作

```go
select {
    case <- chan1:  // 成功读取chan1的数据时
    case chan2 <- 1: // 成功向chan2写入数据时
    default: // 上面均不满足时
}
```

**select不像switch，后面并不带判断条件，而是直接去查看case语句。** 每个 case语句都必须是一个面向channel的操作。

```go
// 随机写入1 0
ch := make(chan int, 1)

for {
    select {
        case ch <- 0:
        case ch <- 1:
    }

i := <-ch

fmt.Println("Value received:", i)
}
```

### 超时

runtime goroutine

* * *

*   Goexit 退出当前 goroutine，但 defer 还会继续调用
*   Gosched 退出当前 goroutine 执行权限，调度器安排其他等待的任务运行，并在下次某时候恢复执行
*   NumCPU 返回 CPU 数量
*   NumGoroutine 返回正在执行和排队的任务总数
*   GOMAXPROCS 设置可以运行的 CPU 核数

### 缓冲机制

```go
// no cache
c := make(chan int)
// cache
c := make(chan int, 1024)
```

调用make时第二个参数作为缓冲区大小传入，缓冲区满之前可以一直写入 读取时可以使用常规方法，也可以使用range

```go
for i := range c {
    fmt.Println(i)
}
```

#### 不带缓存的 channel

一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的 Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行 后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个 goroutine在相同的Channels上执行发送操作。

基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无 缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收 到数据发生在唤醒发送者goroutine之前(译注:_happens before_，这是Go语言并发内存模型的一 个关键术语!)

#### 串联的 channels（pipeline）

#### 带缓存的 channels

```golang
ch:=make(chan int, 3)
cat(ch) // 3 容量
len(ch) // 有效元素的个数
```

如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。 这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被 自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。#### 并发的循环

#### 基于 select 的多路复用

*   time.Tick
*   time.After
*   time.NewTicker
    *   time.NewTicker.Stop

channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一 个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select 到。

这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。 我们会在下一节中看到一个例子。

#### 并发的退出

利用关闭了的 channel 产生零值的特性，通过关闭一个 channel 来进行广播通知所有 goroutine 退出，关闭了的通道会立即返回零值，所以不是发送一个值，而是关闭他

```go
var done = make(chan struct{})

func cancelled() bool {
    select {
    case<-done:
        return true
    default:
        return false
    }
}

go func(){
    ...
    close(done) // 关闭一个通道
}()

for {
    select {
    case<-done:
        for range fileSizes {}
        return
    case size,ok:=<-fileSizes:
    }
}

func walkDir(dir string, n *sync.WaitGroup, fileSize chan<-int64){
defer n.Done()
if cancelled(){
return
}
for _,entry := range dirents(dir){}
}

func dirents(dir string) []os.FileInfo {
    select {
    case sema<-struct{}{}:
    case <-done:
        return nil

    defer func(){<-sema}()
    }
}
```

### 超时机制

go 中没有提供直接的超时处理机制，我们可以利用select机制，可以方便解决超时问题。因为select特点是只要其中一个case完成就会继续执行而不考虑其他

```go
// 超时等待函数
timeout := make(chan bool, 1)
go func (){
    time.Sleep(1e9)  // 等待一秒
    timeout <- true  // time.After(5 * time.Second)
}

select {
    case <- ch:
    case <-timeout
}
```

这种写法看起来是一个小技巧，但却是在Go语言开发中避免channel通信超时的最有效方法。 在实际的开发过程中，这种写法也需要被合理利用起来，从而有效地提高代码质量。

### channel的传递

channel 也是一个原生类型，就像 map 类型，因此channel本身也可以通过channel传递

#### 管道

利用channel可以被传递的特性来设计管道

```go
type PipeData struct {
    value int
    handler func(int) int
    next chan int
}

func handle(queue chan *PipeData {
    for data := range queue {
        data.next <- data.handler(data.value)
    }
}
```

### 单向channel

单向channel只能用于发送或者接收数据，channel本身必然是同时接收读写的，否则根本没法用。单向channel只是对channel的一种使用限制

我们在将一个channel变量传递到一个函数时，可以通过将其指定为单向channel变量，从 而限制该函数中可以对此channel的操作， 比如只能往这个channel写， 或者只能从这个 channel读。

```go
var ch1 chan int
var ch2 chan<- float64 // 只写channel
var ch3 <-chan int // 只读channel

// 单向channel初始化
// channel是原生类型所以支持类型转换
// 单向双向之间转换
ch4 := make(chan int)
ch5 := <- chan int(ch4)
ch6 := chan <- int(ch4)
```

单向channel，从设计的角度考虑，所有的代码都应该遵循”最小权限原则“ 从而避免没必要地使用泛滥问题，进而导致程序失控。 因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调 用close函数，因此对一个只接收的channel调用close将是一个编译错误。

#### 用法

```go
func Parse(ch <- chan int) {
    for value := range ch {
        fmt.Println("Parsing value", value)
    }
}
```

### 关闭channel

close(channel)

使用多重返回值的方式判断channel是否被关闭`x, ok := <-ch`

多核并行化

* * *

runtime.NumCPU() // cup 个数

出让时间片

* * *

runtime.Gosched() // 出让时间片给其他goroutine

同步
--

即使成功地用channel来作为通信手段，还是避免不了多个goroutine之间共享数据的问题，Go 语言的设计者虽然对channel有极高的期望，但也提供了妥善的资源锁方案。

### 同步锁

sync 包提供sync.Mutex 和 sync.RWMutex 两种锁类型。

Mutex是最简单的一种锁类型，同时也比较暴力，当一个goroutine获得了Mutex后，其他goroutine就只能乖乖等到这个goroutine释放该Mutex。

RWMutex相对友好些，是经典的单写多读模型。在读锁占用的情况下，会阻止写，但不阻止读，也就是多个goroutine可同时获取读锁（调用RLock()方法）而写锁（调用Lock()方法）会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine 独占。从RWMutex的实现看，RWMutex类型其实组合了Mutex

```go
type RWMutex struct {
    w Mutex
    writerSem uint32
    readerSem uint32
    readerCount int32
    readerWait int32
}
```

对于这两种锁类型，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock() 调用与之对应，否则可能导致等待该锁的所有goroutine处于饥饿状态，甚至可能导致死锁。

```go
var l sync.Mutex
func foo(){
    l.Lock()
    defer l.Unlock()
}
```

### 全局唯一性操作

```go
var once sync.Once
once.Do(func())
```

once 的 Do()方法可以保证在全局范围内只调用指定的函数一次（这里指 setup() 函数）， 而且所有其他goroutine在调用到此语句时， 将会先被阻塞， 直至全局唯一的 once.Do()调用结束后才继续。

为了更好地控制并行中的原子性操作，sync包中还包含一个atomic子包，它提供了对于一 些基础数据类型的原子操作函数

goroutine 机理（协程机理）

* * *

### 协程

协程（轻量级线程）

*   能够在单一的系统线程中模拟多个任务的并发执行
*   在一个特定的时间，只有一个任务在运行，即并非真正的并行
*   被动的任务调度方式，即任务没有主动抢占时间片的说法。当一个任务正在执行时，外部没有办法中止它。要进行任务切换，只能通过由该任务自身调用yield()来主动出让 CPU使用权。
*   每个协程都有自己的堆栈和局部变量

协程三个状态：挂起（出让了时间片）、运行、停止

### 任务

*   任务上下文，用于在切换任务是保持当前任务的运行环境
*   栈
*   状态
*   任务所对应的任务函数
*   任务的调用参数
*   之前和之后的任务

### 调度

循环执行正在等待中的任务，直到所有任务执行完成

### 上下文切换

任务切换

*   该任务的业务代码主动要求切换，既主动让出执行权
*   发生了io，导致阻塞

### 通信机制

channel

*   内存缓存，用于存放元素
*   发送队列
*   接收队列

基于共享变量的并发

* * *

并发就是指不确定一个事件一定先于另一个事件发生

并发安全指一个函数在线性程序中可以正确地工作。并发的情况下依然可以正确地工作

并发安全的类型是所有它的访问方法和操作就都是并发安全的类型

对于绝大部分变量，如要回避并发访问，要么限制变量只存在于一个 goroutine 内，要么维护一个更高层的互斥不变量。导出包级别的函数一般情况下都是并发安全的。由于 package 级的变量没法被限制在单一的 gorouine，所以修改这些变量“必须”使用互斥条件。

函数不工作的原因可能是死锁、活锁或者资源耗尽

\==竞态==是指在多个goroutine 按某些交错顺序执行时程序无法给出正确的结果。

\==数据静态==发生于并发读写同一变量并且至少其中有一个写入时

\==为定义行为==

```go
var x []int
go func(){x = make([]int, 10)}()
go func(){x = make([]int, 1000000)}()
x[999999]=1 // 未定义行为
```

slice 的三个部分:指针、长度和容量。如果指针来自于第一个make调用,而长度来自第二个make调用，那么x会变成一个嵌合体，它名义上长度为1000000但底层的数组只有10个元素。在这种情况下，尝试存储到第999999个元素会伤及很遥远的一段内存，其恶果无法预测，问题也很难调试和定位。这种语义上的雷区称为末定义行为，C程序员应当对此很熟悉了。幸运的是，相比之下Go语言很少有这种问题

\==如何避免数据竞态==

1.  不要修改变量
2.  避免从多个 goroutine 访问同一个变量
3.  互斥机制（允许多个 goroutine 访问同一个变量，但同一时间只有一个 goroutine 可以访问）

goroutine 通过通道向受限的 goroutine 发送查询请求或更新变量，这就是所说的 ‘不要通过共享内存来通讯，而是要通过通讯来共享内存‘；==监控 goroutine==是指使用通道请求来代理**一个受限变量的所有访问**的 goroutine

```go
// bank 包提供了一个只有一个账户的并发安全银行

расkаgе bank

var deposits=make(chan int) //发送存款额
var balances=make(chan int)//接收余额
func Deposit(amountint){deposits<-amount}
func Balance()int { return<- balances}
func teller(){
  //balance被限制在 teller goroutine中
  var balance int
    for {
        select {
            case amount:=<-deposits:
                blance+=amount
            case balances <-balance
        }
    }
}
func init(
go teller()//启动监控goroutine
}
```

\==串行受限==借助通道共享变量的地址，从而在多个 goroutine 之间共享该变量，变量受限于每一步的 goroutine（监控 goroutine 每一步在变换）

### 互斥锁

一个计数上线为 1 的信号量称为==二进制信号量== （互斥量）

```go
// 通过二进制信号量实现互斥锁的模式
var (
sema = makee(chan struct{}, 1)
balance int
)

func Deposit(amount int){
sema <- struct{}{} // 获取令牌
balance += amount
<- sema // 释放令牌
}

func Balance() int {
sema <- struct{}{}
b:=balance
<- sema
return b
}
```

sync.Mutex 类型来支持互斥锁模式，其 Lock 方法用于获取令牌，Unlock 方法用于释放令牌。Unlock 一般放在 defer 语句中，避免执行不到的情况发生导致错误

互斥量保护共享变量， 按照惯例，被互斥量保护的变量声明应当紧接在互斥量的声明之后。如果实际情况不是如此，请确认已加了注释来说明此事。

\==临界区域==处于 Lock 与 Unlock 直接的可以自由地读取和修改共享变量的部分称为临界区域

每个函数在开始时申请一个互斥锁，在结束时再释放掉，通过这种方式来确保共享变量不会被并发访问。这种西数、互斥锁、变量的组合方式称为==监控(monitor)模式==。(之前在监控 goroutine 中也使用了监控(monitor)这个词，都代表使用一个==代理人(broker)==来确保变量按顺序访问。

### 读写互斥锁

只允许读操作可以并发执行，但写操作需要完全独享的访问权限，这种锁称为==多读单写锁==

mu.RLock 和 mu.RUnlock 读锁（又叫共享锁） mu.Lock 和 mu.Unlock 写锁（又叫互斥锁）（原子操作）

sync.RWMutex 类型来支持读写互斥锁

### 同步原语

\==同步原语==是一系列用于解决多个线程同时进入临界区造成的数据不同步的问题的==抽象同步机制==。在实际应用程序中，有很多需要同步的场景，为了正确、高效地解决这些同步问题，抽象出了一系列同步原语。其中==互斥锁==是最常用的同步原语之一，它可以确保同一时刻只有一个线程可以执行临界区，从而避免竞争冒险。除此之外，还有==条件变量==、==信号量==、==读写锁==、==RCU==等同步原语。这些同步原语都有各自的特点和适用场景，可以根据实际需求进行选择和使用

\==信号量==是一种用于提供不同进程之间或者一个给定的不同线程间同步手段的原语。它是一种计数器，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该信号量对象的等待（wait）时，该计数值减一；当线程完成一次对信号量对象的释放（release）时，计数值加一。信号量多用于进程间的同步与互斥。简单来说，同步是处理竞争，安排进程执行的先后顺序就是同步，每个进程都有一定的先后执行顺序；互斥是互斥访问不可共享的临界资源，同时会引发两个新的控制问题（互斥可以说是特殊的同步）；竞争是当并发进程竞争使用同一个资源的时候，我们就称为竞争进程。共享资源通常分为两类：一类是互斥共享资源，即任一时刻只允许一个进程访问该资源；另一类是同步共享资源，即同一时刻允许多个进程访问该资源；信号量是解决互斥共享资源的同步问题而引入的机制。

\==条件变量==是一种用于线程间同步的机制，它可以让一个线程等待另一个线程满足某个条件后再继续执行。条件变量通常与互斥锁一起使用，以确保线程安全。当一个线程等待条件变量时，它会释放互斥锁并进入阻塞状态，直到另一个线程通知它条件已经满足。条件变量的使用可以避免线程占用CPU资源。

\==RCU==是一种同步机制，全称为Read-Copy-Update。它的基本思想是先创建一个旧数据的副本，然后在副本上进行修改操作。在写者进行修改操作的过程中，旧数据没有做任何更新，不会产生读写竞争，因此依然可以被读者并行访问。当写者修改完成后，写者直接将新数据内存地址替换掉旧数据的内存地址，由于内存地址替换操作是原子的，因此可以保证读写不会产生冲突。内存地址替换后，原有读者访问旧数据，新的读者将访问新数据。当原有读者访问完旧数据，进入静默期后，旧数据将被写者删除回收。RCU适用于多读少写场景.RCU机制除了保护普通指针指向的数据之外, 还可以用于保护链表数据结构. Linux内核中, 提供了一系列的标准函数, 可以使用RCU机制保护双链表. 标准链表元素使用RCU机制保护的链表, 链表中的标准元素, 仍然可以使用. 遍历, 修改, 删除链表元素时, 需要调用标准函数的RCU变体.

### 内存同步

即在可能的情况下，把变量限制到单个goroutine 中，对于其他变量，使用互斥锁。

### 延迟初始化

sync.Once 类型用于针对一次性初始化问题；Once 包含 一个布尔变量和一个互 斥 量 ，布尔变量记录初始化是否已经完成，互斥量则负责保护这个布尔变量和客户端的数据结构。Once 的唯一方法 Do 以初始化函数作为它的参数

每次调用 Do 时先锁定互斥量然后检查布尔变量，第一次调用时布尔为假，调用初始函数后置为真，后续调用相当于空操作

### 竞态检测器(race detector)

`-race` 参数添加到 `go build`、 `go run`、 `go test` 命令即可

打开检测器的版本可以记录对共享变量的所有访问、读写共享变量的 goroutine 标识、所有同步事件（go 语句、通道操作、Lock、Wait等）

### goroutines 和线程

每个 ==OS 线程==都有一个固定大小的内存块（一般 2MB）来做栈，用来存储当前被存储或挂起（指调用其他函数时）的函数的内部变量。2MB对于一个小小的 goroutine 太大（内存浪费），go 会创建大量 goroutine，另外，固定大小的栈对于复杂或者深层次的递归来说又不太够用；修改固定大小可以提升空间的利用率允许创建更多的线程，并且可以允许更深的递归点用，但是这两者不可兼备

goroutine 则会以一个很小的栈（一般只需 2KB），和 OS 线程一样了，他也是保存其活跃或挂起的函数调用的本地变量，但不太一样的是 goroutine 的栈大小不固定==（动态栈）==，会根据需要动态伸缩。最大值有 1GB

OS 线程被系统内核调度，每隔几号秒硬件计时器会中断处理，内核函数 scheduler 会挂起当前执行的线程并保存内存中他的寄存器内容，检查线程列表决定下次那个线程被运行，并从内存中恢复该线程的寄存器信息，恢复执行线程的的现场并开始执行线程，由于是内核调度，所以一个线程向另一个线程移动需要完整的上下文切换；保存用户线程到内存，恢复另一线程的状态到寄存器，更新调度器的数据结构，这些操作比较耗时，需要多次访问内存，并且会增加运行的 CPU 周期

GO Runtime 包含自己的调度器，这个调度器使用了一些技术手段，如 ==m:n 调度==会在 n 个操作系统线程上多工（调度） m 个 goroutine，Go 调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的 Go 程序中的 goroutine (译注:按程序独立)。

和操作系统的线程调度不同的是，Go 调度器并不是用一个硬件定时器而是被Go语言"建筑"本身进行调度的。例如当一个 goroutine 调用了 time.Sleep 或者被 channel 调用或者 mutex 操作阻塞时，调度器会使其进入休眠并开始执行另一个 goroutine 直到时机到了再去唤醒第一个 goroutine。因为这 种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。

GO 调度器使用了一个叫做 ==GOMAXPROCS== 的变量来决定会有多少个操作系统的线程同时执行 GO 代码。其默认值是所运行机器的 CPU 核心数。休眠中的或 者在通信中被阻塞的 goroutine 是不需要一个对应的线程来做调度的。在 I/O 中或系统调用中或调用 非 Go 语言函数时，是需要一个对应的操作系统线程的，但是 GOMAXPROCS 并不需要将这几种情况计数在内。

可以通过修改环境变量 GOMAXPROCS，或者运行时用 runtime.GOMAXPROCS 函数来修改

```go
for {
    go fmt.Print(0)
    fmt.Print(1) 
}

$ GOMAXPROCS=1 go run hacker‐cliché.go 111111111111111111110000000000000000000011111...

$ GOMAXPROCS=2 go run hacker‐cliché.go 010101010101010101011001100101011010010100110...
```

在第一次执行时，最多同时只能有一个 goroutine 被执行。初始情况下只有 main goroutine 被执行， 所以会打印很多 1。过了一段时间后， GO 调度器会将其置为休眠，并唤醒另一个 goroutine，这时候就开始打印很多 0 了，在打印的时候，goroutine 是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个goroutine 可以一起被执行，以同样的频率交替打印 0 和 1。我们必须强调的是 goroutine 的调度是受很多因子影响的，而 runtime 也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。

在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的==身份(id)==，并且这个身份信息可以以一个普通值的形式被被很容易地获取到，典型的可以是一个 integer 或者指针值。这种情况下我们做一个抽象化的 thread­local storage(线程本地存储，多线程编程中不希望其它线程访问的内容)就很容易，只需要以线程的 id 作为 key 的一个 map 就可以解决问题，每一个线程以其 id 就能从中获取到值，且和其它线程互不冲突。

goroutine 没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于 thread­ local storage 总是会被滥用。比如说，一个 web server 是用一种支持 tls 的语言实现的，而非常普遍 的是很多函数会去寻找 HTTP 请求的信息，这代表它们就是去其存储层(这个存储层有可能是 tls)查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行 为下，一个函数的行为可能不是由其自己内部的变量所决定，而是由其所运行在的线程所决定。因 此，如果线程本身的身份会改变——比如一些 worker 线程之类的——那么函数的行为就会变得神秘 莫测。

Go 鼓励更为简单的模式，这种模式下参数对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。

你现在应该已经明白了写一个 Go 程序所需要的所有语言特性信息。在后面两章节中，我们会回顾 一些之前的实例和工具，支持我们写出更大规模的程序:如何将一个工程组织成一系列的包，如果 获取，构建，测试，性能测试，剖析，写文档，并且将这些包分享出去。# runtime
*   Goexit // 退出当前goroutine，defer会继续执行
*   Gosched // 出让当前goroutine执行权限
*   NumCPU // 返回CPU数量
*   NumGoroutine // 返回正在执行行和排队任务总数
*   GOMAXPROCS // 设置可以运行的CPU核数# safe
safe

安全编程

* * *

\[toc\]

数据加密

* * *

### 对称加密

*   采用单秘钥的加密算法
*   构成：明文+加密算法+秘钥
*   常见的算法：DES，AES，RC4

### 非对称加密

*   采用双秘钥加密算法
*   构成：明文+加密算法+私钥+公钥
*   公私钥均可加解密，公钥加密要私钥解密，私钥加密要公钥解密
*   常见算法：RSA
*   私钥不能暴露，公钥是公开的

### 哈希算法

*   只需要加密，生成密文，不需要解密或者不可解密
*   是一种从任意数据中创建固定长度摘要信息的办法
*   常见算法：MD5，SHA-1等

数字签名

* * *

*   指用于标记数字文件拥有者、创造者、分发者身份的字符串
*   数字签名拥有标记文件身份、分发的不可抵赖性等作用
*   常用的数字签名采用了非对称加密

a公司发布a.exe文件，a.exe加入a的签名（a公司私钥加密的哈希值），得到签名后的a.exe，查看签名。用a公司的公钥解密哈希从而验证是否篡改，是否是a公司发布

数字证书

* * *

数字证书包含公钥，使用公钥加密信息给公钥发布者。

PKI 体系

* * *

PKI，全称公钥基础设施，是使用非对称加密理论，提供数字签名、加密、数字证书等服务的体系，一般包括权威认证机构（CA)、数字证书库、秘钥备份及恢复系统、证书作废系统、应用接口等。

围绕PKI体系，建立了一些权威的、公益的机构。它们提供数字证书库、密钥备份及恢复系统、证书作废系统、应用接口等具体的服务

go 中的 hash 函数

* * *

*   crypto/sha1
*   crypto/md5

```go
// 直接生成
md5.New()
sha1.New()

// 计算文件
md5h := md5.New()
sha1h := sha1.New()
file, err := os.Open(p)
io.Copy(sha1h, file)
io.Copy(md5h, file)
```

加密通信

* * *

https = http + ssl/tls

ssl 是网景公司开发的位于TCP与HTTP协议间的透明安全协议

tls 是由IETF实现的建立在ssl v3.0之上的兼容协议，区别在于所支持的加密算法

### 加密通信流程

下面过程都是依赖于SSL/TLS层实现的。在实际开发中，SSL/TLS的实现和工作原理比较复杂，但基本流程一致

1.  输入https协议的网址
2.  服务器向浏览器返回证书，浏览器检查证书合法性
3.  验证和发行
4.  浏览器使用证书中的公钥加密一个随机对称秘钥，并将加密后的秘钥和使用秘钥加密后的请求URL一起发送到服务器
5.  服务器用私钥解密随机对称秘钥，并用获取的秘钥解密加密的请求URL
6.  服务器把用户请求的网页用秘钥加密，并返回给用户。
7.  浏览器用秘钥解密服务器发来的网页数据，并将其显示

ssl协议有两层组成，上层协议包括ssl握手协议、更改密码规格协议、警报协议，下层协议包括ssl记录协议

ssl握手协议建立在ssl记录协议之上，在实际数据传输前用于在客户端与服务器之间进行握手。握手是一个协商过程。这个协议使得客户和服务器能够互相鉴别身份，协商加密算法。在任何数据传输前必须先握手

握手之后才能进行ssl记录协议，它的主要功能是为高层协议提供数据封装、压缩、添加mac、加密等支持。

### 支持https的web服务器

*   crypto/x509 一种常用的数字证书格式
*   crypto/rand 伪随机函数发生器，产生基于时间和CPU时钟的伪随机函数
*   crypto/rsa 非对称加密算法
*   crypto/tls 传输层安全协议
*   crypto/pem 非对称加密体系下，一般用于存放公钥和私钥的文件
*   http.ListenAndServerTLS
*   fmt.Sprintf()
*   tls.Config
*   tls.Certificate
*   net.Listen
*   tls.NewListener
*   http.Serve
*   pem.Decode

### 支持https的文件服务器

### 基于SSL/TSL的ECHO程序

id: f329a6fbdfff4430b8e706cc72675c4a parent\_id: 0089871cb65c479da25a476e5fe78950 created\_time: 2022-03-01T08:07:32.000Z updated\_time: 2022-07-04T08:19:47.792Z is\_conflict: 0 latitude: 0.00000000 longitude: 0.00000000 altitude: 0.0000 author: source\_url: is\_todo: 0 todo\_due: 0 todo\_completed: 0 source: joplin-desktop source\_application: net.cozic.joplin-desktop application\_data: order: 1650118635360 user\_created\_time: 2022-03-01T08:07:32.000Z user\_updated\_time: 2022-04-16T14:17:15.376Z encryption\_cipher\_text: encryption\_applied: 0 markup\_language: 1 is\_shared: 0 share\_id: conflict\_original\_id: master\_key\_id: type\_: 1# toolchan
工具链

* * *

\[toc\]

安装
--

工具
--

### go build

每次都会重新编译除标准库以外的所有依赖包

参数

> \-o 可执行文件名（默认与目录同名） -a 强制重新编译所有包（含标准库） -p 并行编译所使用的CPU核数量 -v 显示待编译包名字 -n 仅显示编译命令，但不执行 -x 显示正在执行的编译命令 -work 显示临时工作目录，完成后不删除 -race 启动数据竞争检查（仅支持amd64） -gcflags 编译器参数
> 
> > \-B 禁用越界检查 -N 禁用优化 -l 禁用内联 -u 禁用unsafe -S 输出汇编代码 -m 输出优化信息
> 
> \-ldflags 链接器参数
> 
> > \-s 禁用符号表 -w 禁用DRAWF调试信息 -X 设置字符串全局变量值 -H 设置可执行文件格式

### go install

与build参数相同，但会将编译结果安装到bin、pkg目录，支持增量编译，没有修改的情况下，直接链接pkg目录中的静态包

编译器用buildid检查文件清单和导入依赖，对比现有静态库和所有源文件修改时间来判断源码是否变化，以此来决定是否需要对包进行重新编译。至于buildid算法，实现起来很简单：将包的全部文件名，运行时版本号，所有导入的第三方包信息（路径、buildid）数据合并后哈希

### go get

将第三方包下载到GOPATH列表的第一个工作空间，默认不更新，需要”-u“参数

> \-d 仅下载，不安装 -u 更新包，包括其依赖项 -f 和 -u配合，强制更新，不检查是否过期 -t 下载测试代码所需的依赖包 -insecure 使用HTTP等非安全协议 -v 输出详细信息 -x 显示正在执行的命令”

### go env

### go clean

清理工作目录，删除编译和安装遗留的目标文件

> \-i 清理go install安装的文件 -r 递归清理所有依赖包 -x 显示正在执行的清理命令 -n 仅显示清理命令，但不执行

编译
--

编译并不仅仅是执行“go build”命令，还有一些须额外注意的内容。 如习惯使用GDB这类调试器，建议编译时添加-gcflags "-N -l"参数阻止优化和内联，否则调试时会有各种“找不到”的情况。

发布时参数-ldfalgs "-w -s"会让链接器剔除符号表和调试信息，能减小可执行文件并稍稍增加反编译难度。

### 交叉编译

所谓交叉编译，是指在一个平台下编译出其他平台所需要的可执行文件。

GO自举后只需使用GOOS、GOARCH环境变量指定目标平台和架构

### 条件编译

代码中用runtime.GOOS判断外，编译器本身就支持文件级别的条件编译

#### 将平台和架构信息添加到主文件名尾部

*   hello\_darwin.go hello\_linux.go
*   使用GOOS交叉编译,编译器会选择对应源码编译
*   文件名除GOOS外，还可以加上GOARCH，或任选其一

```sh
$GOOS=darwin go build -x
compild ... -pack./hello_darwin.go./main.go

$GOOS=linux go build -x
compild ... -pack./hello_linux.go./main.go
```

#### 使用build编译指令

与用文件名区分多版本类似，build编译指令告知编译器：当前源码文件只能用于指定环境。

a.go

```go
// +build windows
                    <--- 必须要有空格
package main
...
```

b.go

```go
// +build darwin
                    <--- 必须要有空格
package main
...
```

可以有多条build指令，表示and

// +build linux darwin // +build 386,!cgo

相当于 (linux OR darwin) AND (386 AND (NOT cgo))

#### 使用自定义tag命令

// +build!release

// +build log

go build -tags "release log"

### 预处理

使用 go generate 命令扫描源码文件，找出所有 "go: generate" 注释，提取其中命令并执行

参数

> *   \-v 显示处理的包及文件名
> *   \-x 显示准备执行的命令
> *   \-n 仅显示命令，但不执行

*   命令必须放在.go源文件中。
*   命令必须以“//go：generate”开头（双斜线后不能有空格）。
*   每个文件可有多条generate命令。
*   命令支持环境变量。
*   必须显式执行go generate命令。
*   按文件名顺序提取命令并执行。
*   串行执行，出错后终止后续命令的执行

这种设计的初衷是为包开发者准备的，可用其完成一些自动处理命令。比如在发布时，清理掉一些包用户不会使用的测试代码。除此之外，还可用来完成基于模板生成代码（类似泛型功能），或将资源文件转换为源码（.resx嵌入资源）等工作。

a.go

```go
// go:generate echo $GOPATH
// go:generate ls -lh
// go:generate uname -a

package main
...
```

可以定义别名，但当前文件有效，可多次使用

```go
// go:generate-command LX ls -l
// go:generate LX /var
// go:generate LX /usr
```# session
\[toc\]

Cookie

* * *

*   会话期 Cookie 会话期 cookies 将会在客户端关闭时被移除。 会话期 cookie 不设置 Expires 或 Max-Age 指令。注意浏览器通常支持会话恢复功能。
*   持久化 Cookie 持久化 Cookie 不会在客户端关闭时失效，而是在特定的日期（Expires）或者经过一段特定的时间之后（Max-Age）才会失效。
*   非法域 属于特定域的 cookie，假如域名不能涵盖原始服务器的域名，那么应该被用户代理拒绝。
*   Cookie 前缀 名称中包含 \_\_Secure- 或 \_\_Host- 前缀的 cookie，只可以应用在使用了安全连接（HTTPS）的域中，需要同时设置 secure 指令。另外，假如 cookie 以 \_\_Host- 为前缀，那么 path 属性的值必须为 "/"（表示整个站点），且不能含有 domain 属性。对于不支持 cookie 前缀的客户端，无法保证这些附加的条件成立，所以 cookie 总是被接受的。

```
type Cookie struct {
Name string
Value string
Path string
Domain string
Expries time.Time
RawExpries string

MaxAge int
Secure bool
HttpOnly bool
Raw string
Unparsed []string
}
```

*   http.SetCookie(w http.ResponseWriter, &http.Cookie)
*   Request.Cookie(name string)
*   Requese.Cookies()

```
for _,cookie := range r.Cookies(){
cookie.Name
cookie.Value
}
```

Session

* * *

会话，有始有终的一系列动作/消息，当Session一词与网络协议相关联时，它又往往隐含了“面向连接”和/或“保持状态”这样两个含义

Session 在 Web 开发中，指一类用来在客户端与服务端之间保持状态的解决方案。有时亦指这种解决方案的存储结构。

Session 是一种服务端机制，服务端使用类似散列表的结构（或者就是散列表）来保存信息。

*   客户端请求创建 Session
*   服务端检查客户端请求是否包含 Session 表示（Session ID）
*   如果有 Session 标识，说明已创建过，按照 Session ID 把 Session 检索出来使用（如果检索不到（可能服务端已删除对应 Session，用户人为添加的 JSESSION 参数），可能会新建一个）
*   如果不包含 Session ID 则会创建一个 Session 并且生成一个相关联的 Session ID，返回给客户端保存

\==Session机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器、服务器的经验当作普遍适用的。==

### Session 创建

1.  生成全局唯一标识 Session ID
2.  开辟数据存储空间。服务端程序一般会在内存中创建相应的数据结构，但这种情况下，系统一旦断电，所有的会话数据就会丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，当然这样会增加I/O开销，但是它可以实现某种程度的Session持久化，也更有利于Session的共享。
3.  Session ID 发送给客户端（最关键）
    *   方式一 Cookie
    *   方式二 URL 重写（在返回给用户的页面里的所有的URL后面追加 Session 标识符，比较麻烦，但客户端禁用 Cookie 的话是首选方案）

### Session 管理

*   全局 Session 管理器
*   保证 Session ID 全局唯一性
*   为每个客户关联一个 Session
*   Session 的存储（存储到内存 文件 数据库）
*   Session 过期处理

Session 劫持

* * *

Session 劫持是中间人攻击的一种类型，SessionId 这暴露后可以直接冒充用户

### 防范

#### 方法一

*   SessionId 只允许 Cookie 设置，而不是通过 URL 重置的方式，同时设置 httponly
    *   这样可以防止 Cookie 被 XSS 读取从而引起 Session 劫持
    *   Cookie 设置不会像 URL 重置那样容易获取 SessionId
*   每个请求中加上 token，加一个隐藏 token 每次验证 token 保证用户请求唯一性

#### 方法二

给 Session 额外设置一个创建时间的值，过期销毁，重新生成，一定程度可以防止劫持

上面两个手段的组合可以在实践中消除Session劫持的风险，一方面，由于SessionID频繁改变，使攻击者难有机会获取有效的SessionID；另一方面，因为SessionID只能在Cookie中传递，然后设置了httponly，所以基于URL攻击的可能性为零，同时被XSS获取SessionID也不可能。最后，由于我们还设置了MaxAge=0，这样就相当于Session、Cookie不会留在浏览器的历史记录里面。