# 内存模型
内存一致性模型简称内存模型，关注的是存储在内存中的数据更改的可见性和一致性

硬件内存模型

* * *

编程语言内存模型

* * *# atomic
原子操作

* * *

\==原子操作==是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）

原子操作由底层硬件支持，锁由系统提供api实现。所以原子操作通常更有效率。

\[TOC\]

原子操作种类

* * *

1.  增或减
2.  比较并交换（CAS，Compare And Swap）
3.  载入
4.  存储
5.  交换

atomic

* * *# 逃逸分析
变量是在堆上分配，还是在栈上分配，是经过编译器的`逃逸分析`之后得出的结论，这一切都是Go编译器在背后帮我们完成的

在编译原理中，分析指针动态范围的方法称之为`逃逸分析`。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。更简单来说，`逃逸分析`决定一个变量是分配在堆上还是分配在栈上。

栈内存分配和释放简单，堆内存分配复杂，要找大小合适的内存块，回收要靠 GC ( Garbage Collection )，减少 GC 压力会提高性能

逃逸分析的场景

* * *

Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。编译器会分析代码的特征和代码生命周期，在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。

### 指针逃逸

```text-plain
func scape() *int {
  a:=10
  return &a
}
```

`go build -gcflags "-m -l" go_file.go`

### 栈空间不足

### 闭包引用

### 动态类型逃逸

对于不确定大小的变量或参数 `interface{}`

### 切片或 map 赋值

给切片或者map赋值对象指针（与对象共享内存地址时），对象会逃逸到堆上。但赋值对象值或者返回对象值切片是不会发生逃逸的。

gcflags

* * *

*   \-l
*   \-m

### \-S

`go build -gcflags=-S . > asm.s 2>&1`# 内连优化
编译器的内连优化

* * *

内联是编程语言编译器常用的优化手段，其优化的对象为函数，也称为函数内联。如果某函数支持内联，则意味着编译器可以直接使用==函数体/函数定义==替换掉对函数的调用代码，以消除调用函数带来的额外开销 \[\[Drawing 2024-05-23 10.10.31.excalidraw\]\]核心改进方向：性能（GC、编译器）、并发、泛型、模块化、工具链。
### **Go 1.5** (2015)
- **并发垃圾回收 (GC)**：引入并行 GC，显著减少停顿时间。
- **自举实现**：运行时完全用 Go 重写，移除 C 依赖（来源：早期版本特性）。
### **Go 1.6** (2016)
- **SSA 编译器**：优化代码生成，提升性能。
- **HTTP/2 支持**：`net/http` 默认支持 HTTP/2（来源：早期版本特性）。
### **Go 1.7** (2016)
- **Context 包**：引入 `context` 管理请求生命周期。
- **编译器改进**：SSA 后端进一步优化（来源：早期版本特性）。
### **Go 1.8** (2017)
- **插件支持**：通过 `plugin` 包动态加载共享库（Linux）。
- **GC 停顿优化**：降至亚毫秒级（来源：早期版本特性）。
### **Go 1.9** (2017)
- **类型别名**：支持 `type T1 = T2`，简化重构。
- **并发 Map**：`sync.Map` 提供线程安全 Map（来源：早期版本特性）。
### **Go 1.10** (2018)
- **构建缓存**：加速重复编译和测试（来源：早期版本特性）。
### **Go 1.11** (2018)
- **Go Modules**：实验性模块化依赖管理（`go.mod`）。
- **WebAssembly 支持**：编译为 WASM（来源：早期版本特性）。
### **Go 1.12** (2019)
- **TLS 1.3**：`crypto/tls` 默认支持（来源：早期版本特性）。
### **Go 1.13** (2019)
- **错误处理**：`errors.Is` 和 `errors.As` 简化错误链处理。
- **数字字面量**：支持二进制/十六进制浮点数（来源：早期版本特性）。
### **Go 1.14** (2020)
- **Defer 优化**：性能提升，减少开销。
- **Modules 默认启用**：取代 GOPATH（来源：早期版本特性）。
### **Go 1.15** (2020)
- **链接器优化**：减少二进制体积，提升编译速度（来源：早期版本特性）。
### **Go 1.16** (2021)
- **嵌入文件**：`//go:embed` 指令嵌入静态资源。
- **IO 文件系统**：`io/fs` 抽象文件系统接口（来源：网页6）。
### **Go 1.17** (2021)
- **泛型实验**：通过 `-G=3` 启用。
- **数学常量**：`math.MaxInt`、`MinInt`。
- **时间方法**：`UnixMilli()`、`UnixMicro()`（来源：网页1）。
### **Go 1.18** (2022)
- **泛型正式支持**：类型参数 `T any`。
- **工作区模式**：`go.work` 管理多模块。
- **IP 处理**：`net/netip` 高效操作 IP（来源：网页1、6）。
### **Go 1.19** (2022)
- **内存模型更新**：明确并发内存规则。
- **原子操作**：`atomic.Int64`、`atomic.Uint64`（来源：网页6）。
### **Go 1.20** (2023)
- **随机数改进**：`math/rand` 自动种子。
- **时间格式**：`time.DateTime`、`DateOnly`。
- **加密支持**：`crypto/ecdh`（来源：网页6）。
### **Go 1.21** (2023)
- **结构化日志**：`log/slog`。
- **泛型工具包**：`slices`、`maps` 操作函数（来源：网页1、6）。
### **Go 1.22** (2024)
- **模块优化**：严格依赖版本控制。
- **WASM 性能**：减少代码体积，增强 GC（来源：网页2、4）。
### **Go 1.23** (2024)
- **弱指针与终结器**：`runtime.AddCleanup` 替代 `SetFinalizer`。
- **模板迭代器**：简化数据遍历（来源：网页4）。
### **Go 1.24** (2025)
- **泛型类型别名**：`type VectorAlias[T] = Vector[T]`。
- **工具链增强**：`go.mod` 的 `tool` 指令管理工具。
- **性能提升**：
  - Map 改用 SwissTable，性能提升 30%。
  - WASM 支持并发与 GC 优化（来源：网页2、3、4、5）。
