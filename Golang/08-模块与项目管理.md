# mod
Modules

* * *

go.mod 是 Golang1.11 引入的依赖包管理工具，解决没有地方记录依赖包版本的问题

Modules 是相关 Go 包的集合，是源码交换和版本控制单元；其替换旧的基于GOPATH的方法来指定使用那些源文件

*   Modules 不需要 src，bin 等这样的子目录，只要其包含 go.mod 文件即可（哪怕是有 go.mod 的空文件夹）
*   GO111MODULE=off/on/auto(default);off 时使用vendor目录或GOPATH模式查找，on 使用modules，完全不使用GOPATH，auto 文件在包含 go.mod 文件的目录下或在GOPATH/src外且包含go.mod文件的目录- go mod init
- go get
- go mod tidy
- go mod vender
## go.mod
主要字段：
- module 定义模块路径，通常是导入路径
- go 指定版本
- require 列出项目依赖及版本
- replace 替换某个依赖的路径
- exclude 排除特定版本依赖
## go.sum
- 模块路径和版本 + 哈希值（模块内容）
- go.mod 文件路径 + go.mod 文件的哈希值# import
1.  相对路径 当前目录同目录
2.  绝对路径 gopath/src

点操作

* * *

```go
import (
    . fmt
)
Printf
```

别名
--

```go
import (
    f "fmt"
)
```

\_ 操作

* * *

```go
_ "github.com/user/restory/name"
```

\_ 操作的作用是引入包，不直接使用包内函数，只调用包内 init 函数# package
包
-

\[toc\]

工作空间

* * *

由 src、bin、pkg 三个目录组成，空间路径通常要添加到 GOPATH 环境变量中

*   src 源码
*   bin 可执行文件安装路径，不会创建额外子目录
*   pkg 包安装路径，按操作系统和平台隔离

环境变量

* * *

*   编译器按 GOPATH 设置的路径搜索目标。go get 默认将下载第三方包放到第一个工作空间
*   GOROOT 用于指示工具链和标准库的存放位置
*   GOBIN 强制代替工作空间的bin目录，作为go install目标保存路径

包
-

```
package <pkg_name>
```

### main 包

*   main 包是一个可独立运行的包，编译后产生可执行文件；
*   其他包会生成`*.a`文件（包文件）放置在 `$GOPATH/pkg/$GOOS_$GOARCH` 中；
*   main 包必须有一个入口函数 main，没有参数，会自动调用

### init 函数

没有任何参数和返回值,会自动调用

*   应用于所有包
*   init 函数是可选的，可以有多个

### 导入包

import 导入标准库或第三方包，参与是工作空间中以src为起始的绝对路径；一个包被多个包同时导入，那么它只会被导入一次

```go
import "net/http" // /usr/local/go/src/net/http
```

*   程序的初始化和执行都起始于main包；
*   一个包被导入时，会先将其导入的其他包导入进来
*   先对导入包的包级常量和变量进行初始化，接着执行init函数（如果有的话）依此类推。
*   所有被导入的包都加载完毕，就会开始对 main 包中的包级常量和变量进行初始化
*   然后执行main包中的init函数（如果存在的话），最后执行main函数

#### 别名

```go
import osx "github.com/apple/osx/lib"
```

\==import 导入参数是路径，而非包名。== ==习惯包和目录保持一致，但不是强制规定==。代码中引入包成员时，使用包名而非目录名。

四种导入包方式

```go
// 默认方式
// test.A
import "github.com/qyuhen/test"

// 别名方式
// X.A
import X "github.com/qyuhen/test"

// 简单方式
// 常用于单元测试，正式代码不推荐使用
// A
import . "github.com/qyuhen/test"

// 初始化方式
// 无法引用，仅用来初始化
// 仅仅是为让目标包初始化函数执行,而非引用其成员
import _ "github.com/qyuhen/test"
```

相对路径

* * *

除工作空间和绝对路径外部分工具还支持相对路径。可在非工作空间目录下，直接运行、编译一些测试代码

自定义路径

* * *

即便将代码托管在GitHub，但我们依然希望使用自有域名定义下载和导入路径。方法很简单，在Web服务器对应路径返回中包含“go-import”跳转信息即可。

```go
package main
  
import( 
    "fmt" 
    "net/http" 
) 
  
func handler(w http.ResponseWriter,r*http.Request) { 
   fmt.Fprint(w, `<meta name="go-import" content="qyuhen.com/test git https://github.com/qyuhen/test" />`) 
} 
  
func main() { 
   http.HandleFunc("/test",handler) 
   http.ListenAndServe(":80",nil) 
}

// go get-v-insecure qyuhen.com/test
```

组织结构

* * *

包有一个或多个保存在同一目录下（不包含子目录）的源码文件组成。包的用途类似命名空间，是成员作用域和访问权限的便捷。

*   包名与目录名并无关系，不要求一致
*   包名通常使用单数形式
*   源码文件必须使用UTF-8格式，否则报错
*   同目录下所有源码文件必须使用相同包名称
*   因导入时使用绝对路径，所以在搜索路径下，包必须有唯一路径，但无须是唯一名字

```go
go list net/... # 显示包路径列表
```

被保留、有特殊含义的包名称

*   main 可执行入口（入口函数main.main）
*   all 标准库以及GOPATH中能找到的所有包
*   std,cmd 标准库及工具链
*   documentation 存档文档信息，无法导入（和目录名无关）

相关工具会忽略以"."或"\_"开头的目录或文件，但允许导入保存这些目录中的包

### 权限

所有成员在包内均可访问，名称大写的为可导出成员，在包外可视。

可以通过指针转换等方式绕开限制

```go
// lib/data.go

package lib

type data struct{
    x int
    Y int
}

func NewData() *data{
    return new(data)
}

// test.go

package main

import (
    "test/lib"
    "unsafe"
)

d:=lib.NewDate()
d.Y=200
p:=(*struct{x int})(unsafe.Pointer(d)) // 利用指针转换访问私有字段
p.x=100
```

### 初始化

包内每个源文件都可定义一个到多个初始化函数，但编译器不保证执行次序

所有初始化函数（包括标准库和导入第三方包）都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且仅执行一次。

编译器首先确保完成所有全局变量初始化，然后才开始执行初始化函数。

初始化函数中也可以有goroutine。

初始化函数无法手动调用。

### 内部包

内部包机制相当于增加了新的访问权限控制：所有保存在internal目录下的包（包括自身）仅能被其父目录下的包（含所有层次的子目录）访问。

src/ src/main.go src/lib/ src/lib/internal src/lib/internal/a src/lib/internal/b src/lib/x src/lib/x/y

内部包internal a b 仅能被 lib lib/x lib/x/y 访问，导入内部包必须使用完整路径 lib/internal/a

依赖管理

* * *

使用vendor机制，专门存放第三方包，实现将源码和依赖完成完整打包分发。如果说internal针对内部，那么vendor就是external。

src/ src/server/ src/server/vendor src/server/vendor/github.com src/server/vendor/github.com/qyuhen src/server/vendor/github.com/qyuhen/test src/server/main.go

```go
import "github.com/qyuhen/test"
```

优先使用vendor/github.com/qyuhen/test

导入vendor中第三方包，参数以vendor为起点绝对路径，这就避免vendor目录位置带来的麻烦，让导入无论使用vendor还是GOPATH都能保持一致，vendor比标准库优先级更高。

有多级vendor目录嵌套时，从当前源文件所在目录开始，逐级向上构造vendor全路径，直到发现路径匹配的目标为止。匹配失败，则依旧搜索GOPATH

src/ | +--server/ | +--vendor/ | | | +--p/ #p1:src/vendor/p# | | | +--x/ | | | +--test.go | | | +--vendor/ | | | +--p/ #p2:src/vendor/x/vendor/p# +--main.go

对于main.go而言构造出的路径是src/server/vendor/p

对于test.go而言构造出的路径是src/server/vendor/x/vendor/p

要使用vendor机制，需开启GO15VENDOREXPERIMENT=1，1.6版本默认开启，且必须设置了GOPATH工作空间# 9. packages
*   为了简化大型程序的设计和维护工作
*   将一组相关的特性放进一个独立的单元以便于理解和更新
*   在每个单元更新的同时保持和程序中其它单元的相对独立性
*   允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。

go list str go env

\==编译速度快的三个原因==

1.  导入的包必须在每个文件开头显示声明，无需分析整个文件
2.  禁止包的环状依赖，没有循环依赖，依赖关系形成一个有向无环图，每个包可以独立编译、并发编译
3.  编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。编译时不需要遍历所有依赖的文件，只要读取导入包的目标文件

\==路径==

如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。

\==声明==

文件开头有包的声明语句，包名，作为导入时的默认标识。 通常默认包名就是导入路径的最后一段

三种例外

1.  main 包，导入路径无关紧要，名为 main 包是给 go build 构建命令一个信息，此包编译完后会调用连接器生成一个可执行文件
2.  目录中 `_test.go` 为后缀的 go 原文件，包名也是以 `_test` 结尾，这是测试的外部扩展包，由 go test 命令独立编译，普通包和测试的外部扩展包是相互独立的
3.  一些依赖版本号的管理工具会在导入路径后追加版本号信息 `gopkg.in/yaml.v2` 此时包名不包含版本号，而是 yaml

\==导入声明==

如果包名相同，需要在导入时指定一个新的包名避免冲突；导入包==重命名==可以解决包名冲突；还可以解决倒入包的包名笨重可以起一个简单的更方便；

```go
import (
"crypto/rand"
mrand "math/rand"
<别名> <path
)
```

\==匿名导入==

`import _ "image/png"` 导入包的==副作用==，会计算包级变量的初始化表达式和执行导入包的 init 初始化函数

\==包和命名==

*   用短小的包名，但要容易理解，常用的标准包 bufio, bytes, flag, fmt, http, io, json, os, sort, sync, time
*   一般采用单数形式，标准包 bytes、errors、strings 使用复数是为了避免和预定类型冲突

\==工具==

go 工具箱既是一个包管理工具，也是一个构建系统，也是一个单元测试基准测试的驱动程序

*   build 编译包
    
*   clean 清除 object 文件
    
*   doc 显示报的文档或标志
    
*   env 打印 go 的环境信息
    
*   fmt 在包的源码上运行 gofmt
    
*   get 下载并安装包及其依赖
    
*   install 编译安装包及其依赖
    
*   list 列出包
    
*   run 编译运行 go 程序
    
*   test 测试包
    
*   version 打印 go 版本
    
*   vet 在包上运行 go 工具 vet
    
*   GOPATH go 工作区目录
    
    *   src 源码
    *   bin 边以后的可执行文件
    *   pkg 边以后的目标文件
*   GOROOT go 的安装目录，标准库目录，一般不需要设置，默认为安装的路径
    
*   GOOS 指定目标操作系统
    
*   GOARCH 指定处理器类型
    

\==下载包==

```go
go get <name> 下载单个包
go get ... 下载整个子目录里的每个包
go get -u 可以确保所有包和依赖的包

go help importpath
```

*   go get 安装的包是完整的 git 仓库
*   包的导入路径含有的网站域名和 git 仓库对应的远程地址不一定相同
*   vendor 目录用于存储依赖包的固定版本的源代码（go help gopath）

\==构建包== go build

go install 和 go build 相似，前者会保存每个报的编译成果，编译的包放在 $GOPATH/pkg，路径与 src 目录对应，可执行文件放在$GOPATH/bin 目录；两者都不会重新编译没有发生变化的包；`go build -i` 安装每个目标所依赖的包；编译结果会放到 GOOS 和 GOARCH 对应的目录

*   如果包是一个库，则忽略输出结果；这可以用于检测包的可以正确编译的。
*   如果包的名字是main，go build将调用连接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。

\==标准包== go list std

\==包文档==

go 鼓励为每个包提供良好的文档。每个导出的成员和包声明前都应包含目的和用法说明的注释

包文档注释一般是完整的句子，第一行是包的摘要说明，注释后紧跟着包声明语句，注释中函数的参数或其他的标识符并不需要额外的引号或其他标记注明。

```go
// Fprintf formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encountered. 
func Fprintf(w io.Writer, format string, a ...interface{}) (int, error)
```

注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（其实可以有多个，他们会组合成一个包文档注释），当注释特别长时一般会放到一个独立文件中，用于保存文档的源文件通常叫 `doc.go`

`go doc` 这个命令打印包的声明和每个成员的文档注释或者某个具体包的一个方法的注释文档。

```go
go doc time              // package
go doc time.Since        // method

go doc time.Duration     // type
go doc time.Duration.Abs // method

// 此命令大小写不敏感，切不需要输入完整的包导入路径

go doc time.abs      // time.Duration.Abs
go doc time.duration // time.Duration
```

`godoc` 提供相互交叉引用的 HTML 页面，包含与 `go doc` 相同以及更多的信息。

\==内部包== ==internal包== Go 语言构建工具对包含 internal 名字的路径段的包导入路径做特殊处理，这种包叫 internal 包。

internal 包只能被和 internal 目录有同一个父目录的包所导入，`net/http/internal/chunked` 只能被 `net/http/httputil` 或 `net/http` 包导入，但是不能被 `net/url` 包导入，`net/url` 可以导入 `net/http/httputil`

\==查询包==

`go list` 可以查询可用包的信息。可以检测包是否在工作区并打印导入路径，还可以使用 `...` 表示任意包，可以列出所有包

```go
$ go list github.com/go-sql-driver/mysql
github.com/go-sql-driver/mysql

$ go list ...
$ go list gopl.io/ch3/...
$ go list ...xml...
encoding/xml
gopl.io/ch7/xmmlselect
```

`go list -json hash` -json 参数表示用 JSON 格式打印每个包的元信息 -f 参数允许使用 text/template 包的模板语言定义文本输出的格式 `go list -f '{{join .Deps " "}}' strconv` windows 下需要转义双引号 `go list -f '{{join .Deps \" \"}}' strconv`# project
工程管理

* * *

\[toc\]

命令行工具

* * *

### 基本用法

gotool 可以：

*   代码格式化
*   代码质量分析和修复
*   单元测试与性能测试
*   工程构建
*   代码文档的提取和展示
*   依赖包管理
*   执行其他的包含指令

```bash
go version
go help
```

代码风格

* * *

go 代码规范分两类

1.  由go编译器进行强制的编码规范
2.  由gotool推行的非强制性编码风格建议

### 强制性编码规范

#### 命名

*   任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的用小写
*   使用驼峰命名法，禁止使用下划线命名法

#### 排列

*   左花括号紧跟代码
*   else等紧跟右花括号

### 非强制性编码风格

```go
// 带名称检查单个文件
// 不带名称检查目录下所有*.go
$ go fmt
```

远程import支持

* * *

```go
import (
 "github.com/myteam/exp/crc32"
)

go get github.com/myteam/exp/crc32
```

工程组织

* * *

### GOPATH

定位源码依赖GOPATH

### 目录结构

*   README 简单介绍项目目标和关键的注意事项
*   LICENSE 工程采用的分发协议

标准go语言工程包括：

*   src/ 包含所有源代码，这是个强制规则
*   pkg/ 自动创建
*   bin/ 自动创建

文档管理

* * *

程序包括代码和文档

软件产品包括源代码、可执行程序、文档和服务

文档，单行 // 多行 /\*\*/

*   代码中的注释、函数、接口的输入、输出、功能和参数说明
*   版权说明注释
*   包说明注释
*   函数说明注释
*   遗留问题说明

```go
// 提取文档
go doc <包名>

go doc -http=<PORT> -path=<PATH>
```

文档规则

*   注释需要紧贴在对应的包声明核函数之前，不能有空行
*   注释如果要新奇一个段落，应该用一个空白注释行隔开，因为直接换行书写会被认为是正常的段内折行
*   可以直接使用 // BUG(author): 的方式记录该代码片段中的遗留问题，这些遗留问题也会被抽到文档中

工程构建

* * *

```go
// 生成二进制文件
// 可执行文件放入/bin目录，如果是个包则放入/pkg目录
go build <包名>

// 执行install时，如果没有执行build，会先执行build
go install <包名>
```

跨平台开发

* * *

### 交叉编译

*   linux下可以生成以下目标格式x86 ELF、AMD64 ELF、ARM ELF、x86 PE和AMD64 PE
*   windows下x86 PE和AMD64 PE

可以通过设置GOOS和GOARCH两个环境变量来制定交叉编译的目标格式。

| $GOOS | $GOARCH |
| --- | --- |
| darwin | 386 |
| darwin | amd64 |
| freebsd | 386 |
| freebsd | amd64 |
| linux | 386 |
| linux | amd64 |
| linux | arm |
| windows | 386 |
| windows | amd64 |

### android 支持

android 基于linux所以也可以编译android go

单元测试

* * *

```go
// 单元测试
go test

// 性能测试,加-test.bench参数
go test -text.bench 
```

单元测试源文件命名规则：待测试包下创建\_test结尾的go文件

*   功能测试函数：以 Test 开头，\*testing.T 为单一参数的函数
*   性能测试函数：以 Benchmark 开头，\*testing.T 为单一参数的函数

打包分发

* * *

就目前而言，以二进制方式分发Go包并不是很现实。由于Go语言对于兼容性控制的非常严 格，任何一个版本号的不同都将导致无法链接包。因此，如果你使用Go语言开发了一个库，那 么最合适的库分发方式是直接打包源代码包并进行分发，由使用者自行编译。 当然，可执行文件没有这个问题。因此如果要避免这个包链接的问题，可以考虑如何将核心 功能以二进制的服务器程序形式提供，并辅以开源的客户端SDK。# gvm
*   gvm install \[goversion\]
*   gvm use \[goversion\] \[--default\]
*   gvm list
*   gvm listall
*   gvm pkgset
*   gvm pkgenv
*   gvm uninstall \[goversion\]
*   gvm implode ## 完全卸载掉 GVM 和所有安装的 Go 版本