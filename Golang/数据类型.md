# 数据类型
整型
--

### 有符号

int8, int16, int32(rune), int64

> rune 和 init32 等价，通常表示一个 Unicode 码点

### 无符号

uint8(byte), uint16, uint32, uint64

> byte 和 unit8 等价，通常用于强调数值是一个原始的数据而不是一个小的整数

### int 和 uint

一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint;其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设;因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

### uintptr

没有指定具体 bit 大小但是足以容纳指针，只有在底层编程时才需要

### 算数运算符

| 优先级1 | 优先级2 | 优先级3 | 优先级4 | 优先级5 |
| --- | --- | --- | --- | --- |
| `*` | `+` | \== | `&&` | \|  |
| `/` | `-` | `!=` |     |     |
| `%` | \| or | `<` |     |     |
| `<<` | `^` xor | `<=` |     |     |
| `>>` |     | `>` |     |     |
| `&` and |     | `>=` |     |     |
| `&^` and not |     |     |     |     |

*   算术上 `<<n` 等价于乘以 2n, ​​`>>n`​​ 等价于除以 2n
*   按位置零(AND NOT):如果对应 y 中 bit 位为 1 的话, 表达式 z = x &^ y 结果 z 的对应的 bit 位为 0，否则 z 对应的 bit 位等于 x 相应的 bit 位的值。
*   同优先级使用左优先结合规则
*   `%` 取模运算符的符号和被取模数的符号总是一致的
*   `/` 除法运算的行为则依赖于操作数是否全为整数

```text-plain
-5%3=-2
-5%-3=-2

5.0/4.0=1.25
5/4=1 // 整数除法会向着0方向截断余数
```

*   \==计算结果溢出，高位丢弃，有符号最左侧为符号为，可能最终结果是负数==

```text-plain
var u uint8 = 255
// 1111 1111, 0000 0000, 0000 0001
fmt.Println(u, u+1, u*u) // "255 0 1"

var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 ‐128 1"
```

\==无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。== 一般来说，需要一个显式的转换将一个值从一种类型转化位另一种类型，并且算术和逻辑运算的二 元操作中必须是相同的类型。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关 的问题，而且也使得程序容易理解。

```text-plain
var a int16 = 1
var b int32 = 2
var compote int = a + b // err

var compote int = int(a) + int(b) // ok
```

任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。

```text-plain
o:=0666
fmt.Printf("%d %[1]o %#[1]o\n", o)
```

请注意 fmt 的两个使用技巧。通常 Printf 格式化字符串包含多个 `%` 参数时将会包含对应相同数量的额外操作数，但是 `%` 之后的 `[1]` 副词告诉 Printf 函数再次使用第一个操作数。第二，`%` 后的 `#` 副词告诉 Printf 在用 `%o`、`%x` 或 `%X` 输出时生成 0、0x 或 0X 前缀。

浮点数

* * *

Go 提供两种浮点数，float32 和 float64，math.MaxFloat32 表示 float32 最大值，math.MaxFloat64 表示 float64 最大值 算数规范由 IEEE754 浮点数国际标准定义，IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现） 一个 float32 （单精度，1个符号位，8个指数位，23个尾数位）类型的浮点数可以提供大约 6 个十进制数的精度，而 float64（双精度，1个符号位，11个指数位，52个尾数位）则可以提供约 15 个十进制数的精度;通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且能精确表示的正整数并不是很大(译注:因为 float32 的有效 bit 位只有 23 个，其它的 bit 位用于指数 float32 和符号;当整数大于 23bit 能表达的范围时，float32 的表示将出现误差)

根据算数规范IEEE754

复数
--

两种复数类型 complex64 和 complex128 对应 float32 和 float64 两种浮点数精度 我们把形如z=a+bi（a、b均为实数）的数称为复数。其中，a称为[实部](https://baike.baidu.com/item/%E5%AE%9E%E9%83%A8/53626919?fromModule=lemma_inlink)，b称为虚部，i称为虚数单位。当z的虚部b＝0时，则z为实数；当z的[虚部](https://baike.baidu.com/item/%E8%99%9A%E9%83%A8/5231815?fromModule=lemma_inlink)b≠0时，实部a＝0时，常称z为[纯虚数](https://baike.baidu.com/item/%E7%BA%AF%E8%99%9A%E6%95%B0/3386848?fromModule=lemma_inlink)。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。 内置函数：

*   complex 用于构建复数
*   real 用于返回复数实部
*   imag 用于返回复数虚部

```text-plain
x := complex(1,2) // 1+2i
x := 1 + 2i // 1+2i
x := 2i + 1 // 1+2i
```

复数也可以使用 `==` 和 `!=` 进行比较，`math/cmplx` 包提供复数处理函数

布尔 bool

* * *

```text-plain
s != "" && s[0] == "x"
```

这样表达式总是安全的，`s[0]` 操作如果作用与空字符串将会导致 panic 异常

布尔值不会隐式转换为数值 0 或 1，反之亦然

```text-plain
i := 0
if b {
    i = 1
}

func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}

// 数字到布尔型的逆转换则非常简单, 不过为了保持对称, 我们也可以包装一个函数:

func itob(i int) bool { return i != 0 }
```

常量
--

常量表达式在编译器计算，而不是在运行期，当操作数是常量时，一些运行时的错误也可以在编译期发现，常量的所有算术运算、逻辑运算和比较运算结果也是常量。

*   len
*   cap
*   real
*   imag
*   complex
*   unsafe.Sizeof 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始 化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。

```text-plain
const (
    a = 1
    b
    c=2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"
```

### iota

生成一组相似规则初始化的常量，不用每行都写一遍初始化表达式

```text-plain
type Weekday int

const (
    Sunday Weekday = iota // 0
    Monday // 1
    Tuesday // 2
    Wednesday // 3
    Thursday // 4
    Friday // 5
    Saturday // 6
)

type Flags uint

const (
    FlagUp Flags = 1 << iota
    FlagBroadcast
    FlagLoopback
    FlagPointToPoint
    FlagMulticast
)

const (
    _   = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 << 64)
    YiB // 1208925819614629174706176
)
```

### 无类型常量

六种未明确类型的常量类型（为没有明确基础类型的常量提供比基础类型更高精度的类型）

1.  无类型的布尔型
2.  无类型的整型
3.  无类型字符
4.  无类型浮点数
5.  无类型复数
6.  无类型字符串 通过延迟明确常量具体类型，无类型常量==可以提供更高的运算精度，可以直接用于更多的表达式而不需要显示的类型转换。== 比如说上例中的 YIB、ZIB 超出任何整数类型的表达范围，但依然是合法常量 还比如 math.Pi，无类型常量可以用于任何需要浮点数的常量赋值给 float32、float64，complex128 类型，如果 math.Pi 被确定为指定类型那精度就不一样了同时对其他类型还要进行转换

```text-plain
var x float32 = math.Pi
var x float64 = math.Pi
var x complex128 = math.Pi

const Pi64 float64 = math.Pi
var x float32 = float32(Pi64)
var x float64 = Pi64
var x complex128 = complex128(Pi64)
```

除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达 式可能对应不同的结果:

```text-plain
var f float64 = 212

fmt.Println((f ‐ 32) * 5 / 9) // "100"; (f ‐ 32) * 5 is a float64 
fmt.Println(5 / 9 * (f ‐ 32)) // "0"; 5/9 is an untyped integer, 0 
fmt.Println(5.0 / 9.0 * (f ‐ 32)) // "100"; 5.0/9.0 is an untyped float
```

只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语 句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式 转换为对应的类型，如果转换合法的话。 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和 复数，可能会有舍入处理 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变 量指定明确的类型

### 分组

```text-plain
const i = 100
const pi = 3.14
const prefix = "Go_"

// 分组
const (
    i = 100
    pi = 3.14
    prefix = "Go_"
)
```

错误类型

* * *

```text-plain
err := errors.New("emit macho dwarf: elf header corrupted")
if(err != nil){
    fmt.Print(err)
}
```

数组
--

有==固定长度==的==特定类型元素==组成的序列，由于长度固定所以很少直接使用，Slice是可以增长和收缩的动态序列，更灵活，但要理解 slice 需要先理解数组

*   元素可通过索引下标访问，索引从零开始，len 函数返回数组元素个数
*   数组每个元素会被初始化为元素类型的零值，也可使用一组值来初始化`[3]int{1,2,3}`​
*   数组字面值中出现 `...`​ 表示长度有初始化元素个数决定 `[...]int{1,2,3}`​
*   数组长度是数组类型的一部分 `[3]int`​ 和 `[4]int`​ 是不同类型
*   数组、slice、map、struct 字面值的写法很相似，直接提供初始值序列，或者指定索引和对应值的方式初始化 `[3]int{0:0,1:1,2:2}`​ 定义一个含有 100 个元素的数组 `[...]int{99: -1}`​ 第 100 个元素初始化为 -1 其他为零值
*   一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的(必须是同类型数组，所有元素相等才相等)

```text-plain
[2][4]int{ [4]int{1,2,3,4}, [4]int{1,2,3,4} }

[2][4]{ {1,2,3,4}, {1,2,3,4} }
```

Slice 动态数组

* * *

和数组一样，只是没有长度声明 `var fslice []int`​

*   切片代表变长的序列，元素为相同类型，一般写作 `[]T`​；
*   类似数组，无固定长度，slice 是数组子序列，底层引用一个底层数组；
*   一个 slice 有三部分构成：指针、长度、容量；
*   指针指向 slice 第一个元素对应底层数组元素的地址；长度对应 slice 元素个数，不能超过容量；容量为 slice 开始的位置到底层数组的结尾位置；len 和 cap 分别返回长度和容量

### 切片操作

*   ​`s[i:j] 0 <= i <= j <= cap(s)`​
*   从第 i 元素开始，到 j - 1 个元素结束，长度 j - i
*   i 被省略将从 0 开始，j 被省略将从 len(s) 开始
*   字符串的切片操作和 \[\]byte 字节类型切片的切片操作是类似的
*   x\[m:n\]切片操作对于字符串则生成一个新字符串，如果x是\[\]byte的话则生成一个新的\[\]byte
*   一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数，第一次是反转开头的n 个元素，然后是反转剩下的元素，最后是反转整个slice的元素。(如果是向右循环旋转，则将第三 个函数调用移到第一个调用位置就可以了
*   和数组不同的是，slice之间不能比较，因此我们不能使用操作符来判断两个slice是否含有全部相 等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等 (\[\]byte)，但是对于其他类型的slice，我们必须自己展开每个元素进行比较
*   slice唯一合法的比较操作是和nil比较
*   通过 len(s) == 0 来判断 slice 是否为空，不应使用是否为 nil 判断
*   使用 make 创建时，cap 可以省略 `make([]T, len)`​ `make([]T, len, cap)`​

```text-plain
var s []int // nil
s = nil // nil
s = []int(nil) // nil
s = []int{} // != nil
```

### append

*   用来向 slice 追加元素，append 过程中，先检测 slice 底层数组 cap 是否足够容纳新增元素，如果足够直接扩展 slice，将新元素直接复制到扩展的空间，新老 slice 共用一个底层数组。如果 cap 不足以容纳新元素，会先分配一个足够大的 slice，将原来的值和新增的值都添加到新的 slice，新老 slice 不会共用一个底层数组
*   copy 函数第一个参数是要复制的目标 slice，第二个参数是源 slice，目标和源的位置顺序和 dst = src 复制语句是一致的。会返回成功复制的元素个数（等于两个 slice 中长度较小的那个）
*   为了提高内存使用效率，新分配的数组一般略大于保存被操作的两个 slice 所需要的最低大小。通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间

```text-plain
func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    if zlen <= cap(x) {
        z = x[:zlen]
    } else {
        zcap := zlen
        if zcap < 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x)
    }
    copy(z[len(x):], y)
    return z
}
```

内置的append函数可能使用比appendInt更复杂的内存扩展策略。因此，通常我们并不知道append 调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的 底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是 将append返回的结果直接赋值给输入的slice变量`a = append(a, b)`​ 要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是 slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样 一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型

```text-plain
type Slice struct {
    array unsafe.Pointer
    len, cap int
}
```

### copy

Copy from one slice to another

```text-plain
var s = make([]int, 3)
n := copy(s, []int{0, 1, 2, 3}) // n == 3, s == []int{0, 1, 2}
```

Copy from a slice to itself

```text-plain
s := []int{0, 1, 2}
n := copy(s, s[1:]) // n == 2, s == []int{1, 2, 2}
```

Copy from a string to a byte slice (special case)

```text-plain
var b = make([]byte, 5)
copy(b, "Hello, world!") // b == []byte("Hello")
```

### 内存技巧

```text-plain
// pop
top := stack[len(stack) - 1]
stack = stack[:len(stack) - 1]

// splice(slice,b)
copy(slice[b:],slice[b+1:])
slice[:len(slice)-1]
```

Map

* * *

哈希表是是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的 key 可以在常数时间复杂度内检索、更新或删除对应的value。 一个 map 就是是个哈希表的引用，map\[K\]V，所有 key 都有相同类型，所有 value 也有相同类型；key 必须是支持 == 比较运算符的数据类型。

```text-plain
// 创建一个 map

// make 创建
make(map[string]string)

// 字面值创建
map[string]int{
    "name": "deve",
    "age": "34",
}

// 创建空 map
map[string]int{}

// 删除元素
delete(theMap, theKey)

theMap[theKey]+=1
theMap[theKey]++
```

#### 声明

```text-plain
var myMap map[string] PersonInfo
var <var_name> map[key_type>] <val_type>
```

#### 创建

```text-plain
myMap = make(map[string] PersonInfo)
myMap = make(map[string] PersonInfo, 100)
myMap = map[string] PersonInfo {
    "123": PersonInfo{"12", "jack", "Room 444,..."}
}
```

#### 赋值

```text-plain
myMap["123"] = PersionInfo{"1","jack","Room 595,..."}
```

#### 删除

```text-plain
delete(myMap, 'key')
```

#### 查找

```text-plain
value, ok := myMap["key"] // 使用ok-idiom获取值，可知道key/value是否存在
if ok {}
```

所谓ok-idiom模式，是指在多返回值中用一个名为ok的布尔值来标示操作是否成功。因为很多操作默认返回零值，所以须额外说明

向 map 存数据前必须先创建，零值 nil 的 map 写入元素会导致 panic 要注意的是 map 的元素并不是一个变量，所以不能对 map 的元素进行取址操作 `&theMap[theKey]`​ 禁止对 map 元素取址的原因是随着 map 元素数量的增长 map 可能会重新分配更大的内存空间，导致之前地址无效。 遍历可以使用 `range`​ 和 slice 类似，遍历顺序每次不同（每次都使用随机的遍历顺序可以强制 要求程序不会依赖具体的哈希函数实现），要按顺序遍历可以先对 key 排序 `sort.Strings([]string)`​

```text-plain
for key, value := range theMap {}
```

map 中区分元素值为 0 时，是零值的 0，还是真是存在的 0

```text-plain
age, ok := theMap[theKey]
if !ok {/* 这时说明是零值的 0 */}

if age, ok := theMap[theKey];!ok {}
```

和 slice 一样，除了值为 nil 的 map 也不能进行比较

```text-plain
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false 
    }
    for k, xv := range x {
        // 判断 map 间元素是否相同，
        // 不能只单纯比较 value（xv != yv)
        // 值为零，和值为零值是要区分
        // 需使用 !ok || xv != yv
        if yv, ok := y[k]; !ok || yv != xv { 
            return false
        }
    }
    return true
}

equal(map[string]int{"A": 0}, map[string]int{"B": 42}) // map1,map2 的 A 值都为零，但性质不一样
```

使用 slice 作为 key，绕过 map 的 key 必须是可比较的限制

1.  定义一个将 slice 转为 map 对应的 string 类型的 key 的函数，确保 key1 和 key2 相等时 f(key1) == f(key2) 才成立
2.  创建一个 key 为 string 类型的 map，每次对 map 操作时先用辅助函数将 slice 转为 string

make

* * *

make 用于内建类型（slice/map/channel）的内存分配

*   make 只能创建 slice/map/channel 并返回有初始值（非零）的 T 类型，而不是 `*T`​
*   指向数据结构的引用在使用前必须被初始化，如 slice 是一个包含指向数据（内部 array ）的指针、长度、容量的三项描述符在这些被初始化之前，slice 为 nil，make 初始化了数据结构填充适当的值，返回初始化后的（非零）值。

### slice

make(T, len\[, cap = len\])

### map

make(T \[, init\_space\])

### channel

make(T \[, buffer\_size\])

new

* * *

new 用于各种类型的内存分配，本质上和其他语言中的同名函数一样，new（T）分配了零值填充的 T 类型的内存空间，返回其地址 `*T`​ (返回的是指针) ==零值== int,int8,int32,int64,float32,float64 0 unit 0x0 rune 0 byte 0x0 bool false string ""

‍