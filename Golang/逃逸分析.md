# 逃逸分析
变量是在堆上分配，还是在栈上分配，是经过编译器的`逃逸分析`之后得出的结论，这一切都是Go编译器在背后帮我们完成的

在编译原理中，分析指针动态范围的方法称之为`逃逸分析`。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。更简单来说，`逃逸分析`决定一个变量是分配在堆上还是分配在栈上。

栈内存分配和释放简单，堆内存分配复杂，要找大小合适的内存块，回收要靠 GC ( Garbage Collection )，减少 GC 压力会提高性能

逃逸分析的场景

* * *

Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。编译器会分析代码的特征和代码生命周期，在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。

### 指针逃逸

```text-plain
func scape() *int {
  a:=10
  return &a
}
```

`go build -gcflags "-m -l" go_file.go`

### 栈空间不足

### 闭包引用

### 动态类型逃逸

对于不确定大小的变量或参数 `interface{}`

### 切片或 map 赋值

给切片或者map赋值对象指针（与对象共享内存地址时），对象会逃逸到堆上。但赋值对象值或者返回对象值切片是不会发生逃逸的。

gcflags

* * *

*   \-l
*   \-m

### \-S

`go build -gcflags=-S . > asm.s 2>&1`