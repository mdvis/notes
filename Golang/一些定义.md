# 一些定义
程序结构

* * *

\[toc\]

关键字

* * *

*   var 和 const
*   package 和 import
*   func
*   return
*   defer
*   go
*   select
*   interface
*   struct
*   break/case/continue/for/fallthrough/else/if/switch/goto/default
*   chan
*   type
*   map
*   range

预定义名称

* * *

### 内建常量

true false iota nil

### 内建类型

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| int | int8 | int16 | int32 | int64 |     |
| unit | unit8 | unit16 | unit32 | unit64 | unitptr |
| float32 | float64 | complex128 | complex64 |     |     |
| bool | byte | rune | string | error |     |

### 内建函数

*   make
*   len
*   cap
*   new
*   append
*   copy
*   close
*   delete
*   complex
*   real
*   imag
*   panic
*   recover

声明
--

*   var
*   const
*   type
*   func

\*\*简短变量声明 \*\*​ **​**​ **​`:=`​**​**​**

**退化赋值操作**

```go
var i, j, k int
var m, n, j = true, 2, "ji"
```

变量
--

### 零值

零值初始化机制使得 Go 中不存在未初始化的变量

*   数字零值是 0
*   布尔零值是 false
*   字符串零值是 ""
*   接口或引用类型（slice ptr map chan func）零值是 nil
*   数组或结构体零值是 每个元素或字段都是对应类型的零值

### 指针

```go
var x int
// &x 指向变量的指针,其数据类型为 *int（指针为指向 int 类型的指针）
var p *int = &x
// p 指针指向变量 x（保存了变量 x 的内存地址）
// *p 读取指针指向的变量的值，值为 int 类型，*p 同时是个变量，可以改变指针指向的变量的值
*p = 4
```

指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双 刃剑:要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名(译注:这是Go语 言的垃圾回收器所做的工作)。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如 slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。

### new

`new(T)` 创建 T 类型的匿名变量，初始化为 T 类型零值，返回变量地址 `*T` new 为语法糖，和普通变量声明语句方式创建变量没区别 new 为预定义函数，不是关键字，可以重新定义

```go
func delta(old, new int) int {return new - old} // new 被重新定义，函数 delta 中无法使用内置 new 函数
```

### 变量声明周期

*   包一级的变量和程序运行周期一直
*   局部变量生命周期到不被引用为止

\==函数的有右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。== 变量引用算法大概是，从每个包记得变量和每个运行的函数的么个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到变量。如果不存在则说明变量不可达，就是说存在与否不影响运行结果。变量的有效期只取决于是否可达

赋值
--

```go
x = 1
*ptr = true
o.p = ""
a[i] *= x // a[i] = a[i] * x
```

### 元组赋值

是指一种赋值形式，允许同时更新多个变量值，赋值前右侧表达式会先求职

```go
x, y = y, x
m, n = m, m%n
a, b, c = 1, 2, 3

f, err := os.Open("...")
// ok-idom (map 查找, 类型断言, 通道接收)
v, ok := m[key]
v, ok := x.(T)
v, ok := <-ch
```

### 可赋值性

不同类型可赋值（隐式赋值，显示赋值）性规则有不同要求

*   类型必须完全匹配
*   nil可以赋值给任何指针或引用类型的变量
*   两个值是否可以用==或`!=`，比较的第二个值对第一个值是可赋值的，反之亦然

类型
--

`type 类型名 底层类型`

对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出;不过国 内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符 当作大写字母处理。

\==一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供 了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。==

\==对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型(译注:如果T是指针类 型，可能会需要用小括弧包装T，比如 (\*int)(0) )。只有当两个类型的底层基础类型相同时，才允 许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响 值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。==

\==数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的==

\==比较运算符 == 和 `<` 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底 层类型的未命名类型的值之间做比较。==

\==许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的 String方法返回的结果打印==

包和文件

* * *

包的目的都是为了支持模块化、封装、单独编译和代码重用. 通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释，如果有多个包注释目前会按照文件名的先后链接为一个包注释，如果注释很大，通常会放到独立的`doc.go`文件中

### 初始化

首先包级变量按声明出现的顺序依次初始化，多个 go 文件按照文件名排序后依次编译 复杂的初始化工作可是使用 init 函数，一个包可以有多个 init 函数，init 函数会按照声明顺序在程序开始执行时依次自动调用

### 作用域

在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面 的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归 引用了自身，则会产生编译错误。

```go
if f, err:=os.Open(fname); err != nil {
    return err
}

// f 作用域只在 if 语句内
f.ReadByte() // undefined f
f.Close() // undefined f
```

```go
var cwd string

func init() {
    // 这一句重新声明了 cwd 屏蔽了外部 cwd
    cwd, err := os.Getwd() // compile error: unused: cwd if err != nil {
    log.Fatalf("os.Getwd failed: %v", err) }
}
```