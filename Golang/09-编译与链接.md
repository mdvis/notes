# cgo
与其他语言交互性

* * *

自C语言诞生以来，程序员们已经积累了无数的代码库。即使后面还出现了众多时髦的新语言，有无数的代码库都还很偏执地只提供了C语言版本。因此，如何快捷方便地直接引用这些功能强大且供量过硬的C语言库，就成了所有现代语言都不得不重视的话题。作为一门直接传承于C的语言，Go当然应该将与C语言的交互作为首要任务之一。Go确实也 提供了这一功能，称为Cgo。

```go
/*
#include <stdlib.h>
*/
import "C" // 告诉Cgo开始工作，工作内容就是将前面注释中的C源码自动生成包装性质的Go代码
```

函数调用从汇编的角度看，就是一个将参数按顺序压栈 (push)，然后进行函数调用(call)的过程。Cgo生成的代码只不过是帮你封装了这个压栈和调用 的过程，从外面看起来就是一个普通的Go函数调用。

只要是紧贴在import “C” 前，单行注释多行注释都可以生效

类型映射

* * *

跨语言交互有两个复杂问题

1.  类型映射
2.  跨越调用边界传递指针所带来的对象生命周期和内存管理问题

| Go  | C   |
| --- | --- |
| C.char/schar | signed char |
| C.uchar | unsigned char |
| C.short/ushort | unsigned short |
| C.int/uint | unsigned int |
| C.long/ulong | unsigned long |
| C.longlong | long long |
| C.ulonglong | unsigned long long |
| C.float |     |
| C.double |     |
| unsafe.Pointer | void\* |
| struct\_ | struct |
| union\_ | union |
| enum\_ | enum |

如果C语言中的类型名称或变量名称与Go语言的关键字相同，Cgo会自动给这些名字加上下 划线前缀。

字符串映射

* * *

Go中有字符串类型，C中是字符数组

Cgo提供C.Cstring、C.GoString、C.GoStringN

由于C.CString的内存管理方式与Go语言自身的内存管理方式不兼容，我们设法期待Go语 言可以帮我们做垃圾收集，因此在使用完后必须显式释放调用C.CString所生成的内存块，否则 将导致严重的内存泄露。结合我们之前已经学过的defer用法，所有用到C.CString的代码大致 都可以写成如下的风格:

```go
var gostr string
cstr := C.Cstring(gostr)
defer.C.Free(unsafe.Pointer(cstr))
```

C程序

* * *

```go
package hello

/*
#include <stdio.h>
void hello(){
printf("Hello,Cgo")
}
*/
import "C"

func Hello()int{
return int(C.hello())
}
```

cgo 伪C文法，指定依赖的第三方库和编译选项

* * *

```go
// #cgo CFLAGS: -DPNG_DEBUF=1
// #cgo linux CFLAGS: -DLINUX=1 
// #cgo LDFLAGS: -lpng
// #include <png.h>
import "C"
```

使用CFLAGS来传入编译选项，使用LDFLAGS来传入链接选项

```go
// #cgo pkg-config: png cairo 
// #include <png.h>
import "C"
```

函数调用

* * *

```go
n, err := C.atoi("a234")
n,err := C.f(&array[0])
```

编译Cgo

* * *# link
连接符号

* * *

链接符号关心的是如何将语言文法使用的符号转化为链接期使用的符号，在常规情况下，链 接期使用的符号对我们不可见，但是在一些特殊情况下，我们需要关心这一点，比如:在用 gdb 调试的时候，要设置断点:b <函数名>，这里的<函数名>是指“链接符号”，而非我们平常看到 的语言文法层面使用的符号。

```go
package Package

func Method(arg1 ArgType1, arr2....) (ret1 RetType1, ret2....)
func (v ClassType) Method(arg1 ArgType1, arr2....) (ret1 RetType1, ret2....)
func (v *ClassType) Method(arg1 ArgType1, arr2....) (ret1 RetType1, ret2....)
```

Go没有重载，所以语言的连接符号由如下信息组成

*   Package
*   ClassType
*   Method

连接符号组成规则

*   Package.Method
*   Package.ClassType.Method

```go
// qbox.us/mockfs模块

func New(cfg Config) *MockFS
func (fs *MockFS) Mkdir(dir string) (code int, err error) 
func (fs MockFS) Foo(bar Bar)

// 对应符号链接

qbox.us/mockfs.New
qbox.us/mockfs.*MockFS·Mkdir
qbox.us/mockfs.MockFS·Foo
```# source
源码
--

编译好的可执行文件真正的执行入口并非我们所写的main.main函数，编译器总会插入一段引导代码，完成如命令行参数、运行时初始化等工作，然后进入用户逻辑

调试程序时，建议使用`go build -gcflags "-N -l"` 参数关闭编译器代码优化和函数内联，避免断点和单步执行无法准确对应源码行

```sh
go build -gcflags "-N -l" -o test test.go
gdb test
(gdb)info files
Entry point:0x44dd00
(gdb)b*0x44dd00
(gdb)b runtime.rt0_go
```

使用断点命令可以轻松找到目标源文件信息

GDB常用的调试命令

* * *

*   （gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h
*   （gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r
*   （gdb）start：单步执行，运行程序，停在第一执行语句
*   （gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l
*   （gdb）set：设置变量的值
*   （gdb）next：单步调试（逐过程，函数直接执行）,简写n
*   （gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s
*   （gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt
*   （gdb）frame：切换函数的栈帧,简写f
*   （gdb）info：查看函数内部局部变量的数值,简写i
*   （gdb）finish：结束当前函数，返回到函数调用点
*   （gdb）continue：继续运行,简写c
*   （gdb）print：打印值及地址,简写p
*   （gdb）quit：退出gdb,简写q
*   （gdb）break+num：在第num行设置断点,简写b
*   （gdb）info breakpoints：查看当前设置的所有断点
*   （gdb）delete breakpoints num：删除第num个断点,简写d
*   （gdb）display：追踪查看具体变量值
*   （gdb）undisplay：取消追踪观察变量
*   （gdb）watch：被设置观察点的变量发生修改时，打印显示
*   （gdb）i watch：显示观察点
*   （gdb）enable breakpoints：启用断点
*   （gdb）disable breakpoints：禁用断点
*   （gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元
*   （gdb）run argv\[1\] argv\[2\]：调试时命令行传参# go汇编
go 汇编

ChatGPT

Go 汇编是指在 Go 语言中使用汇编语言进行编程。这通常是为了实现某些性能关键的操作或者访问特定的硬件功能。Go 语言提供了一些工具和约定，使得在 Go 代码中可以嵌入汇编代码。

### 基本概念

1.  **Plan 9 汇编语法**：Go 使用了一种类似 Plan 9 操作系统的汇编语法，不同于传统的 AT&T 或 Intel 汇编语法。
2.  **函数定义**：汇编函数定义使用 `.TEXT` 伪指令。
3.  **寄存器**：使用前缀 `$` 表示立即数，`R` 表示寄存器，`(R)` 表示寄存器指针，`(R)(R*scale)` 表示基址+索引。

### 基本示例

以下是一个简单的 Go 汇编示例：

go

复制代码

`package main // 声明汇编函数 func Add(a, b int) int func main() { result := Add(3, 5) println(result) // 输出 8 }`

对应的汇编代码（文件名：`add_amd64.s`）：

assembly

复制代码

`TEXT ·Add(SB), NOSPLIT, $0-24 MOVQ a+0(FP), AX // 将参数 a 移动到寄存器 AX MOVQ b+8(FP), BX // 将参数 b 移动到寄存器 BX ADDQ BX, AX // AX = AX + BX MOVQ AX, ret+16(FP) // 将结果放到返回值位置 RET`

### 详细说明

*   `TEXT ·Add(SB), NOSPLIT, $0-24`:
    *   `TEXT` 表示定义一个文本段。
    *   `·Add` 表示函数名 `Add`。
    *   `SB` 是一个符号基址。
    *   `NOSPLIT` 表示不进行栈拆分。
    *   `$0-24` 表示栈帧的大小。
*   `MOVQ a+0(FP), AX` 和 `MOVQ b+8(FP), BX`：
    *   `MOVQ` 表示移动 64 位数据。
    *   `a+0(FP)` 表示从参数 `a` 所在的位置获取值，`FP` 是帧指针。
    *   `AX` 和 `BX` 是 x86-64 的通用寄存器。
*   `ADDQ BX, AX`：将 `BX` 中的值加到 `AX` 中。
*   `MOVQ AX, ret+16(FP)`：将 `AX` 中的值放到返回值的位置。
*   `RET`：返回。

### 常用寄存器

*   **通用寄存器**：AX, BX, CX, DX, SI, DI, BP, SP, R8-R15。
*   **特殊寄存器**：IP（指令指针），FLAGS（标志寄存器）。

### 栈帧布局

在 Go 汇编中，栈帧布局对于函数调用和参数传递至关重要。栈帧通常包括：

1.  返回地址。
2.  保存的寄存器。
3.  本地变量。
4.  参数。

### 调试和优化

1.  **调试**：可以使用 `gdb` 或者 `delve` 等调试器。
2.  **优化**：通过了解 CPU 架构和指令集，可以手工优化一些性能关键的代码路径。

### 参考资料

*   [Go 官方文档中的汇编部分](https://golang.org/doc/asm)
*   [Go 汇编的官方示例](https://github.com/golang/go/tree/master/src/runtime/internal/sys)

通过理解这些基本概念和示例，你可以开始在 Go 代码中使用汇编来提高性能或实现特定的低级功能。

4o

go 汇编 常用指令

ChatGPT

在 Go 汇编中，常用指令与标准汇编指令相似，但由于 Go 汇编采用了 Plan 9 汇编语法，某些指令和使用方法可能与传统的 AT&T 或 Intel 语法略有不同。下面是一些常用的 Go 汇编指令及其用途：

### 数据传输指令

*   **MOVQ src, dst**: 移动 64 位数据。
*   **MOVL src, dst**: 移动 32 位数据。
*   **MOVW src, dst**: 移动 16 位数据。
*   **MOVB src, dst**: 移动 8 位数据。

示例：

assembly

复制代码

`MOVQ AX, BX // 将 AX 寄存器的值移动到 BX 寄存器 MOVQ $10, AX // 将立即数 10 移动到 AX 寄存器`

### 算术指令

*   **ADDQ src, dst**: 将 64 位的 src 加到 dst。
*   **ADDL src, dst**: 将 32 位的 src 加到 dst。
*   **SUBQ src, dst**: 将 64 位的 src 从 dst 中减去。
*   **SUBL src, dst**: 将 32 位的 src 从 dst 中减去。
*   **MULQ src**: 64 位无符号乘法，将结果存放在 AX。
*   **IMULQ src**: 64 位有符号乘法，将结果存放在 AX。
*   **DIVQ src**: 64 位无符号除法，商存放在 AX，余数存放在 DX。
*   **IDIVQ src**: 64 位有符号除法，商存放在 AX，余数存放在 DX。

示例：

assembly

复制代码

`ADDQ AX, BX // 将 AX 和 BX 的值相加，结果存放在 BX SUBQ $5, AX // 将 AX 中的值减去 5，结果存放在 AX`

### 逻辑指令

*   **ANDQ src, dst**: 进行 64 位按位与操作。
*   **ORQ src, dst**: 进行 64 位按位或操作。
*   **XORQ src, dst**: 进行 64 位按位异或操作。
*   **NOTQ dst**: 对 64 位的 dst 进行按位取反操作。

示例：

assembly

复制代码

`ANDQ AX, BX // 对 AX 和 BX 进行按位与操作，结果存放在 BX XORQ $0x1, AX // 对 AX 进行按位异或操作，结果存放在 AX`

### 移位指令

*   **SHLQ count, dst**: 将 64 位的 dst 左移 count 位。
*   **SHRQ count, dst**: 将 64 位的 dst 右移 count 位。
*   **SARQ count, dst**: 将 64 位的 dst 算术右移 count 位。

示例：

assembly

复制代码

`SHLQ $2, AX // 将 AX 中的值左移 2 位 SHRQ $3, BX // 将 BX 中的值右移 3 位`

### 流程控制指令

*   **JMP label**: 无条件跳转到指定标签。
*   **JE label**: 如果等于，跳转到指定标签。
*   **JNE label**: 如果不等于，跳转到指定标签。
*   **JG label**: 如果大于，跳转到指定标签。
*   **JL label**: 如果小于，跳转到指定标签。
*   **JGE label**: 如果大于等于，跳转到指定标签。
*   **JLE label**: 如果小于等于，跳转到指定标签。
*   **CALL target**: 调用函数。
*   **RET**: 返回。

示例：

assembly

复制代码

`CMPQ AX, BX // 比较 AX 和 BX JE label // 如果 AX == BX，跳转到 label JMP next // 无条件跳转到 next label: // 代码块 next: // 代码块`

### 比较指令

*   **CMPQ src, dst**: 比较 64 位的 src 和 dst。
*   **CMPL src, dst**: 比较 32 位的 src 和 dst。
*   **TESTQ src, dst**: 对 64 位的 src 和 dst 进行按位与操作并设置条件码。
*   **TESTL src, dst**: 对 32 位的 src 和 dst 进行按位与操作并设置条件码。

示例：

assembly

复制代码

`CMPQ AX, BX // 比较 AX 和 BX JE label // 如果 AX == BX，跳转到 label TESTQ AX, AX // 测试 AX 是否为零 JZ label // 如果 AX 为零，跳转到 label`

### 函数调用和返回

*   **CALL target**: 调用目标函数。
*   **RET**: 从函数返回。

示例：

assembly

复制代码

`CALL ·SomeFunction(SB) // 调用 Go 函数 SomeFunction RET // 从当前函数返回`

### 寄存器说明

*   **AX, BX, CX, DX**: 通用寄存器。
*   **SI, DI**: 源索引和目标索引寄存器。
*   **SP**: 栈指针。
*   **BP**: 基指针。
*   **R8-R15**: 额外的通用寄存器。

### 特殊指令

*   **LEAQ src, dst**: 计算内存地址，将结果存入 dst。
*   **NOP**: 空操作，不执行任何操作。

示例：

assembly

复制代码

`LEAQ 8(SP), AX // 计算 SP+8 的地址，将结果存入 AX NOP // 执行空操作`

### 汇编函数示例

以下是一个完整的汇编函数示例，该函数计算两个整数的和：

Go 代码：

go

复制代码

`package main func Add(a, b int) int func main() { result := Add(10, 20) println(result) // 输出 30 }`

汇编代码（`add_amd64.s`）：

assembly

复制代码

`TEXT ·Add(SB), NOSPLIT, $0-24 MOVQ a+0(FP), AX // 将第一个参数 a 移动到 AX MOVQ b+8(FP), BX // 将第二个参数 b 移动到 BX ADDQ BX, AX // 将 BX 加到 AX 上 MOVQ AX, ret+16(FP) // 将结果存放到返回值 RET // 返回`

这些常用指令和示例应该可以帮助你在 Go 汇编中编写高效的代码。了解这些指令的使用方法和语法规则是掌握 Go 汇编编程的基础。# 汇编
Go 汇编是指在 Go 语言中使用汇编语言进行编程。这通常是为了实现某些性能关键的操作或者访问特定的硬件功能。Go 语言提供了一些工具和约定，使得在 Go 代码中可以嵌入汇编代码。

### 基本概念

1.  **Plan 9 汇编语法**：Go 使用了一种类似 Plan 9 操作系统的汇编语法，不同于传统的 AT&T 或 Intel 汇编语法。
2.  **函数定义**：汇编函数定义使用 `.TEXT` 伪指令。
3.  **寄存器**：使用前缀 `$` 表示立即数，`R` 表示寄存器，`(R)` 表示寄存器指针，`(R)(R*scale)` 表示基址+索引。

### 基本示例

以下是一个简单的 Go 汇编示例：

```go
package main

// 声明汇编函数
func Add(a, b int) int

func main() {
    result := Add(3, 5)
    println(result) // 输出 8
}
```

对应的汇编代码（文件名：`add_amd64.s`）：

```assembly
TEXT ·Add(SB), NOSPLIT, $0-24
    MOVQ a+0(FP), AX // 将参数 a 移动到寄存器 AX
    MOVQ b+8(FP), BX // 将参数 b 移动到寄存器 BX
    ADDQ BX, AX      // AX = AX + BX
    MOVQ AX, ret+16(FP) // 将结果放到返回值位置
    RET
```

### 详细说明

*   `TEXT ·Add(SB), NOSPLIT, $0-24`:
    *   `TEXT` 表示定义一个文本段。
    *   `·Add` 表示函数名 `Add`。
    *   `SB` 是一个符号基址。
    *   `NOSPLIT` 表示不进行栈拆分。
    *   `$0-24` 表示栈帧的大小。
*   `MOVQ a+0(FP), AX` 和 `MOVQ b+8(FP), BX`：
    *   `MOVQ` 表示移动 64 位数据。
    *   `a+0(FP)` 表示从参数 `a` 所在的位置获取值，`FP` 是帧指针。
    *   `AX` 和 `BX` 是 x86-64 的通用寄存器。
*   `ADDQ BX, AX`：将 `BX` 中的值加到 `AX` 中。
*   `MOVQ AX, ret+16(FP)`：将 `AX` 中的值放到返回值的位置。
*   `RET`：返回。

### 常用寄存器

*   **通用寄存器**：AX, BX, CX, DX, SI, DI, BP, SP, R8-R15。
*   **特殊寄存器**：IP（指令指针），FLAGS（标志寄存器）。

### 栈帧布局

在 Go 汇编中，栈帧布局对于函数调用和参数传递至关重要。栈帧通常包括：

1.  返回地址。
2.  保存的寄存器。
3.  本地变量。
4.  参数。

### 调试和优化

1.  **调试**：可以使用 `gdb` 或者 `delve` 等调试器。
2.  **优化**：通过了解 CPU 架构和指令集，可以手工优化一些性能关键的代码路径。

### 参考资料

*   [Go 官方文档中的汇编部分](https://golang.org/doc/asm)
*   [Go 汇编的官方示例](https://github.com/golang/go/tree/master/src/runtime/internal/sys)

通过理解这些基本概念和示例，你可以开始在 Go 代码中使用汇编来提高性能或实现特定的低级功能。

指令
--

在 Go 汇编中，常用指令与标准汇编指令相似，但由于 Go 汇编采用了 Plan 9 汇编语法，某些指令和使用方法可能与传统的 AT&T 或 Intel 语法略有不同。下面是一些常用的 Go 汇编指令及其用途：

### 数据传输指令

*   **MOVQ src, dst**: 移动 64 位数据。
*   **MOVL src, dst**: 移动 32 位数据。
*   **MOVW src, dst**: 移动 16 位数据。
*   **MOVB src, dst**: 移动 8 位数据。

示例：

```assembly
MOVQ AX, BX   // 将 AX 寄存器的值移动到 BX 寄存器
MOVQ $10, AX  // 将立即数 10 移动到 AX 寄存器
```

### 算术指令

*   **ADDQ src, dst**: 将 64 位的 src 加到 dst。
*   **ADDL src, dst**: 将 32 位的 src 加到 dst。
*   **SUBQ src, dst**: 将 64 位的 src 从 dst 中减去。
*   **SUBL src, dst**: 将 32 位的 src 从 dst 中减去。
*   **MULQ src**: 64 位无符号乘法，将结果存放在 AX。
*   **IMULQ src**: 64 位有符号乘法，将结果存放在 AX。
*   **DIVQ src**: 64 位无符号除法，商存放在 AX，余数存放在 DX。
*   **IDIVQ src**: 64 位有符号除法，商存放在 AX，余数存放在 DX。

示例：

```assembly
ADDQ AX, BX   // 将 AX 和 BX 的值相加，结果存放在 BX
SUBQ $5, AX   // 将 AX 中的值减去 5，结果存放在 AX
```

### 逻辑指令

*   **ANDQ src, dst**: 进行 64 位按位与操作。
*   **ORQ src, dst**: 进行 64 位按位或操作。
*   **XORQ src, dst**: 进行 64 位按位异或操作。
*   **NOTQ dst**: 对 64 位的 dst 进行按位取反操作。

示例：

```assembly
ANDQ AX, BX   // 对 AX 和 BX 进行按位与操作，结果存放在 BX
XORQ $0x1, AX // 对 AX 进行按位异或操作，结果存放在 AX
```

### 移位指令

*   **SHLQ count, dst**: 将 64 位的 dst 左移 count 位。
*   **SHRQ count, dst**: 将 64 位的 dst 右移 count 位。
*   **SARQ count, dst**: 将 64 位的 dst 算术右移 count 位。

示例：

```assembly
SHLQ $2, AX  // 将 AX 中的值左移 2 位
SHRQ $3, BX  // 将 BX 中的值右移 3 位
```

### 流程控制指令

*   **JMP label**: 无条件跳转到指定标签。
*   **JE label**: 如果等于，跳转到指定标签。
*   **JNE label**: 如果不等于，跳转到指定标签。
*   **JG label**: 如果大于，跳转到指定标签。
*   **JL label**: 如果小于，跳转到指定标签。
*   **JGE label**: 如果大于等于，跳转到指定标签。
*   **JLE label**: 如果小于等于，跳转到指定标签。
*   **CALL target**: 调用函数。
*   **RET**: 返回。

示例：

```assembly
CMPQ AX, BX  // 比较 AX 和 BX
JE label     // 如果 AX == BX，跳转到 label
JMP next     // 无条件跳转到 next

label:
    // 代码块
next:
    // 代码块
```

### 比较指令

*   **CMPQ src, dst**: 比较 64 位的 src 和 dst。
*   **CMPL src, dst**: 比较 32 位的 src 和 dst。
*   **TESTQ src, dst**: 对 64 位的 src 和 dst 进行按位与操作并设置条件码。
*   **TESTL src, dst**: 对 32 位的 src 和 dst 进行按位与操作并设置条件码。

示例：

```assembly
CMPQ AX, BX  // 比较 AX 和 BX
JE label     // 如果 AX == BX，跳转到 label
TESTQ AX, AX // 测试 AX 是否为零
JZ label     // 如果 AX 为零，跳转到 label
```

### 函数调用和返回

*   **CALL target**: 调用目标函数。
*   **RET**: 从函数返回。

示例：

```assembly
CALL ·SomeFunction(SB)  // 调用 Go 函数 SomeFunction
RET                     // 从当前函数返回
```

### 寄存器说明

*   **AX, BX, CX, DX**: 通用寄存器。
*   **SI, DI**: 源索引和目标索引寄存器。
*   **SP**: 栈指针。
*   **BP**: 基指针。
*   **R8-R15**: 额外的通用寄存器。

### 特殊指令

*   **LEAQ src, dst**: 计算内存地址，将结果存入 dst。
*   **NOP**: 空操作，不执行任何操作。

示例：

```assembly
LEAQ 8(SP), AX  // 计算 SP+8 的地址，将结果存入 AX
NOP             // 执行空操作
```

### 汇编函数示例

以下是一个完整的汇编函数示例，该函数计算两个整数的和：

Go 代码：

```go
package main

func Add(a, b int) int

func main() {
    result := Add(10, 20)
    println(result) // 输出 30
}
```

汇编代码（`add_amd64.s`）：

```assembly
TEXT ·Add(SB), NOSPLIT, $0-24
    MOVQ a+0(FP), AX  // 将第一个参数 a 移动到 AX
    MOVQ b+8(FP), BX  // 将第二个参数 b 移动到 BX
    ADDQ BX, AX       // 将 BX 加到 AX 上
    MOVQ AX, ret+16(FP) // 将结果存放到返回值
    RET               // 返回
```

这些常用指令和示例应该可以帮助你在 Go 汇编中编写高效的代码。了解这些指令的使用方法和语法规则是掌握 Go 汇编编程的基础。