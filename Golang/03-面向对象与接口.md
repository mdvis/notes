# 面向对象
method

* * *

### 声明

func (r ReceiverType) funcName (paramters) (result) 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这 种类型上，即相当于为这种类型定义了一个独占的方法。

*   可以为当前包内除了接口和指针以外的任何类型定义方法；在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样
*   如果方法内不引用实例，可省略参数名，仅保留类型

```go
type N int

func (n N)toString()string{
    return fmt.Printf(n)
}

func (N)test(){
    fmt.Printf("hi")
}
```

reveiver 叫做方法的接收器，早期的面向对象语言留下的遗产将 调用一个方法称为“向一个对象发送消息 在Go语言中，我们并不会像其它语言那样用this或者self作为接收器;我们可以任意的选择接收器的名字。==由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错 的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。== p.Distance 这种表达式叫做选择器，选择合适的对应 p 的 Distance 方法来执行

```go
package main
import (
    "fmt"
)
const (
    WHITE = iota
    BLACK
    BLUE
    RED
    YELLOW
)
type Color byte
type Box struct {
    width,height,depth float64
    color Color
}
type BoxList []Box
func (b Box) Volume() float64 {
    return b.width * b.height * b.depth
}
func (b *Box) SetColor(c Color){
    b.color = c
}
func (bl BoxList) BiggestsColor() Color {
    v := 0.00
    k := Color(WHITE)
    for _,b := range bl {
        if b.Volume() > v {
            v = b.Volume()
            k = b.color
        }
    }
    return k
}
func (c Color) String() string {
    strings := []string{ "WHITE", "BLACK", "BLUE", "RED", "YELLOW" }
    return strings[c]
}
func main(){...}
```

### 基于指针对象的方法

当调用一个函数时，会对其==每一个参数值进行拷贝==，如果一个函数需要==更新一个变量==，或者函数的其中一个参数实在太大我们希望能够==避免进行这种默认的拷贝==，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个==接受者变量本身比较大时==，我们就==可以用其指针而不是对象==来声明方法

```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
// 方法名为 (*Point).ScaleBy,必须要有(),否则可能会被理解成*(Point.ScaleBy)
```

\==在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方 法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。==

*   只有类型`(Point)`和指向他们的指针`(*Point)`，才是可能会出现在接收器声明里的两种接收器。
*   此 外，为了避免歧义，在声明方法时，如果一个==类型名本身是一个指针==的话，是不允许其出现在接收器中的 方法可使用实例值或指针调用方法，编译器会根据方法 reveiver 类型自动在基础类型和指针类型间转换 对象是否特别大不适合拷贝，内存地址指针适合拷贝

#### nil 也是一个合法的接收器类型

接收器对象值为零值，零值是 nil 是，接收器的类型就是 nil,当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是 很有必要的

```go
type IntList struct {
    valut int
    Tail *IntList
}
func (list *IntList)Sum()int{
if list == nil {
return 0
}
return list.Value + list.Tail.Sum()
}
```

#### 通过嵌入结构体来扩展类型

```go
import "image/color"

type Point struct{ X, Y float64 }

type ColoredPoint struct { 
Point
Color color.RGBA
}
```

```

type ColoredPoint struct {

Point

Color color.RGBA

}

type ColoredPoint struct {

*Point

Color color.RGBA

}

type ColoredPoint struct {

Point

color.RGBA

}
```

如果选择器有二义性的话编译器会报错，比如你在同一级里 有两个同名的方法。 方法只能在命名类型(像Point)或者指向类型的指针上定义，内嵌使得我们给匿名 struct类型来定义方法也有了手段

#### 方法值和方法表达式

p.Distance叫作“选择器”，选择器会返回一个方法"值"­>一个将方法 (Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用;即 调用时不需要指定接收器(译注:因为已经在前文中指定过了)，只要传入函数的参数即可 当T是一个类型时，方法表达式可能会写作T.f或者(\*T).f，会返回一个函数"值"，这种函数会将其第 一个参数用作接收器，所以可以用通常(译注:不写选择器)的方式来对其进行调用

```

p := Point{1, 2}

distanceFromP := p.Distance // 方法值

distanceFromP(q)

Distance:=Point.Distance //方法表达式

Distance(p,q)
```

#### 封装

一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。 Go语言只有一种控制可见性的手段:大写首字母的标识符会从定义它们的包中被导出，小写字母 的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封 装一个对象，我们必须将其定义为一个struct。

封装有三方面优点

1.  调用方不能直接修改对象的变量值，只需关注少量语句且只要弄懂少量变量的可能的值即可
2.  隐藏实现细节，可以防止调用方依赖那些可能变化的具体实现，这样使包设计者在不破坏对外api的情况下得到更大的自由
3.  阻止了外部调用方对对象内部的值任意的进行修改

```go
var a N
p:=&a
a.value()
p.value()
```

选择receiver类型参考

*   要修改实例状态， 用\*T
*   无需修改状态的小对象或固定值，建议用T
*   大对象建议用\*T，以减少复制成本
*   引用类型、字符串、函数等指针包装对象，直接用T
*   若包含Mutex等同步字段，用\*T，避免因复制造成锁操作无效
*   其他无法确定的情况，都用\*T

### 匿名字段

可以像访问匿名字段成员那样调用其方法，由编译器负责查找

```go
type data struct {
    sync.Mutex
}
d:=data{}
d.Lock() // 会处理为 sync.(*mutex).Lock()
```

可以访问匿名成员及方法但是他们却不属于继承关系

### 方法集

类型有一个与之相关联的方法集，这决定类型是否实现了某个接口。可以使用反射检测这些规则

*   类型 T 方法包含所有 receiver T 方法
*   类型 \*T 方法集包含所有 receiver T + \*T 方法
*   匿名嵌入 S，T 方法集包含所有 receiver S 方法
*   匿名嵌入 \*S，T 方法集包含所有 receiver S + \*S 方法
*   匿名嵌入 S 或 \*S，\*T 方法集包含所有 receiver S + \*S 方法

方法集仅影响接口实现和方法表达式转换，与通过实例指针调用方法无关。实例并不使用方法集，而直接调用。匿名字段就是为方法集准备的。方法和实例以匿名嵌入方式组合到一起共同实现对外接口。

### 表达式

方法根据引用方式不同，可分为expression和value两种状态。

#### Method Expression

通过类型引用的 method expression 会被还原为普通函数样式，receiver 是第一参数，调用时需显示传参。类型可以是T或\*T，只要目标方法存在于该类型方法集中即可

```go
type N int

func (n N)test(){}

f:=N.test
f(n)
f:=(*N).test
f(&n)

(*N).test(&n)
```

### Method Value

基于实例或指针引用的method value，参数签名不会改变，依旧按正常方式调用。**但当 method value 被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需要的 receiver 对象，与其绑定，以便在稍后执行时，能隐式传入 receiver 对象。**

```go
type N int

func (n N) test { }

var n N = 10
p:=&n

n++
f1:=n.test // 复制n 11

n++
f2:=p.test // 复制*p 12

n++

f1() // 11
f2() // 12
```

编译器会为 method value 生成一个包装函数，实现间接调用。至于receiver复制，和闭包的实现方法基本相同，打包成funcvval，经由DX寄存器传递。当method value作为参数时，会复制含receiver在内的整个method value

```go
func call(m func()){
    m()
}

var n N =10
p:=&n

print p n // 10

n++
call(n.test) // 11

n++
call(p.test) // 12
```

```go
type N int

// receiver 指针类型
func (n *N) test {
print n *n
}

var n N = 10
p:=&n

n++
f1:=n.test

n++
f2:=p.test

n++
print p n // 13

f1() // 13
f2() // 11
```# 接口
接口是一组 method 的组合，用来定义对象的一组行为 接口类型是对其它类型行为的抽象和概括;因为接口类型不会和特定的实现细节绑定在一起，通过 这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型;简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义;当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。

接口约定

* * *

接口类型是一种抽象类型，他不会暴露它所代表的对象的内部值的结构和这个对象支持的基础操作的集合

接口类型

* * *

接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。 io.Writer 类型是用的最广泛的接口之一，因为它提供了所有的类型写入bytes的抽象，包括文件类 型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。 io.Reader 可以代表任意可以读取bytes的类型 io.Closer 可以是任意可以关闭的值，例如一 个文件或是网络链接。

实现接口的条件

* * *

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。 接口指定的规则非常简单:表达一个类型属于某个接口只要这个类型实现这个接口,这个规则甚至适用于等式右边本身也是一个接口类型

```go
var w io.Writer
w = os.Stdout  // has Write method
w = new(bytes.Buffer) // has Write method
w = time.Second // error: lacks Write method

var rwc io.ReaderWriterCloser
rwc = os.Stdout // *os.File had Read, Write, Close method
rwc = new(bytes.Buffer) // error: lacks Close Method

w = rwc
rwc = w // error: lacks Close method
```

对于每一个命名过的具体类型 T；它一些方法的接收者是类型 T 本身然而另一些则是一个 T 的指针。在 T 类型的参数上调用一个 `*T` 的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了他的地址。这仅仅是一个语法糖：T 类型的值不拥有所有 `*T` 指针的方法，那这样他就可能只实现更少的接口。 interface{}类型，它没有任何方法，被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。 对于创建的一个interface{}值持有一个boolean，float，string，map，pointer，或者任意其它的类 型;我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法。

flag.Value 接口

* * *

定义
--

接口代表一种契约，是多个方法声明的集合。有些动态语言也被称作协议。

*   需要共同遵守的实现约定的规则，无需知道对方身份协作
*   实现的是做什么，而不是怎么做，谁来做
*   解除类型依赖
*   有助于减少用户可视方法
*   屏蔽实现细节
*   会有运行期开销
*   包内，货值不频繁变化的内部模块并不需要抽象接口强行分离
*   最常见是对包外提供访问，或预留拓展空间
*   无需显示声明，只要包含接口声明全部方法即视为实现
*   可以先实现类型，后抽象所需接口（重构时，模块拆分时等）

```go
// 接口也是一种结构
// 不能有字段
// 不能定义自己的方法
// 只能声明方法，不能实现
// 可嵌入其他接口类型
type iface struct {
    tab *itab
    data unsafe.Pointer
}
```

*   通常以er做名称后缀
*   方法名是声名组成部分
*   参数名可不同或省略

```go
type tester interface {
    test()
    string()string

    type d strict{} 

    func (*data)test(){} // 只有指针才有test方法
    func (data)string()string{return ""}

    var d data
    var t tester = &d

    t = d // error
    t = &d
}
```

执行机制

* * *

接口使用一个名为itab的结构存储运行期所需要的相关类型信息。

```go
type iface struct {
    tab *itab // 类型信息
    data unsafe.Pointer // 实际对象指针
}

type itab struct {
    inter *interfacetype // 接口类型
    _type *_type // 实际对象类型
    fun [1]uintptr // 实际对象方法地址
}
```

将对象赋值给接口变量时，会复制该对象。无法修改接口存储的复制品，因为他是unaddressagle的 接口内部两个指针（itab，data)都为nil时，接口才等于nil。再返回错误信息时容易出问题，应该明确返回nil

类型转换

* * *

类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型。 使用ok-idiom模式，几遍转换失败也不会引发panic。还可用switch语句在多种类型间做出推断匹配，这样空接口皆有更多发挥空间。

技巧
--

*   让编译器检查，确保类型实现了指定接口

```go
var _ InterfaceName = struct{}
```

*   定义函数类型，让相同签名的函数自动实现某个接口

```go
type FuncString func()string

func (f FuncString) String()string {
    return f()
}

var t fmt.Stringer = FuncString(
    func()string{
        return ""
    }
)
```

接口机理

* * *

### 类型赋值给接口

接口包含的方法列表是类型包含方法的子集

### 接口查询

接口查询即接口方法查询，类型实现了接口所有方法。就认为类型实现了接口。

### 接口赋值

接口查询的一种优化

```go
var a interface{} = 1

a.(int)
a.(string)
```

interface 变量存储的类型

* * *

interface 里的变量可以是任意类型的数值（实现了 interface），如何知道变量实际保存的是哪个类型的对象

*   Comma-ok 断言 `value, ok = element.(T)` value 是变量的值，ok 是一个 bool 类型，element 是 interface 变量，T 是断言类型
*   switch 测试

```go
type Element interface{}
type List []Element

type Person struct {
    name string
    age int
}

func (p Person) String() string { }
list := make(List, 3)
list[0] = 1
list[1] = "Hello"
list[2] = Person{"Dennis",8}

for i,v := range list {
    if val,ok := v.(int);ok{}
    else if val,ok := v.(string);ok{}
    else if val,ok := v.(Person);ok{}
    else{}
}


for i,v := range list {
    switch val:=v.(type){
        case int:
        case string:
        case Person:
        default:
    }
}
```

嵌入 interface

* * *

```go
// sort package
type Interface interface {
    Len() int
    Less(i,j int) bool
}

// heap package
type Interface interface {
    sort.Interface
    Push(x interface{}) interface{}
}
```

```go
type inter1 interface{}
type inter2 interface{}
type inter3 interface{
    inter1
    inter2
}
```

```go
package main
import (
    "fmt"
)
type Human struct {
    name string
    age int
    phone string
}
type Student struct {
    Human
    school string
    loan float32
}
type Employee struct {
    Human
    company string
    money float32
}
func (h Human) SayHi(){ }
func (h Human) Sing(lyrics string){}
func (e Employee) SayHi(){}

type Men interface {
    SayHi()
    Sing(lyrics string)
}

mike := Student{Human{"",34,""},"",34.4}
sam:= Employee{Human{"",43,""},"",3.44}

ls := make([]Men,2)
ls[0], ls[1] := mike, sam
```

反射
--

1.  首先把值转换为 reflect 对象，根据情况选择 reflect.Type 或 reflect.Value

```go
t := reflect.TypeOf(i) // 得到类型的元数据
v := reflect.ValueOf(i) // 得到实际值
```

1.  将 reflect 对象转化成相应的值，可以返回相应的类型和数值

```go
tag := t.Elem().Field(0).Tag
name := v.Elem().Field(0).String()
```

1.  反射的字段必须是可修改的

反射就是动态运行时的状态 Go语言提供了一种机制，在编译时不知道类型的情况下，可更新变量、在运行时查看 值、调用方法以及直接对它们的布局进行操作，这种机制称为反射(reflection)

*   在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作
*   不需要在编译时就知道这些变量的具体类型
*   可以让我们将类型本身作为第一类的值类型处理(把类型当作头等值)

why

* * *

我们需要一个有能力==统一处理各种值类型==的函数

*   处理的多种类型无法共享同一个接口
*   处理的类型布局未知
*   处理的类型在设计函数时还不存在
*   以上三条同时存在

reflect.Type 和 reflect.Value

* * *

```go
func TypeOf(i interface{}) reflect.Type
func ValueOf(i interface{}) reflect.Value
```

*   reflect 包定义两个重要类型，Type 和 Value。
*   Type 和 Value 接口均满足 `fmt.Stringer` 接口
*   一个 Type 表示一个 Go 类型，是一个接口，有一系列用来区分类型及检查他们组成部分的方法
*   reflect.TypeOf(interface{}) 接受任意类型，并返回 reflect.Type 形式的动态类型，reflect.TypeOf 总是返回具体类型

1.  反射能在运行期探知对象的类型信息和内存结构，一定程度上弥补了静态语言在动态行为上的不足。
2.  反射还是实现元编程的重要手段。
3.  Go对象头部并没有类型指针，通过其自身是无法在运行期获知任何类型相关信息的。
4.  反射操作所需的全部信息都源自接口变量。接口变量除存储自身类型外，还会保存实际对象的类型数据。 对所有接口进行反射都可以得到一个包含Type和Value的信息结构。Type表达的是被反射的这个变量本身的类型信息，Value表达的是变量实例本身的信息

```go
// switch 类型分支
switch x.(type) {
case type1:
  ...
case type2:
  ...
default:
  ...
}
```

```go
// 将一个具体的值转为接口类型会有一个隐式的接口转换操作
// 它会创建一个包含两个信息的接口值: 
// 操作数的动态类型(这里是int)和它的动态的值(这里是3)
t := reflect.TypeOf(3)
t.String() // "int"
t // "int"
```

```go
// reflect.TypeOf 总是返回具体类型
// io.Writer 是 interface，os.File 是类型
var w io.Writer = os.Stdout
reflect.TypeOf(w) // "*os.File"
```

*   一个 Value 可以装载任意类型的值
*   reflect.ValueOf(interface{}) 返回一个装载其动态值的 reflect.Value
*   reflect.Value 可以持有一个接口值
*   除非 Value 持有的是字符串, 否 则 String 方法只返回其类型. 而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理.
*   对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type
*   reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法. 它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值

```go
v := reflect.ValueOf(3) // a flect.Value
fmt.Println(v) // "3"  
fmt.Printf("%v\n", v) // "3"  
fmt.Println(v.String()) // NOTE: "<int Value>"

v.Type() // a reflect.Type
```

```go
type order struct {
    ordID int
    customID int
}

o:=order{456,56}

reflect.TypeOf(o) // main.order
reflect.ValueOf(o) // {456 56}
```

```go
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface()  // an interface{}
i := x.(int) // an int
fmt.Printf("%d\n", i) // "3"
```

reflect.Kind 和 reflect.Name

* * *

*   reflect.Type
    *   reflect.Type.Kind`func Kind() reflect.Kind`
    *   reflect.Type.Name`func Name() string` 这两个反射入口函数，会将任何传入的对象转换为接口类型。面对类型时，需要区分Type和Kind。前者表示真实类型（静态类型），后者表示其基础结构（底层类型）类别

### 理解反射的类型（Type）与种类（Kind）

在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。

#### 1) 反射种类（Kind）的定义

Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。 Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。 type A struct{} 定义的结构体属于 Struct 种类，\*A 属于 Ptr。

#### 2) 从类型对象中获取类型名称和种类

Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。 类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。

```go
t:=reflect.TypeOf(o) // main.orider
t.Kind() // struct
t.Name() // orider
```

reflect.NumField 和 reflect.Field

* * *

*   reflect.Value
    *   reflect.Value.NumField`func NumField() int`
    *   reflect.Value.Field`func Field(n int) reflect.StructField` `NumField()`方法返回结构中的字段数，`Field(i int)`方法返回字段 `i` 的 `reflect.Value`。 NumField 只能用于结构体，用前判断reflect.ValueOf(o).Kind() === reflect.Struct

```go
v:=reflect.ValueOf(o) // {456 56}
v.NumField() // 2
v.Field(0) // 456
v.Field(1) // 56
```

reflect.Int 和 reflect.String

* * *

*   reflect.ValueOf
    *   reflect.Value.Int `func Int() int64`
    *   reflect.Value.String `func String() string` 构造复合类型

```go
reflect.ArrayOf(10, reflect.TypeOf(byte(0)))
reflect.MapOf(relect.TypeOf(""),reflect.TypeOf(0))
```

*   reflect.ArrayOf
*   reflect.MapOf
*   reflect.TypeOf(&n).Elem // 返回指针、数组、切片、字典（值）或通道**的**基类型 获取结构体指针的基类型后，才能遍历他的字段。
*   reflect.Ptr
*   reflect.TypeOf().NumField
*   reflect.TypeOf().Field
*   reflect.TypeOf().Field().Type
*   reflect.TypeOf().Field().Offset
*   reflect.TypeOf().Field().Name
*   reflect.TypeOf().Field().Type.NumberField
*   reflect.TypeOf().Field().Type.Field
*   reflect.TypeOf().Field().Anonymoust
*   Reflect.Ptr
*   reflect.TypeOf().FieldByName
*   reflect.Typeof().FieldByIndex 匿名字段可用多级索引（按定义顺序）直接访问。 相对于reflect而言，当前包和外包都是“外包”，可用反射提取struct tag，还能自动分解。其常用于ORM映射，或数据格式验证 辅助判断方法Implements、ConvertibleTo、AssignableTo都是运行期进行动态调用和赋值所必需的。
*   reflect.TypeOf().Implements
*   reflect.TypeOf().ConvertibleTo
*   reflect.TypeOf().AssignableTo

值
-

Value 专注于对象实例数据读写。接口变量会复制对象，且是unaddressable的，所以要修改目标对象，就必须使用指针。

*   reflect.ValueOf().Elem // 传入指针也需要Elem获取目标对象，被接口存储的指针本身是不能寻址和进行设置操作的
*   reflect.ValueOf().CannAddr
*   reflect.ValueOf().CanSet 不能对非导出字段直接进行设置操作，无论是当前包还是外包

```go
type User struct {
    Name string
    code int
}

func main(){
    p:=new(User)
    v:=reflect.ValueOf(p).Elem()

    name:=v.FieldByName("Name")
    code:=v.FieldByName("code")

    fmt.Printf(name.CanAddr(), name.CanSet())
    fmt.Printf(code.CanAddr(), code.CanSet())

    if name.CanSet() {
        name.SetString("Tom")
    }

    if code.CanAddr() {
        *(*int)(unsafe.Pointer(code.UnsafeAddr())) = 100
    }

    fmt.Printf(*p)
}
```

*   Value.Pointer // 返回该字段所保存的地址
*   Value.Int
*   Value.data
*   Value.UnsafeAddr // 返回该字段自身的地址（结构对象地址+偏移量）
*   Value.Interface // 进行类型推断和转换
*   Value.TrySend
*   Value.TryRecv

```go
type user struct{
    Name string
    Age int
}
u:=user{
    "mage",
    60
}

v:=reflect.ValueOf(&u)

p,ok:=v.Interface().(*user)
```

接口有两种nil状态，使用IsNil判断是否为nil

```go
var a interface{}=nil
var b interface()=(*int)(nil)

a==nil
reflect.ValueOf(b).IsNil()
```

方法
--

*   Value.MethodByName
*   Value.MethodByName().Call

```go
type X struct {}

func (X) Test(x,y int) (int,error){
    return x+y, fmt.Errorf("%d",x+y)
}

func main(){
    var a X
    v:=reflect.ValueOf(&a)
    m:=v.MethodByName("Test")

    in:=[]reflect.Value{
        reflect.ValueOf(1),
        reflect.ValueOf(2),
    }

    out:=m.Call(in)
    for _,v:= range out{
        fmt.Println(v)
    }
}
```

变参使用CallSlice更方便

```go
type X struct {}

func (X) Format(s string, a...interface{})string{
    return fmt.Sprintf(s,a...)
}

func main(){
    var a X
    v:=reflect.ValueOf(&a)
    m:=v.MethodByName("Format")

    out:=m.Call([]reflect.Value{
        reflect.ValueOf("%d"),
        reflect.ValueOf("x"),
        reflect.ValueOf("100"),
    })

    fmt.Println(out)

    out=m.CallSlice([]reflect.Value{
        reflect.ValueOf("%d"),
        reflect.ValueOf([]interface{}{"x",100})
    })
}
```

构建
--

*   make
*   new

性能
--

反射在带来“方便”的同时，也造成了很大的困扰。很多人对反射避之不及，因为它会造成很大的性能损失。需谨慎使用

用法
--

获取类型信息

* * *

```go
var x float64 = 3.4

v.TypeOf() // float64

v:=reflect.ValueOf(x)
v.Kind() == reflect.Float64 // true
v.Float() // 3.4
```

获取值类型

* * *

> 类型 Type 中有个成员函数 CanSet，Go语言中所有的类型都是值类型，即这些变量在传递给函数的时候将发生一次复制。基于这个原则，我们再次看一下下面的语句:

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
v.Set(4,1)
```

> 首先要理清 v 和 x 的关系。在调用 ValueOf() 的地方，需要注意到 x 将会产生一个副本，因此 ValueOf() 内部对 x 的操作其实都是对着 x 的一个副本。假如 v 允许调用 Set()，那么我们也可以想象出，被修改的将是这个 x 的副本，而不是 x 本身。如果允许这样的行为，那么执行结果将会非常困惑。调用明明成功了，为 什么 x 的值还是原来的呢?为了解决这个问题Go语言，引入了可设属性这个概念(Settability)。 如果 CanSet() 返回 false，表示你不应该调用 Set() 和 Set\_Xxx\_() 方法，否则会收到这样的错误: `panic: reflect.Value.SetFloat using unaddressable value`

```go
var x float64 = 3.4
p := reflect.ValueOf(&x)
v := p.Elem()
v.CanSet()
```

对结构的反射操作

* * *

```go
type T struct { 
  A int
  B string
}

t := T{203, "mh203"}
s := reflect.ValueOf(&t).Elem()
typeOfT := s.Type()

for i := 0; i < s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf("%d: %s %s = %v\n", i, typeOfT.Field(i).Name, f.Type(), f.Interface())
}
```# oop
面向对象

* * *

\[toc\]

类型系统

* * *

实际上类型系统才是一门编程语 言的地基，它的地位至关重要

类型系统是指一个语言的类型体系结构。一个典型的类型系统通常包含如下基本内容

*   基础类型，byte，int，bool，float等
*   复合类型，数组，结构体，指针等
*   可以指向任意对象的类型（any类型）
*   值语义和引用语义
*   面向对象，即所有具备面向对象特征（比如成员方法）的类型
*   接口

类型系统描述的是这些内容在一个语言中如何被关联

### 为类型添加方法

go中可以给当前包内任意类型（包括内置类型，但不包括指针类型）添加相应的方法

*   方法施加的目标（也就是对象）显示传递，没有隐藏起来
*   方法施加的目标（也就是对象）不需要非得是指针，也不用非得叫this

```go
type Integer int

func (s Integer) Less(b Interger) bool { //函数名前面部分相当于python的self，js的this，称作receiver
    return s < b
}

func Less2(s, b Interger) bool { //函数名前面部分相当于python的self，js的this，称作receiver
    return s < b
}

func main(){
    var a Interger = 1
    a.Less(2)  // 面向对象
    Less2(a, 2)  // 面向过程
}
```

### 值语义和引用语义

值语义

*   基本类型，byte，int，bool，float32，float64和string等
*   复合类型，数组，结构体和指针等

数组复制是值复制`b = a`，想要表达引用需要使用指针`b = &a` 这是b的类型是`*[3]int`而不是`[3]int`

*   数组切片：指向数组的一个区间；其本质是一个区间，\[\]T大致可表示为如下，切片内部指向数组指针，所以会改变指向数组元素

```go
type slice struct {
    first *T
    len int
    cap int
}
```

*   map：极其常见的数据结构，提供键值查询能力

map本质是一个字典指针，map\[K\]V大致表现如下

```go
type Map_K_V struct {}
type map[K]V struct {
    impl *Map_K_V
}

// 基于指针可以自定义一个引用

type IntegerRef struct {
    impl *int
}
```

*   channel：执行体（goroutine）间的通信设施

channel和map类似，本质上是一个指针，将他们设计为引用类型而不是统一的值类型的原因是，完整复制一个channel或map并不是常规需求

*   接口：对一组满足某个契约的类型的抽象

接口具备引用语义是因为内部维持两个指针，如下，接口在go中非常重要

```go
type interface struct {
    data *void
    itab *Itab
}
```

这四个看起来像引用类型，实际并不影响其类型被看做值语义

### 结构体

go语言放弃了包括继承在内的大量面向对象的特性，只保留了组合这个最基础的特性。组合甚至都不算面向对象的特性。组合只是形成复合类型的基础

```go
type Rect struce {
    x, y float64
    width, height float64
}

func (a Rect) Area() float64{
    return a.width * a.height
}
```

初始化

* * *

```go
rect1 := new(Rect)
rect2 := &Rect{}
rect3 := &Rect{0, 0, 100, 100}
rect3 := &Rect{ width: 100, height: 100}
```

未进行显式初始化的变量都会被初始化为该类型的零值，例如bool类型的零 值为false，int类型的零值为0，string类型的零值为空字符串。

没有构造函数的概念， 对象的创建通常交由一个全局的创建函数来完成， 以 NewXXX来命名，表示“构造函数”

```go
func NewRect(x, y, width, height float64) *Rect {
    return &Rect {x,y,width,height}
}
```

匿名组合

* * *

确切地说，Go语言也提供了继承，但是采用了组合的文法，所以我们将其称为匿名组合

```go
type Base struct {
    Name string
}

func (base *Base) Foo(){}
func (base *Base) Bar(){}

type Foo struct {
    Base
}

// 使Foo”继承“并改写了Bar方法
func (foo *Foo) Bar() {
    foo.Base.Bar()
    ...
}
// 调用foo.Foo和foo.Base.Foo效果一致
// 匿名组合类型相当于以其类型名称（去掉包名部分） 作为成员变量的名字
func (foo *Foo) Bar() {
    ...
    foo.Base.Bar()
}
// 属性顺序对应这内存布局（位置前后）
```

以指针方式从一个类型”派生“

```go
type Foo struct {
    *Base
    ...
}
```

这时创建实例的时候，需要外部提供一个Base类实例的指针（类似c++虚基类）

```go
type Job struct {
    Command string
    *log.Logger
}
```

在合适的赋值后，我们在Job类型的所有成员方法中可以很舒适地借用所有log.Logger提 供的方法

```go
func (job *Job) start(){
    job.Log("starting")
    ...
    job.Log('end')
}
```

可见性

* * *

要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母 开头；Go语言中符号的可访问性是包一级的而不是类型一级的

接口
--

接口采用duck type方式，无需显示声明。

接口在Go语言有着至关重要的地位。如果说goroutine和channel 是支撑起Go语言的并发模型 的基石，让Go语言在如今集群化与多核化的时代成为一道极为亮丽的风景，那么接口是Go语言 整个类型系统的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度。

### 其他语言接口（java，c）

*   在Go语言出现之前，接口主要作为不同组件之间的契约存在。对契约的实现是强制的，你 必须声明你的确实现了该接口。为了实现一个接口，你需要从该接口继承。
*   这类接口我们称为侵入式接口。“侵入式”的主要表现在于实现类需要明确声明自己实现了 某个接口。

### 非侵入式接口

*   一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口

```go
type File struct {}

func (f *File) Read(buf []byte) (n int, err error)
func (f *File) Write(buf []byte) (n int, err error)
func (f *File) Seek(off int64, whence int) (pos int64, err error)
func (f *File) Close() error

type IFile interface {
    Read(buf []byte) (n int, err error)
    Write(buf []byte) (n int, err error)
    Seek(off int64, whence int) (pos int64, err error)
    Close() error
}

type IReader interface { Read(buf []byte) (n int, err error) }

type IWriter interface { Write(buf []byte) (n int, err error) }

type ICloser interface { Close() error }

// 尽管File类并没有从这些接口继承，甚至可以不知道这些接口的存在，但是File类实现了这些接口(有接口要求的所有函数)，可以进行赋值：
var file1 IFile = new(File)
var file2 IReader = new(File)
 var file3 IWriter = new(File)
 var file4 ICloser = new(File)
```

小的文法调整，深远的影响

*   go标准库再也不需要绘制类库的继承树图
*   实现类的时候，只需要关心自己应该提供哪些方法，不需在纠结细粒度问题，接口由使用方按需定义，无需事前规划
*   不用为了实现一个接口而导入一个包，因为多饮用一个外部的包，就意味着更多的耦合，接口有需求方按自身需求定义，使用方无需关心是否有其他模块定义过类似的接口

### 接口赋值

接口赋值分为两种情况：

1.  将对象实例赋值给接口，要求对象实例实现了接口所要求的所有方法
2.  将一个接口赋值给另一个接口

#### 赋值给接口

```go
type Inte int

func (a *Inte) Add(b Inte){}

func (a Inte) Less(b Inte) bool {}
// 会自动生成如下方法
func (a *Inte) Less(b Inte) bool {
    return (*a).Less(b)
}

// 这样Less和Add都在*Inte上
// 所以给如下接口赋值时要使用*Inte(指针)
type LessAdder interface {
    Less(b Inte)bool
    Add(b Inte)
}

var a Inte = 1
var b LessAdder = &a
```

#### 将一个接口赋值给另一个接口

**只要两个接口拥 有相同的方法列表（次序不同不要紧），那么它们就是等同的，可以相互赋值；也可以赋给子集**。

### 接口查询

在Go语言中，对象是否满足某个 接口，通过某个接口查询其他接口，这一切都是完全自动完成的。

```go
var file1 Writer = ...
if file2, ok := file1.(*File); ok {}  // 判断file1接口指向的对象实例是否是*File类型
```

### 类型查询

询问**接口指向的对象实例**的类型

```go
var v1 interface {} = ...
switch v := v1.(type){
case int:
    ...
case string:
    ...
default:
    ...
}
// .(type)只能用于switch语句
```

通常类型查询不常用，更多是个补充需要配合接口使用

利用反射也可以进行类型查询，reflect.TypeOf()

### 接口组合

type Read interface {} type Write interface{} type ReadWrite interface { Reader Write}

### any类型

因为任何对象都满足空接口 interface{}，所以 interface{} 看起来像是可以指向任何对象的 any

函数可以接受任意参数时，会将其声明为interface{}

```go
func Printf(args ...interface){}
```# 结构体
聚合的数据类型，由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。成员可以通过点操作符访问.其成员也是变量,可以直接赋值也可以通过指针访问 结构体成员的顺序也有重要意义，不同顺序就是不同类型；如果结构体成员名字是以大写字母开头的，那么该成员就是导出的;这是Go语言导出规则决定 的。一个结构体可能同时包含导出和未导出的成员k。

*   一个命名为S的结构体类型将不能再包含S类型的成员:因为一个聚合的值不能包含它自身。(该限制同样适应于数组。)
*   S类型的结构体可以包含 `*S` 指针类型的成员，这可以让我们创建递归 的数据结构
*   结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。
*   结构体没有任何成员的话就是空结构体，写作`struct{}`。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些 Go 语言程序员用 map 来模拟 set 数据结构时，用它来代替 map 中布尔类型的 value，只是强调 key 的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们 通常会避免这样的用法。

```go
type Person struct {
    name string
    age int
}

var p Person
p.name = "Astaxie"
p.age = 32

p:=Person{"Astaxie", 32}
p:=Person{name:"Astaxie", age: 32}

seen := make(map[string]struct{})
if _,ok := seen[s];!ok {
    seen[s] = struct{}{}
}
```

### 结构体面值

1.  按成员顺序（要记住成员类型和顺序，成员调整会导致错误，只在定义包内部使用，或者在排列比较规则的小结构体中使用`image.Point{x, y}` `color.RGBA{red, green, blue, alpha}`）
2.  以成员名字加值（常用）

```go
type Point struct {x, Y int}

p := Point{1, 2} // 按成员定义顺序为每个成员指定一个面值
Point{Y:2} // 以成员名字和值来初始化
```

考虑效率，较大结构体通常会用指针方式传入和返回 如果要在函数内部修改结构体成员的话，用指针传入是必须的;因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。

```go
pp := &Point{1, 2}
// 等价
pp := new(Point)
*pp = Point{1, 2}
```

### 结构体比较

*   结构体全部成员可比较结构体就可以比较
*   可比较的结构体类型和其他比较类型一样，可以用于 map 的 key 类型

### 结构体嵌入和匿名成员(匿名字段/嵌入字段)

*   命名结构体包含另一个结构体类型的匿名成员，通过点运算符访问匿名成员链中嵌套的成员
*   声明一个成员的数据类型而不指明成员的名字，这类成员就叫匿名成员
*   匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针

```go
type Point struct { X, Y int}
type Circle struct { 
    Center Point
    Radius int
}
type Wheel struct {
    Circle Circle
    Spokes int
}

var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20

type Circle struct {
    Point // 匿名成员，Point 类型被嵌入到 Circle 结构体
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}

var w Wheel
w.X = 8        // equivalent to w.Circle.Point.X = 8 
w.Y = 8        // equivalent to w.Circle.Point.Y = 8 
w.Radius = 5   // equivalent to w.Circle.Radius = 5
w.Spokes = 20
```

*   右边的注释中给出的显式形式`w.Circle.Point.X`访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法 访问了
*   匿名成员 Circle、Point 都有自己的名字（即命名类型的名字，但这些名字再点操作符中是可选的）
*   结构体的字面值没有简短表示匿名成员的语法
*   匿名成员有隐式名字，所以不能同时包含两个同类型的匿名成员，名称会冲突
*   成员的名字是有其类型隐式决定的，所有匿名成员也有可见性的规则约束
*   任何命名类型都可作为结构体的匿名成员

但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢?

答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访 问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该 类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组 合是Go语言中面向对象编程的核心

```go
// 以下均无法通过
w = Wheel{8, 8, 5, 20}
w = Wheel{X:8, Y:8, Radius:5, Spokes:20}

// 字面值必须遵循形状类型声明时的结构
w = Wheel{Circle{Point{8, 8}, 5}, 20}
w = Wheel{
    Circle: Circle{
        Point: Point{X:8, Y:8},
        Radius: 5,
    },
    Spokes:20
}

fmt.Printf("%#v\n", w)
// Wheel{ Circle: Circle{ Point: Point{X:8, Y:8}, Radius: 5 }, Spokes:20 }
```