# 字符串
Go字符串的字面量形式有两种。 一种是解释型字面表示（interpreted string literal，双引号风格）。 另一种是直白字面表示（raw string literal，反引号风格）。

```text-x-go
"Hello\nworld!\n\"你好世界\""
// 等价
`Hello
world!
"你好世界"`
```

*   一个字符串是一个==不可改变==的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是 用来包含人类可读的文本。
*   文本字符串通常被解释为采用UTF8编码的Unicode码点(rune)序列
*   len 函数返回字节数目（不是 rune 字符数目）
*   s\[i\] 索引操作
*   访问超出字符串索引范围将会导致 panic 异常
*   第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字 节。
*   子字符串操作 `s[i:j]`，小于 i，或大于 j 都会导致 panic
*   `+` 操作符拼接成新字符串
*   字符串可以使用 == 和 `<` 比较，逐个字节比较，比较结果是字符串自然吗的顺序

```text-plain
var s string

s[len(s)] // panic
s[0] = "L" // 字符串不可修改
```

因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此 我们可以将Unicode码点也写到字符串面值中。

字面值

* * *

在一个双引号包含的字符串面值中，可以用以反斜杠 `\` 开头的转义序列插入任意的数据。下面的换 行、回车和制表符等是常见的ASCII控制代码的转义方式:

```text-plain
\a 响铃
\b 退格
\f 换页
\n 换行
\r 回车
\t 制表符
\v 垂直制表符
\' 单引号 (只用在 '\'' 形式的rune符号面值中)
\" 双引号 (只用在 "..." 形式的字符串面值中)
\\ 反斜杠
```

反引号 \`...\` 原生字符串字面值，字面值中没有转义操作；全是字面意思，包含换行退格等，因此可以多行，特殊的地方是为了保证所有平台值一样会删除回车；用于编写正则表达式、html 模板、json 面值、命令提示信息及那些需要扩展到多行的场景

unicode

* * *

unicode 码点对应 rune 整数类型

utf-8

* * *

UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码由Go语言之父Ken Thompson 和Rob Pike共同发明的，现在已经是Unicode的标准。使用 1 到 4 个字节来表示每个 Unicode 码点，ASCII 部分占一个字节，常用部分站两到三个字节。 每个符号编码 后第一个字节的高端bit位用于表示总共有多少编码个字节。如果第一个字节的高端bit为0，则表示 对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一 个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。更大的Unicode码点 也是采用类似的策略处理。 UTF-8就是以8位为单元对UCS进行编码，而UTF-8不使用大尾序和小尾序的形式，每个使用UTF-8存储的字符，除了第一个字节外，其余字节的头两个比特都是以"10"开始，使文字处理器能够较快地找出每个字符的开始位置。

```text-plain
0xxxxxxx                               runes 0‐127 (ASCII)
110xxxxx 10xxxxxx                      128‐2047 (values <128 unused)
1110xxxx 10xxxxxx 10xxxxxx             2048‐65535 (values <2048 unused)
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    65536‐0x10ffff (other values unused)
```

变长的编码无法直接通过索引来访问第 n 个字符，但是 UTF8 编码获得了很多额外的优点。

*   编码紧凑
*   兼容 ASCII
*   可以自动同步
*   前缀编码（对字符集进行编码时要求字符集中任一字符的编码都不是其它字符的编码的前缀）
*   没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。
*   同时 UTF8 编码的顺序和 Unicode 码点的顺序一致，因此可以直接排序 UTF8 编码序列。
*   同时因为没有嵌入的 NUL(0) 字节，可以很好地兼容那些使用 NUL 作为字符串结尾的编程语言。

Go 中的包

* * *

*   unicode
*   unicode/

通过码点输入特殊字符（h 是一个 16 进制数字，一般少用 32bit 形式）

1.  `\uhhhh` 对应 16bit 码点值
2.  `\Uhhhhhh` 对应 32bit 码点值

```text-plain
// 表示相同值
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c"

// rune 字符
'世' '\u4e16' '\U00004e16'
```

对于小于 256 码点值可以写在一个十六进制转义字节中，例如 `'\x41'` 对应字符 `'A'`，但是对于更大的码点则必须使用 `\u` 或 `\U` 转义形式。因此，`'\xe4\xb8\x96'` 并不是一个合法的 rune 字符，虽然这三个字节对应一个有效的UTF8编码的码点。

UTF8 优良设计是的诸多字符串操作都不需要解码操作，不用解码做前后缀包含子串测试等

```text-plain
func HasPrefix(s, prefix string) bool {
return len(s) < len(prefix) && s[:len(prefix)] == prefix
}

func HasSuffix(s, suiffx string) bool {
return len(s) < len(suffix) && s[len(suffix):] == suiffx
}

func Contains(s, substr string) bool {
    for i:=0; i<len(s); i++ {
        if HasPrefix(s[i:], substr){
             return true
        }
    }
    return false
}
```

UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这样的。

```text-plain
// 字符串包含13个字 节，以UTF8形式编码，但是只对应9个Unicode字符

import "unicode/utf8"

s := "Hello, 世界"

fmt.Println(len(s)) // "13"
fmt.Println(utf8.RuneCountInString(s)) // "9"


// DecodeRuneInString函数都返回一个r和长度，r对应字符本身,长度对应r采用UTF8编 码后的编码字节数目
// 此种方法是笨拙的，range 循环处理字符串时会自动隐式解码 UTF8 字符串
// 需要注意的是对于非ASCII，索引更新的步 长将超过1个字节

for i := 0; i < len(s); {

r, size := utf8.DecodeRuneInString(s[i:]) fmt.Printf("%d\t%c\n", i, r)

i += size

}
```

或者我们可以直接调用utf8.RuneCountInString(s)函数。

正如我们前面提到的，文本字符串采用 UTF8 编码只是一种惯例，但是对于循环的真正字符串并不 是一个惯例，这是正确的。如果用于循环的字符串只是一个普通的二进制数据，或者是含有错误编 码的 UTF8 数据，将会发送什么呢?

每一个 UTF8 字符解码，不管是显式地调用 utf8.DecodeRuneInString 解码或是在 range 循环中隐式 地解码，如果遇到一个错误的 UTF8 编码输入，将生成一个特别的 Unicode 字符 `'\uFFFD'`，在印刷中 这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号 `"�"`。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的 UTF8 字符串。

UTF8 字符串作为交换格式是非常方便的，但是在程序内部采用 rune 序列可能更方便，因为 rune 大小一致，支持数组索引和方便切割。

将 `[]rune` 类型转换应用到 UTF8 编码的字符串，将返回字符串编码的 Unicode 码点序列

```text-plain
// "program" in Japanese katakana

s := "プログラム"

fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0" 
r := []rune(s)

fmt.Printf("%x\n", r) // "[30d7 30ed 30b0 30e9 30e0]"
```

(在第一个Printf中的 `% x` 参数用于在每个十六进制数字前插入一个空格。) 如果是将一个 `[]rune` 类型的 Unicode 字符 slice 或数组转为 string，则对它们进行 UTF8 编码:

```text-plain
fmt.Println(string(r)) // "プログラム"
```

将一个整数转型为字符串意思是生成以只包含对应 Unicode 码点字符的 UTF8 字符串:

```text-plain
fmt.Println(string(65)) // "A", not "65" 
fmt.Println(string(0x4eac)) // "京"
```

如果对应码点的字符是无效的，则用 `'\uFFFD'` 无效字符作为替换:

```text-plain
fmt.Println(string(1234567)) // "�"
```

字符串和byte切片

* * *

### 字符串处理包

*   bytes 和 strings 类似，但是针对和字符串有着相同结构的\[\]byte类型
*   strings 字符串的查询、替换、比较、截断、拆分、合并等
*   strconv 提供了布尔型、整型数，浮点数、对应字符串的相互转换，还提供双引号转义相关的转换
*   unicode 提供IsDigit、IsLetter、IsUpper 和 IsLower 等类似功能，用于给字符分类。每个函数有一个单一的 rune 类型的参数，返回布尔值。所有函数都是遵循 Unicode 标准定义的字母、数字、等分类规范

因为字符串 是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将 会更有效

```text-plain
func comma(s string) string { n := len(s)

if n <= 3 { return s

}

return comma(s[:n‐3]) + "," + s[n‐3:] }
```

##### strings

```text-plain
func Contents(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
```

##### bytes

```text-plain
func Contents(s, substr []byte]) bool
func Count(s, sep []byte]) int
func Fields(s []byte]) [][]byte]
func HasPrefix(s, prefix []byte]) bool
func Index(s, sep []byte]) int
func Join(a [][]byte], sep []byte]) []byte]
```

bytes.Buffer 用于字节 slice 的缓存,初始是空的，随着string byte \[\]byte等写入可动态增长，不需要初始化，零值也是有效的

```text-plain
// intsToString is like fmt.Sprint(values) but adds commas.

func intsToString(values []int) string {
    var buf bytes.Buffer 
    buf.WriteByte('[')
    for i, v := range values {
        if i > 0 { buf.WriteString(", ")
    }
    fmt.Fprintf(&buf, "%d", v) }
    buf.WriteByte(']')
    return buf.String() 
}

func main() {
    fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
}
```

当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是 WriteByte方法对于写入类似'\['和'\]'等ASCII字符则会更加有效。

### 字符串和数字转换

#### 整数转字符串

1.  fmt.Sprintf 返回格式化字符串
2.  strconv.Itoa 整数转 ASCII

```text-plain
func Itoa(i int) string
```

*   strconv.FormatInt
*   strconv.FormatUint

```text-plain
func FormatInt(i int64, base int) string
func FormatUint(i uint64, base int) string
```

#### 字符串转整数

*   strconv.Atoi
*   strconv.ParseInt

```text-plain
func Atoi(s string) int
func ParseInt(s string,base int, bitSize int)(i int64, err error)
```

有时会使用 fmt.Scanf 解析输入的字符串和数字，特别是当字符串和数字混合在一起是