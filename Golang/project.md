# project
工程管理

* * *

\[toc\]

命令行工具

* * *

### 基本用法

gotool 可以：

*   代码格式化
*   代码质量分析和修复
*   单元测试与性能测试
*   工程构建
*   代码文档的提取和展示
*   依赖包管理
*   执行其他的包含指令

```bash
go version
go help
```

代码风格

* * *

go 代码规范分两类

1.  由go编译器进行强制的编码规范
2.  由gotool推行的非强制性编码风格建议

### 强制性编码规范

#### 命名

*   任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的用小写
*   使用驼峰命名法，禁止使用下划线命名法

#### 排列

*   左花括号紧跟代码
*   else等紧跟右花括号

### 非强制性编码风格

```go
// 带名称检查单个文件
// 不带名称检查目录下所有*.go
$ go fmt
```

远程import支持

* * *

```go
import (
 "github.com/myteam/exp/crc32"
)

go get github.com/myteam/exp/crc32
```

工程组织

* * *

### GOPATH

定位源码依赖GOPATH

### 目录结构

*   README 简单介绍项目目标和关键的注意事项
*   LICENSE 工程采用的分发协议

标准go语言工程包括：

*   src/ 包含所有源代码，这是个强制规则
*   pkg/ 自动创建
*   bin/ 自动创建

文档管理

* * *

程序包括代码和文档

软件产品包括源代码、可执行程序、文档和服务

文档，单行 // 多行 /\*\*/

*   代码中的注释、函数、接口的输入、输出、功能和参数说明
*   版权说明注释
*   包说明注释
*   函数说明注释
*   遗留问题说明

```go
// 提取文档
go doc <包名>

go doc -http=<PORT> -path=<PATH>
```

文档规则

*   注释需要紧贴在对应的包声明核函数之前，不能有空行
*   注释如果要新奇一个段落，应该用一个空白注释行隔开，因为直接换行书写会被认为是正常的段内折行
*   可以直接使用 // BUG(author): 的方式记录该代码片段中的遗留问题，这些遗留问题也会被抽到文档中

工程构建

* * *

```go
// 生成二进制文件
// 可执行文件放入/bin目录，如果是个包则放入/pkg目录
go build <包名>

// 执行install时，如果没有执行build，会先执行build
go install <包名>
```

跨平台开发

* * *

### 交叉编译

*   linux下可以生成以下目标格式x86 ELF、AMD64 ELF、ARM ELF、x86 PE和AMD64 PE
*   windows下x86 PE和AMD64 PE

可以通过设置GOOS和GOARCH两个环境变量来制定交叉编译的目标格式。

| $GOOS | $GOARCH |
| --- | --- |
| darwin | 386 |
| darwin | amd64 |
| freebsd | 386 |
| freebsd | amd64 |
| linux | 386 |
| linux | amd64 |
| linux | arm |
| windows | 386 |
| windows | amd64 |

### android 支持

android 基于linux所以也可以编译android go

单元测试

* * *

```go
// 单元测试
go test

// 性能测试,加-test.bench参数
go test -text.bench 
```

单元测试源文件命名规则：待测试包下创建\_test结尾的go文件

*   功能测试函数：以 Test 开头，\*testing.T 为单一参数的函数
*   性能测试函数：以 Benchmark 开头，\*testing.T 为单一参数的函数

打包分发

* * *

就目前而言，以二进制方式分发Go包并不是很现实。由于Go语言对于兼容性控制的非常严 格，任何一个版本号的不同都将导致无法链接包。因此，如果你使用Go语言开发了一个库，那 么最合适的库分发方式是直接打包源代码包并进行分发，由使用者自行编译。 当然，可执行文件没有这个问题。因此如果要避免这个包链接的问题，可以考虑如何将核心 功能以二进制的服务器程序形式提供，并辅以开源的客户端SDK。