# Linux 系统管理指南


## Linux 分区建议

# Linux 分区建议
| **目录** | **文件系统** | **作用** | **为什么单独分区** | **推荐大小** |
| --- | --- | --- | --- | --- |
| `/` (根目录) | Ext4/Btrfs | 系统核心文件存储 | 系统的基础分区，必须存在 | 桌面：15-25 GB  <br>服务器：25-50 GB |
| `/boot` | Ext4/Btrfs | 启动加载器和内核文件存储 | 提高启动稳定性，避免其他分区问题影响系统启动 | 500 MB - 1 GB |
| `/boot/efi` | FAT32 | EFI 系统分区，存储 UEFI 引导文件（如 GRUB 的 `grubx64.efi`、系统启动项配置） | 提供 UEFI 引导支持，需使用 FAT32 文件系统（UEFI 的标准） | 300-500 MB |
| `/home` | Ext4/Btrfs | 用户的个人文件和设置存储 | 防止用户数据占满根目录空间，方便重装系统时保护数据 | 根据需求，通常 20 GB 或更大 |
| `/var` | Ext4/Btrfs | 日志文件、缓存文件、邮件队列等存储 | 防止日志或缓存增长过快挤占根分区空间，提升服务器稳定性 | 普通系统：2-5 GB  <br>服务器：按需分配 |
| `/tmp` | Ext4/Btrfs | 临时文件存储 | 防止恶意用户创建大量临时文件导致系统崩溃，可用内存文件系统提高性能 | 桌面：1-2 GB  <br>服务器：5-10 GB |
| `/usr` | Ext4/Btrfs | 用户安装的程序和库文件存储 | 防止程序安装占满根分区空间，可只读挂载提高安全性 | 桌面：15-20 GB  <br>服务器：25-50 GB |
| `/opt` | Ext4/Btrfs | 第三方或自定义安装的软件包存储 | 隔离非标准软件，便于管理和维护 | 5-20 GB 或根据需求调整 |
| `/srv` | Ext4/Btrfs | 服务数据存储（如 Web 服务器或 FTP 服务数据） | 保证服务数据独立，便于备份和管理 | 根据服务需求分配 |
| `/swap` | Swap | 内存不足时的备用空间 | 提高系统稳定性，防止内存耗尽 | 按需分配，**小于 2 GB 内存**：`swap` 等于内存大小的 **2 倍**。**2-8 GB 内存**：`swap` 等于内存大小。**超过 8 GB 内存**：`swap` 通常设置为 **1-2 GB**（或根据实际需求调整）。 |


## Linux 错误码

# Linux 错误码
\[toc\] 退出码（退出状态）可以告诉我们最后一次执行的命令的状态。在命令结束以后，我们可以知道命令是成功完成的还是以错误结束的。

**其基本思想是，程序返回退出代码 `0` 时表示执行成功，没有问题。代码 `1` 或 `0` 以外的任何代码都被视为不成功。** 退出码除了 0 和 1 外还有很多值，我将在本文介绍它们。

### Linux Shell 中的各种退出码

我们来快速了解一下 Linux Shell 中的主要退出码：

| 退出码 | 解释  |
| --- | --- |
| `0` | 命令成功执行 |
| `1` | 通用错误代码 |
| `2` | 命令（或参数）使用不当 |
| `126` | 权限被拒绝（或）无法执行 |
| `127` | 未找到命令，或 `PATH` 错误 |
| `128+n` | 命令被信号从外部终止，或遇到致命错误 |
| `130` | 通过 `Ctrl+C` 或 `SIGINT` 终止（_终止代码 2 或键盘中断_） |
| `143` | 通过 `SIGTERM` 终止（_默认终止_） |
| `255/*` | 退出码超过了 0-255 的范围，因此重新计算（LCTT 译注：超过 255 后，用退出码对 256 取模） |

> 📋 `130`（`SIGINT` 或 `^C`）和 `143`（`SIGTERM`）等终止信号是非常典型的，它们属于 `128+n` 信号，其中 `n` 代表终止码。

在简单了解了退出码之后，我们来看看它们的用法。

### 获取退出码

前一个命令执行的退出码存储在特殊变量 `$?` 中。你可以通过运行以下命令来获取：

```
echo $?
```

我们在所有演示中都将使用它来获取退出代码。 请注意，`exit` 命令支持以带着前一条命令相同的退出码退出。

### 退出码 0

退出码 `0` 表示命令执行无误，这是完成命令的理想状态。 例如，我们运行这样一条基本命令

```
neofetch 

echo $?
```

这个退出码 `0` 表示特定命令已成功执行，仅此而已。让我们再演示几个例子。 你可以尝试终止一个进程；它也会返回代码 `0`。

```
pkill lxappearance
```

查看文件内容也会返回退出码 0，这**仅**意味着 `cat` 命令执行成功。

### 退出码 1

退出码 `1` 也很常见。它通常表示命令以一般错误结束。 例如，在没有 sudo 权限的情况下使用软件包管理器，就会返回代码 `1`。在 Arch Linux 中，如果我运行下面的命令：

```
pacman -Sy
```

它会返回 `1`， 表示上一条命令运行出错。

> 📋 如果你在基于 Ubuntu 的发行版中尝试这样做（不使用 `sudo` 执行 `apt update`），运行后会得到错误码 `100`，表示你是在没有权限的情况下运行 `apt`。`100` 不是标准错误码，而是 `apt` 特有的错误码。

虽然这是一般的理解，但我们也可以将其解释为 “不被允许的操作”。 除以 `0` 等操作也会返回错误码 `1`。

### 退出码 2

这个退出码出现在当执行的命令有语法错误时。滥用命令参数也会导致此错误。 一般来说，它表示由于使用不当，命令无法执行。 例如，我在一个本应只有一个连字符的选项上添加了两个连字符，那么此时会出现退出码 2。

```
grep --z file.txt
```

当权限被拒绝时，比如访问 `/root` 文件夹，就会出现错误码 `2`。

### 退出码 126

126 是一个特殊的退出码，它用于表示命令或脚本因权限错误而未被执行。 当你尝试执行没有执行权限的 Shell 脚本时，就会出现这个错误。 请注意，该退出码只出现在没有足够权限的脚本或命令的“_执行_”中，这与一般的**权限被拒绝**错误不同。 因此，不要把它与你之前看到的退出码为 `2` 的示例混淆。在那个示例中，运行的是 `ls` 命令，权限问题出自它试图执行的目录。而本例中权限问题来自脚本本身。

### 退出码 127

这是另一个常见的退出码。退出码 `127` 指的是“未找到命令”。它通常发生在执行的命令有错别字或所需的可执行文件不在 `$PATH` 变量中时。 例如，当我尝试执行一个不带路径的脚本时，经常会看到这个错误。 当你想运行的可执行文件不在 `$PATH` 变量中时，也会出现退出码 `127`。你可以通过 在 PATH 变量中添加命令的目录来纠正这种情况。 当你输入不存在的命令时，也会得到这样的退出码。

### 退出码 128+n 系列

当应用程序或命令因致命错误而终止或执行失败时，将产生 128 系列退出码（`128+n`），其中 `n` 为信号编号。 `n` 包括所有类型的终止代码，如 `SIGTERM`、`SIGKILL` 等。

#### 退出码 130 或 SIGINT

在通过终止信号 `2` 或按下 `Ctrl+C` 中断进程时，会发出 `SIGINT`（键盘中断信号）。 因为终止信号是 `2`，所以我们得到的退出码是 `130`（128+2）。下面的视频演示了 `lxappearance` 的中断信号。

#### 退出码 137 或 SIGKILL

`SIGKILL`（立即终止信号）表示终止信号 `9`。这是终止应用程序时最不应该使用的方法。 因为终止信号为 `9`，因此我们得到的退出代码为 `137`（128+9）。

#### 退出码 143 或 SIGTERM

`SIGTERM` 是进程在未指定参数的情况下被杀死时的默认行为。 `SIGTERM` 的终止信号为 `15`，因此该信号的退出码为 `143`（128+15）。 还有一些你以前可能不知道的终止信号，它们也有自己类似的退出码。你可以在这里查看它们：

> 📋 请注意，如果进程在启动它的同一会话中终止，这些信号可能不会出现。如果要重现这些信号，请从不同的 shell 终止。
> 
> 就个人而言，信号 `128` 是无法重现的。

### 当退出码超过了 255 会怎样?

最新版本的 Bash 甚至保留了超过 255 的原始退出码的值，但一般来说，如果代码超过 255，就会被重新计算。 也就是说，代码 `256` 会变成 `0`，`257` 会变成 `1`，`383` 会变成 `127`，以此类推。为确保更好的兼容性，请将退出码保持在 `0` 至 `255` 之间。


## linux 安全指南

好的，我现在需要为用户提供一个关于Linux安全指南的全面回答。首先，我需要仔细阅读用户提供的搜索结果，从中提取关键的安全建议和最佳实践。接下来，我需要将这些信息分门别类，确保覆盖用户可能关心的各个方面，比如系统更新、用户权限、防火墙配置等。

首先，我看到搜索结果中多个网页都提到了系统更新和补丁管理的重要性，例如网页1、2、3、5、7、9都强调了及时更新系统和软件包以修复漏洞。这可能是一个基础但关键的点，需要放在前面。

然后是用户权限管理，网页1、2、3、5、8、9都提到了最小权限原则、使用sudo代替root登录、设置强密码策略等。特别是网页8还详细说明了如何配置密码复杂度和锁定策略，这部分需要整合进去。

防火墙和网络安全的配置在网页1、2、3、6、9中都有涉及，提到使用iptables或firewalld，限制不必要的端口和服务。网页4和6还讨论了选择更安全的初始化系统如不使用systemd，以及使用LibreSSL代替OpenSSL，但可能这些属于进阶内容，可能需要放在后面或者作为可选建议。

加密技术方面，网页1、2、3、4、5、6、7、10提到了文件系统加密、SSH密钥认证、磁盘加密等，特别是网页4详细讨论了内核安全配置，但可能用户需要的是更实用的步骤，所以需要简化这些内容。

日志和监控也是多个网页提到的重点，比如网页1、3、5、7、8、10，需要说明如何启用日志记录和使用工具进行分析。

恶意软件防范方面，网页2、5、7、9提到了安装防病毒软件和定期扫描，特别是网页7推荐了几款工具，需要列举出来。

此外，还有一些进阶建议，比如禁用不必要的服务（网页2、3、6、8）、使用SELinux或AppArmor（网页3、6）、定期备份数据（网页1、3、5、7）、配置SSH安全（网页9、10）等，需要分点说明。

最后，可能需要总结一些最佳实践，如定期审计、安全扫描、遵循最小安装原则等，这些在网页3、5、6、7、9中都有提到。

现在需要将这些信息结构化，分成几个主要部分，每个部分下包含具体的措施，并确保引用正确的网页来源。同时，要避免重复，合并相似的建议。例如，多个网页提到强密码策略，可以合并成一个点，引用多个来源。此外，检查是否有遗漏的重要点，如双因素认证（网页3）、使用安全软件源（网页7）等，确保覆盖全面。

可能的结构如下：
1. 系统更新与漏洞管理
2. 用户与权限管理
3. 网络安全配置
4. 数据加密与安全传输
5. 日志监控与审计
6. 恶意软件防护
7. 进阶安全措施
8. 最佳实践与持续维护

每个部分下再分点说明具体措施和相关引用。需要确保每个建议都有对应的网页支持，并且引用正确。例如，在系统更新部分引用网页1、2、3、5、7、9；在用户权限部分引用网页1、2、3、5、8、9等。

还要注意时间因素，今天是2025年3月7日，所以较旧的网页（如2022年的网页8）可能需要验证其建议是否仍然适用，但用户提供的搜索结果可能已是最新的，因此可以默认采用。同时，部分网页可能提供了更详细的操作步骤，如网页8中的具体配置文件修改，可能需要简化成用户易懂的建议，而不是详细命令。

最后，需要确保回答清晰、有条理，每个点都简洁明了，同时引用正确的来源，帮助用户进一步查阅详细信息。




以下是综合多个来源的Linux安全指南，涵盖核心防护措施与最佳实践，帮助提升系统安全性：

---

### 一、系统基础防护
1. **系统更新管理**  
   • 启用自动更新：`yum-autoupdate`（RHEL系）或`unattended-upgrades`（Debian系）
   • 定期执行手动更新：`apt update && apt upgrade` 或 `dnf update`
   • 优先应用关键安全补丁，避免使用已停止维护的旧内核

2. **最小化安装原则**  
   • 安装时仅选择必要软件包，禁用非必需服务（如`telnet`、`rpcbind`）
   • 使用轻量级初始化系统替代systemd（如OpenRC或runit）以减少攻击面

---

### 二、用户与权限控制
1. **账户安全策略**  
   • 禁用root远程登录，强制使用`sudo`执行特权命令
   • 设置密码复杂度：长度≥12位，包含大小写字母、数字及符号
   • 配置密码失败锁定：`pam_tally2.so deny=5 unlock_time=600`（5次失败后锁定10分钟）

2. **权限管理**  
   • 遵循最小权限原则：通过`chmod`限制文件权限（如配置文件设为644，脚本设为700）
   • 使用`setfacl`细化访问控制，避免全局可写目录

---

### 三、网络与访问控制
1. **防火墙配置**  
   • 启用`firewalld`或`iptables`，仅开放必要端口（如SSH自定义端口）
   • 限制IP访问：`/etc/hosts.allow`中设置白名单（如`sshd:192.168.1.0/24`）

2. **SSH安全强化**  
   • 禁用密码认证，强制使用密钥登录：`PasswordAuthentication no`
   • 修改默认端口，启用两步验证（如Google Authenticator）
   • 配置会话超时：`ClientAliveInterval 300`（5分钟无操作自动断开）

---

### 四、数据与加密保护
1. **磁盘加密**  
   • 安装时启用LUKS全盘加密，敏感目录使用`ecryptfs`
   • 数据库/配置文件采用`gpg`或`openssl`加密存储

2. **传输安全**  
   • 使用SFTP替代FTP，配置SSL/TLS加密Web服务（如Let's Encrypt证书）
   • 禁用弱加密算法：在`/etc/ssh/sshd_config`中设置`Ciphers aes256-ctr`

---

### 五、监控与应急响应
1. **日志审计**  
   • 集中管理日志：部署`rsyslog`或`journald`，监控`/var/log/auth.log`等关键文件
   • 使用工具分析异常：`fail2ban`自动封禁暴力破解IP，`Logwatch`生成日报

2. **入侵检测**  
   • 安装AIDE/Tripwire定期校验系统文件完整性
   • 启用SELinux/AppArmor强制访问控制

---

### 六、进阶安全措施
• **内核加固**：调整sysctl参数（如`kernel.kptr_restrict=2`隐藏内核指针）
• **沙箱隔离**：使用Firejail或Docker限制高风险应用权限
• **备份策略**：每日增量备份至异地存储，测试恢复流程

---

### 最佳实践清单
1. 定期进行漏洞扫描（OpenVAS/Nessus）
2. 禁用USB存储设备（通过`/etc/modprobe.d/blacklist.conf`）
3. 使用LibreSSL替代OpenSSL提升加密安全性
4. 配置`umask 027`限制新建文件默认权限

通过上述措施，可显著降低Linux系统风险。具体实施时需结合业务需求调整，建议参考各发行版官方文档细化配置。


## LVM

好的，我们来详细梳理一下 LVM 的常用操作和标准使用流程。LVM 的核心优势在于它提供了动态调整存储容量的灵活性。

### LVM 核心概念

首先，理解三个核心概念：

1.  **PV** - 物理卷
    *   实体：可以是硬盘分区、整个硬盘、RAID阵列。
    *   操作：被 LVM 初始化的存储设备。
2.  **VG** - 卷组
    *   实体：一个或多个 PV 的集合。
    *   操作：像一个“存储池”，从里面划分空间给 LV 使用。
3.  **LV** - 逻辑卷
    *   实体：从 VG 中划分出来的一块空间。
    *   操作：最终被格式化成文件系统并挂载使用的部分，对于系统来说，它就像一个普通分区。

---

### 一、标准 LVM 使用流程

这是一个从零开始创建并使用 LVM 的完整流程。

**步骤 1：准备物理磁盘或分区**

使用 `fdisk` 或 `gdisk` 创建新分区，并将其**类型标记为 `8e` (Linux LVM)**（对于 MBR）或 `8e00` (Linux LVM)（对于 GPT）。

```bash
sudo fdisk /dev/sdb
# 在 fdisk 交互界面中：n (新建) -> p (主分区) -> ... -> t (修改类型) -> 8e (LVM) -> w (保存)
```

**步骤 2：创建 PV**

使用 `pvcreate` 命令将分区初始化为物理卷。

```bash
# 创建单个 PV
sudo pvcreate /dev/sdb1

# 一次性创建多个 PV
sudo pvcreate /dev/sdb1 /dev/sdc1

# 查看所有 PV
sudo pvs
# 或查看详细信息
sudo pvdisplay
```

**步骤 3：创建 VG**

使用 `vgcreate` 命令将一个或多个 PV 组合成一个卷组。

```bash
# 创建名为 "myvg" 的 VG，并包含 /dev/sdb1
sudo vgcreate myvg /dev/sdb1

# 查看所有 VG
sudo vgs
# 或查看详细信息
sudo vgdisplay
```

**步骤 4：创建 LV**

使用 `lvcreate` 命令从 VG 中划分出逻辑卷。

```bash
# 创建名为 "mylv" 的 LV，大小为 20G
sudo lvcreate -L 20G -n mylv myvg

# 创建使用 VG 所有剩余空间的 LV
sudo lvcreate -l 100%FREE -n mylv myvg

# 查看所有 LV
sudo lvs
# 或查看详细信息
sudo lvdisplay
```

创建成功后，LV 的设备文件通常位于 `/dev/<vg_name>/<lv_name>`，例如 `/dev/myvg/mylv`。

**步骤 5：格式化和挂载 LV**

像使用普通分区一样，对 LV 进行格式化并挂载。

```bash
# 格式化为 ext4 文件系统
sudo mkfs.ext4 /dev/myvg/mylv

# 创建挂载点
sudo mkdir /mnt/mydata

# 挂载 LV
sudo mount /dev/myvg/mylv /mnt/mydata
```

**步骤 6：配置开机自动挂载**

编辑 `/etc/fstab` 文件，添加一行。

```bash
sudo vim /etc/fstab
```

添加以下内容（推荐使用 UUID，更稳定）：

```bash
# 先使用 `blkid` 命令查看 LV 的 UUID
/dev/myvg/mylv /mnt/mydata ext4 defaults 0 2

# 或者使用更稳定的 UUID 方式（推荐）
UUID=你的LV_UUID /mnt/mydata ext4 defaults 0 2
```

保存后，可以使用 `sudo mount -a` 测试配置是否正确。

---

### 二、LVM 常用维护操作

#### 1. VG 管理

*   **扩展 VG**（当有新的 PV 可用时）：
    ```bash
    # 先将新磁盘/分区创建为 PV
    sudo pvcreate /dev/sdc1
    # 将其添加到已有的 VG "myvg" 中
    sudo vgextend myvg /dev/sdc1
    ```

*   **缩小 VG**（**危险操作，需先迁移数据**）：
    ```bash
    # 1. 将数据从 /dev/sdb1 迁移到 VG 中的其他 PV
    sudo pvmove /dev/sdb1
    # 2. 从 VG "myvg" 中移除 PV /dev/sdb1
    sudo vgreduce myvg /dev/sdb1
    ```

#### 2. LV 管理（核心优势）

*   **扩展 LV**（**在线操作，无需卸载**）：
    ```bash
    # 1. 先扩展 LV 本身的大小（例如增加 10G）
    sudo lvextend -L +10G /dev/myvg/mylv
    # 或者扩展到指定大小
    sudo lvextend -L 30G /dev/myvg/mylv

    # 2. 然后扩展文件系统，使增加的空间可用
    # 对于 ext4 文件系统：
    sudo resize2fs /dev/myvg/mylv
    # 对于 xfs 文件系统：
    sudo xfs_growfs /mnt/mydata  # 注意 xfs 需要指定挂载点
    ```

*   **缩小 LV**（**有风险，务必先备份！**）：
    ```bash
    # 1. 卸载文件系统
    sudo umount /mnt/mydata
    # 2. 强制检查文件系统
    sudo e2fsck -f /dev/myvg/mylv
    # 3. 先缩小文件系统（例如缩小到 15G）
    sudo resize2fs /dev/myvg/mylv 15G
    # 4. 再缩小 LV
    sudo lvreduce -L 15G /dev/myvg/mylv
    # 5. 重新挂载
    sudo mount /dev/myvg/mylv /mnt/mydata
    ```
    **注意：XFS 文件系统不支持缩小！**

*   **删除 LV**：
    ```bash
    # 确保已卸载
    sudo umount /mnt/mydata
    # 删除 LV
    sudo lvremove /dev/myvg/mylv
    ```

*   **创建 LV 快照**（用于备份）：
    ```bash
    # 创建一个名为 "mylv-snap" 的快照，大小为 1G
    sudo lvcreate -L 1G -s -n mylv-snap /dev/myvg/mylv

    # 挂载快照（只读）进行备份
    sudo mount -o ro /dev/myvg/mylv-snap /mnt/snapshot
    # 备份完成后，卸载并删除快照
    sudo umount /mnt/snapshot
    sudo lvremove /dev/myvg/mylv-snap
    ```

#### 3. PV 管理

*   **查看 PV 信息**：
    ```bash
    sudo pvs
    sudo pvdisplay
    ```

*   **从 VG 中移除 PV**（见上面 VG 缩小部分）。

---

### 三、常用命令总结

| 功能 | 命令 | 说明 |
| :--- | :--- | :--- |
| **信息查看** | `pvs/vgs/lvs` | 简洁信息 |
| | `pvdisplay/vgdisplay/lvdisplay` | 详细信息 |
| **创建** | `pvcreate /dev/sdX1` | 创建 PV |
| | `vgcreate vg_name /dev/sdX1` | 创建 VG |
| | `lvcreate -L size -n lv_name vg_name` | 创建 LV |
| **扩展** | `vgextend vg_name /dev/sdX2` | 扩展 VG |
| | `lvextend -L +size /dev/vg_name/lv_name` | 扩展 LV |
| | `resize2fs /dev/vg_name/lv_name` | 扩展 ext4 文件系统 |
| **缩小** | `lvreduce -L -size /dev/vg_name/lv_name` | **小心**：缩小 LV |
| | `resize2fs /dev/vg_name/lv_name new_size` | **小心**：缩小 ext4 文件系统 |
| **删除** | `lvremove /dev/vg_name/lv_name` | 删除 LV |
| | `vgremove vg_name` | 删除 VG（需先删 LV） |
| | `pvremove /dev/sdX1` | 删除 PV（需先从 VG 中移除） |
| **快照** | `lvcreate -s -L size -n snap_name /dev/vg_name/lv_name` | 创建快照 |

### 最佳实践与注意事项

1.  **备份第一**：在对 LV 进行缩小、删除等危险操作前，务必备份重要数据。
2.  **使用 UUID**：在 `/etc/fstab` 中挂载时，使用 `UUID=` 而非设备路径，因为设备路径（如 `/dev/sdb`）可能在重启后发生变化，而 VG/LV 的名称路径（如 `/dev/myvg/mylv`）相对稳定，但 UUID 是最稳定的。
3.  **快照非备份**：快照主要用于创建一致性备份的瞬间状态，它不能替代异地备份。
4.  **预留空间**：不要将 VG 的 100% 空间全部分配给 LV，留一些空间有利于快照和灵活性。
5.  **规划大小**：合理规划 LV 的初始大小，虽然 LVM 可以动态扩展，但缩小要麻烦得多。

掌握以上操作，你就能很好地管理和使用 LVM 来满足动态存储需求了。


## RAID 冗余独立磁盘阵列 redundant array

# RAID 冗余独立磁盘阵列 redundant array of inexpensive disks
| **RAID 级别** | **描述** | **磁盘数量** | **数据冗余** | **读性能** | **写性能** | **磁盘空间利用率** | **优点** | **缺点** | **适用场景** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **RAID 0** | 数据条带化，没有冗余（数据分散在多个磁盘） | 2及以上 | 无冗余 | 高   | 高   | 100% | \- 提供最快的读写速度  <br>\- 磁盘空间利用率最高 | \- 无冗余，任何一个磁盘故障会导致数据丢失 | \- 对速度要求高且不重视数据保护的应用，如视频编辑、大数据处理 |
| **RAID 1** | 镜像，数据在两个磁盘间完全复制（镜像冗余） | 2   | 有冗余 | 中等  | 中等  | 50% | \- 数据冗余保护  <br>\- 读性能提高（从多个磁盘读取数据） | \- 写性能较低（因为需要写入所有镜像磁盘）  <br>\- 磁盘利用率低 | \- 需要高数据安全性、少量磁盘空间的场景，如数据库、关键应用服务器 |
| **RAID 5** | 数据条带化，带有奇偶校验（数据分布在多个磁盘上，并进行奇偶校验） | 3及以上 | 有冗余 | 高   | 中等  | 最低（N-1）% | \- 高冗余保护  <br>\- 较高的读性能  <br>\- 写性能相比RAID 1有所提升 | \- 写入性能较低（因为要计算奇偶校验）  <br>\- 恢复数据过程较慢 | \- 数据冗余和空间利用率要求较平衡的场景，如文件服务器、Web 服务器 |
| **RAID 6** | 类似RAID 5，但使用双重奇偶校验（可以承受两个磁盘故障） | 4及以上 | 有冗余 | 高   | 较低  | 最低（N-2）% | \- 提供更高的冗余保护（支持两个磁盘故障）  <br>\- 高读性能 | \- 写入性能较低（由于需要双重奇偶校验）  <br>\- 磁盘空间利用率低于RAID 5 | \- 需要高数据保护且写负载较轻的场景，如大型存储系统、数据中心 |
| **RAID 10 (1+0)** | RAID 1与RAID 0的组合，数据镜像与条带化 | 4及以上 | 有冗余 | 很高  | 很高  | 50% | \- 高读写性能  <br>\- 良好的冗余保护  <br>\- 故障恢复能力强 | \- 磁盘利用率较低（需至少4个磁盘）  <br>\- 成本较高 | \- 高性能与数据冗余都很重要的应用，如数据库、虚拟化环境、交易系统 |
| **RAID 50 (5+0)** | RAID 5与RAID 0的组合，条带化和奇偶校验结合 | 6及以上 | 有冗余 | 高   | 高   | 最低（N-2）% | \- 较高的读写性能  <br>\- 比RAID 5更高的冗余性能和性能 | \- 写入性能较低（仍有奇偶校验计算）  <br>\- 需要更多磁盘支持 | \- 需要平衡高性能和冗余的大型存储环境，如视频编辑、云存储 |
| **RAID 60 (6+0)** | RAID 6与RAID 0的组合，双重奇偶校验与条带化结合 | 8及以上 | 有冗余 | 高   | 较高  | 最低（N-4）% | \- 提供双重奇偶校验冗余保护  <br>\- 较高的读性能  <br>\- 较强的数据恢复能力 | \- 写入性能较低（需要双重奇偶校验）  <br>\- 磁盘空间利用率较低 | \- 对数据安全性要求高的大型存储场景，如数据中心、视频存档管理系统 |


## fstab

系统开机时会主动读取 `/etc/fstab` 这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。

## 挂载的限制
1. 根目录是必须挂载的，而且==一定要先于其他 mount point 被挂载==。因为是所有目录的根目录，其他目录都是由根目录 `/` 衍生出来的
2. 挂载点必须是已经存在的目录
3. 挂载点的指定可以任意，但必须遵守必要的系统目录架构原则
4. 所有挂载点在同一时间只能被挂载一次
5. 所有分区在同一时间只能挂在一次
6. 若进行卸载，必须将工作目录退出挂载点（及其子目录）之外
## 参数

```
UUID=be7c41...375162  /         ext4   defaults  1  1
tmpfs                 /dev/shm  tmpfs  defaults  0  0
```

| 列   | 名           | 作用                            |
| --- | ----------- | ----------------------------- |
| 第一列 | Device      | 磁盘设备文件或者该设备的 Label 或者 UUID    |
| 第二列 | Mount point | 挂载在那个目录                       |
| 第三列 | Filesystem  | 文件系统                          |
| 第四列 | Parameters  | 文件系统参数，默认 async               |
| 第五列 | dump        | 能否被dump备份命令作用（通常 0 或 1）       |
| 第六列 | fsck        | 是否检验扇区,开机过程中系统默认用fsck检验系统是否完整 |
## 查看分区的 Label 和 UUID
```
dumpe2fs -h /dev/sda1 blkid /dev/vda1
```
## 文件系统
*   ext2
*   ext3
*   ext4
*   reiserfs
*   xfs
*   jfs
*   smbfs
*   iso9660
*   vfat
*   ntfs
*   swap
*   auto
## 文件系统参数
* auto - 在启动时或键入了 mount -a 命令时自动挂载
* noauto - 只在你的命令下被挂载
* exec - 允许执行此分区的二进制文件
* noexec - 不允许执行此文件系统上的二进制文件
* ro - 以只读模式挂载文件系统
* rw - 以读写模式挂载文件系统
* user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数
* users - 允许所有 users 组中的用户挂载文件系统
* nouser - 只能被 root 挂载
* owner - 允许设备所有者挂载
* sync - I/O 同步进行，默认为 async
* async - I/O 异步进行，默认为 async
* dev - 解析文件系统上的块特殊设备
* nodev - 不解析文件系统上的块特殊设备
* suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限
* nosuid - 禁止 suid 操作和设定 sgid 位
* noatime - 不更新文件系统上 inode 访问记录，可以提升性能(参见 atime 参数)
* nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)
* relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能(参见 atime 参数)
* flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失
* usrquota 启动文件系统对用户磁盘配额模式支持
* grpquota 启动文件系统对群组磁盘配额模式的支持
* defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.
#### btrfs 挂载选项

1.  acl/noacl
2.  autodefrag/noautodefrag
3.  compress/compress-force
4.  subvol/subvolid
5.  device
6.  degraded
7.  commit
8.  ssd/nossd
9.  ssd\_spread/nossd\_spread
10.  nodiscard
11.  norecovery
12.  usebackuproot/nousebackuproot
13.  space\_cache=version、nospace\_cache、clear\_cache
14.  skip\_balance
15.  datacow/nodatacow
16.  datasum/nodatasum

```
UUID=ff4a838b-1571-4d31-9063-456f29b742fd /home btrfs compress=zstd:1,subvol=home 0 0
```

### <dump> dump 备份取值

*   0 不做dump备份
*   1 每天进行dump操作
*   2 不定日期进行dump操作

### <pass> fsck 检查参数

*   0 不检验
*   1 最早检验（一般根目录会选择）
*   2 1级别检验完后进行检验


## 磁盘and卷

### Linux 磁盘管理与分区扩容综合指南

---

#### 一、核心概念区分
| **场景**       | **适用工具**                     | **关键特点**                                |
|----------------|----------------------------------|-------------------------------------------|
| **非 LVM 环境** | `fdisk` + `resize2fs/xfs_growfs` | 直接操作物理分区，需保持起始扇区一致                |
| **LVM 环境**    | `pvcreate` + `vgextend` + `lvextend` | 逻辑卷动态扩展，支持在线扩容，灵活性高               |

---

### 二、通用操作命令
#### 1. **磁盘空间查看**
```bash
# 查看所有挂载点使用情况（含文件系统类型）
df -Th

# 树形显示块设备结构（磁盘→分区→挂载点）
lsblk -f

# 查看磁盘分区表（MBR/GPT）
fdisk -l
```

#### 2. **分区表重载**
```bash
# 通知内核更新分区表（避免重启）
partprobe /dev/sda
```

---

### 三、非 LVM 环境扩容流程
#### **适用场景**：直接操作物理分区（如 `/dev/sda1`）

#### 1. **操作流程**
```bash
# 1. 检查磁盘使用率
df -h /

# 2. 使用 fdisk 调整分区（需相同起始扇区！）
sudo fdisk /dev/sda
   → p        # 记录起始扇区
   → d        # 删除旧分区
   → n        # 新建分区（保持原起始扇区）
   → w        # 保存

# 3. 重载分区表
sudo partprobe /dev/sda

# 4. 调整文件系统
sudo resize2fs /dev/sda1      # ext2/3/4
或
sudo xfs_growfs /             # XFS（需已挂载）
```

#### 2. **注意事项**
- **扇区一致性**：新分区必须与原分区起始扇区相同，否则数据丢失。
- **备份数据**：建议使用 `dd if=/dev/sda1 of=/backup/sda1.img` 备份。
- **文件系统验证**：操作前执行 `fsck /dev/sda1` 检查完整性。

---

### 四、LVM 环境扩容流程
#### **适用场景**：逻辑卷管理（如 `/dev/centos/root`）

#### 1. **核心组件**
- **PV（物理卷）**：磁盘或分区（如 `/dev/sda2`）。
- **VG（卷组）**：PV 的集合（如 `vg_centos`）。
- **LV（逻辑卷）**：从 VG 划分的可扩展空间（如 `/dev/vg_centos/root`）。

#### 2. **扩容流程**
```bash
# 1. 添加新磁盘或扩展现有分区
sudo fdisk /dev/sdb → 创建分区类型 `8e` (Linux LVM)

# 2. 初始化物理卷
sudo pvcreate /dev/sdb1

# 3. 扩展卷组
sudo vgextend vg_centos /dev/sdb1

# 4. 扩展逻辑卷
sudo lvextend -l +100%FREE /dev/vg_centos/root

# 5. 调整文件系统
sudo resize2fs /dev/vg_centos/root    # ext2/3/4
或
sudo xfs_growfs /dev/vg_centos/root   # XFS
```

#### 3. **关键命令详解**
| **命令**         | **作用**                          | **常用参数**                     |
|------------------|-----------------------------------|----------------------------------|
| `pvdisplay`      | 显示物理卷详细信息                | `-m` 查看PE映射                  |
| `vgdisplay`      | 显示卷组剩余空间（`Free PE/Size`） | `-v` 显示详细VG、LV、PV关系      |
| `lvextend`       | 扩展逻辑卷容量                    | `-L +10G` 指定大小，`-r` 自动调整文件系统 |

#### 4. **高级操作**
- **在线扩容**：无需卸载文件系统（ext4/XFS 均支持）。
- **缩小逻辑卷**：  
  ```bash
  # ext4：需先卸载 → e2fsck → resize2fs → lvreduce
  # XFS：**不支持缩小**，需备份后重建
  ```

---

### 五、风险规避与最佳实践
1. **操作前检查**：
   ```bash
   # 确认设备名称
   lsblk
   # 验证文件系统类型
   blkid /dev/sda1
   ```

2. **数据备份方案**：
   - **全盘备份**：`dd if=/dev/sda of=/backup/sda.img bs=4M`
   - **增量备份**：`rsync -a --delete /data/ /backup/data/`

3. **LVM 环境维护**：
   - 定期检查 VG 剩余空间：`vgs`
   - 避免 VG 空间耗尽：预留 5-10% 的未分配空间。

---

### 六、操作流程图解
#### 非 LVM 扩容流程
```
[检查df] → [fdisk调整分区] → [partprobe] → [resize2fs/xfs_growfs]
```

#### LVM 扩容流程
```
[添加磁盘] → [pvcreate] → [vgextend] → [lvextend] → [resize2fs/xfs_growfs]
```

---

通过本指南，您可安全完成 Linux 系统下的磁盘扩容操作。根据实际环境选择 LVM 或非 LVM 方案，严格遵循操作顺序，确保数据安全。


## 在 Linux 中查看硬盘 UUID

在 Linux 系统中，UUID（通用唯一识别码）用于唯一标识磁盘分区或文件系统。UUID 是一个 128 位的数字，通常表示为 32 个十六进制数字，并用连字符分割为 5 组，总共 36 个字符的格式
## 使用 blkid 命令
_blkid_ 是一个命令行工具，用于定位或打印块设备的属性。它利用 _libblkid_ 库来获取磁盘分区的 UUID。使用方法如下：
```sh
blkid
输出示例：
/dev/sda1: UUID="d92fa769-e00f-4fd7-b6ed-ecf7224af7fa" TYPE="ext4" PARTUUID="eab59449-01"
/dev/sdc1: UUID="d17e3c31-e2c9-4f11-809c-94a549bc43b7" TYPE="ext2" PARTUUID="8cc8f9e5-01"
```
## 使用 lsblk 命令
_lsblk_ 命令列出所有可用的或指定的块设备的信息。它读取 _sysfs_ 文件系统和 _udev_ 数据库以收集信息。使用方法如下：
```bash
lsblk -o name,mountpoint,size,uuid
输出示例：
NAME MOUNTPOINT SIZE UUID
sda 30G
└─sda1 / 20G d92fa769-e00f-4fd7-b6ed-ecf7224af7fa
sdb 10G
sdc 10G
├─sdc1 1G d17e3c31-e2c9-4f11-809c-94a549bc43b7
```
## 使用 by-uuid 路径
在 _/dev/disk/by-uuid/_ 目录下包含了 UUID 和实际的块设备文件，UUID 与实际的块设备文件链接在一起。使用方法如下：
```bash
ls -lh /dev/disk/by-uuid/
输出示例：
lrwxrwxrwx 1 root root 10 Jan 29 08:34 d92fa769-e00f-4fd7-b6ed-ecf7224af7fa -> ../../sda1
lrwxrwxrwx 1 root root 10 Jan 29 08:34 d17e3c31-e2c9-4f11-809c-94a549bc43b7 -> ../../sdc1
```
## 使用 hwinfo 命令
_hwinfo_ 是一个硬件信息工具，用于检测系统中已存在的硬件，并以可读的格式显示各种硬件组件的详细信息。使用方法如下：
```bash
hwinfo --block | grep by-uuid | awk '{print $3,$7}'
输出示例：
/dev/sdc1, /dev/disk/by-uuid/d17e3c31-e2c9-4f11-809c-94a549bc43b7
/dev/sda1, /dev/disk/by-uuid/d92fa769-e00f-4fd7-b6ed-ecf7224af7fa
```

