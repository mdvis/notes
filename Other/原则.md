## **SOLID**
- SRP(single-responsibility principle)
- OCP(open-closed principle)
- LSP(liskov substitution principle)
- ISP(interface segregation principle)
- DIP(dependency inversion principle)
SDA 和 SDP 结合形成依赖倒置原则（DIP）
	**SDP (Stable Denpendencies Principle)** 稳定依赖原则
	稳定组件不应该依赖稳定性低的组件
	**SAP (Stable Abstraction Principle)** 稳定抽象原则
	稳定的组件应该是抽象的，不稳定的组件应该是具体的
## **CARP (Composition/Aggregation Reuse  Principle)**
合成/聚合复用原则，优先使用对象组合（合成）和聚合，而不是继承达到代码复用。
## 最少知识
- **LoD (Law of Demeter)** 迪米特法则/最少知识原则
- **PoLK (Principle of Least Knowledge)** 最少通信（知识）原则
一个对象应对其他对象尽可能少的了解（结构、实现细节等）有助于减少对象之间的耦合，提高代码的可维护性和可重用性
## KISS
KISS(Keep It Simple and stupid) 尽量保持简单(怎么做)
## DRY/SPOT
有一个编程原则叫做 DRY (Don't repeat yourself，不要重复自己），指的是尽量不要有重复的代码，更好的名字应该是 SPOT (Single Point of Truth， 单点事实）。代码需要修改时，你只需要在一个地方修改，而不必改动多个地方。
## YAGNI
YAGNI(You Ain't Gonna Need It)(ain't = are not)(gonna = gong to) 你不需要他（避免过度设计）（要不要做）
## GRASP
General Responsibility Assignment Software Patterns 通用职责分配软件模式
*   创建者（Creator）
*   信息专家（Information Expert）
*   低耦合（Low coupling）
*   控制器（Controller）
*   高内聚（High Cohesion）
*   多态性（Polymorphism）
*   纯虚构（Pure Fabrication）
*   间接性（Indirection）
*   防止变异（Protected Variations）

# 编程原则速查表 (Cheat Sheet)
## 🥇 第一梯队（核心原则）

| 原则                                     | 一句话解释            | 正例            | 反例           |
| -------------------------------------- | ---------------- | ------------- | ------------ |
| **KISS** (Keep It Simple, Stupid)      | 保持简单，避免不必要复杂性    | 一个函数只做一件事     | 嵌套十层 if/else |
| **DRY** (Don’t Repeat Yourself)        | 不要重复造轮子，提炼公共逻辑   | 公共方法抽取到 utils | 多处复制粘贴相同逻辑   |
| **YAGNI** (You Aren’t Gonna Need It)   | 不要提前实现可能永远用不到的功能 | 按需开发          | 为“未来”写十个备用接口 |
| **SoC** (Separation of Concerns) 关注点分离 | 模块/层次职责单一        | MVC 模式        | 所有逻辑写在一个类里   |
| **SOLID**                              | 面向对象设计五大原则       | 单一职责、开闭、里氏替换等 | “万能类”承担所有功能  |
## 🥈 第二梯队（工程实践）

| 原则                                      | 一句话解释       | 正例                              | 反例                  |
| --------------------------------------- | ----------- | ------------------------------- | ------------------- |
| **Design for Change**                   | 代码要容易改动和扩展  | 插件化架构                           | 改个字段要动全系统           |
| **CoC** (Convention over Configuration) | 遵循约定，减少配置负担 | Rails 默认约定路径                    | 每个项目写几十份 config     |
| **Fail Fast**                           | 出错要尽早暴露     | 输入校验立即抛错                        | 错误吞掉，运行到后面崩溃        |
| **LoD** Law of Demeter (迪米特法则)          | 模块只与直接朋友通信  | user.getAddress().getCity() 封装好 | 层层调用 `.a().b().c()` |
| **POLA** 最小惊讶原则                         | API 行为要符合直觉 | `list.length` 返回元素个数            | `list.length` 返回字节数 |
## 🥉 第三梯队（哲学与高阶设计）

| 原则                           | 一句话解释               | 正例                | 反例                   |
| ---------------------------- | ------------------- | ----------------- | -------------------- |
| **组合优于继承**                   | 用组合扩展功能而非深继承        | Strategy 模式       | 深层继承链，改一处全崩          |
| **可读性优先 (Clean Code)**       | 代码写给人看，机器只是顺便执行     | 有意义的变量名           | `a, b, c, d` 随机命名    |
| **Don’t Make Me Think**      | API / UI 要直观，减少心智负担 | `user.isActive()` | `user.flagX()` 不知啥意思 |
| **You Build It, You Run It** | 开发者负责到上线运维          | DevOps 一条龙        | 写完交给 Ops，出问题甩锅       |
| **Worse is Better**          | 简单实用 > 完美复杂         | Unix 工具链          | 巨型“完美框架”没人用          |
- 写不下去时 → **KISS / DRY / YAGNI**
- 架构设计时 → **关注点分离 / SOLID / Fail Fast**
- 长期维护时 → **组合优于继承 / Clean Code / 最小惊讶**

## Unix 原则

- 让每个程序就做好一件事，如果有新任务，就重新开始。不要在原程序中加入新功能而搞复杂。
	a. 一个程序只做一件事，并做好。
	b. 程序要能协作。
	c. 程序要能处理文本流，因为这是最通用的接口。
- 假定一个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。
	a. 输出中不要有无关的信息干扰。
	b. 避免使用严格的分栏格式和二进制格式输入。
	c. 不要坚持使用交互式输入。
- 尽可能早的将设计和编译的软件投入试用。哪怕是操作系统也不例外。理想情况下是几星期内，对拙劣的代码别犹豫，丢掉重写。
- 优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。

1. 模块原则：使用简洁的接口拼合简单的部件
2. 清晰原则：清晰胜于机巧
3. 组合原则：设计时考虑拼接组合
4. 分离原则：策略同机制分离，接口同引擎分离
5. 简洁原则：设计要简洁，复杂度能低则低
6. 吝啬原则：除非却无他法，不要编写庞大的程序
7. 透明性原则：设计要可见，以便审查和调试
8. 健壮原则：健壮源于透明与简洁
9. 表示原则：把知识叠入数据以求逻辑质朴而健壮
10. 通俗原则：接口设计避免标新立异
11. 缄默原则：如果一个程序设计没什么好说多，就沉默
12. 补救原则：出现异常时，马上退出并给足够的错误信息
13. 经济原则：宁花机器一分，不花程序猿一秒
14. 生成原则：避免手工Hack，尽量编写程序去生成程序
15. 优化原则：雕琢前要先有原型，跑前先会走
16. 多样原则：绝不相信所谓'不二法门'的断言
17. 扩展原则：设计着眼未来，未来总比想象来的快