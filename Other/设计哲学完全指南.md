## 第一部分：什么是好系统设计
### 核心理念
- **好的系统设计不是炫技**，而是 **满足需求**。
- 目标是 **简单、健壮、易于理解、可维护**。
- 设计应当考虑权衡，而不是追求"完美架构"。
## 第二部分：系统设计的原则
### 1. 从需求出发
- **明确系统要解决什么问题**。
- 需求分为：
  - **功能性需求 (Functional requirements)**：系统必须完成的事。
  - **非功能性需求 (Non-functional requirements)**：系统必须满足的质量指标，如性能、可靠性、扩展性等。
### 2. KISS 原则
- **Keep It Simple, Stupid**
- **简单往往比复杂更好**：复杂度是系统失败的最大风险。
### 3. YAGNI 原则
- **You Ain't Gonna Need It (You are not going to need it)**
- **不要为了未来的可能性过度设计**。只构建当前需求所需的功能。
### 4. 容错性
- **假设系统的每个组件最终都会失败**。
- 关键是 **隔离失败、快速恢复**，而不是避免失败。
### 5. 扩展性
- **横向扩展 (scale out) 比纵向扩展 (scale up) 更现实**。
- 设计要考虑未来增长，但不要过度优化。
### 6. 权衡
- **没有免费的午餐**，每个设计都有成本。
- 例如：
  - 一致性 vs 可用性
  - 延迟 vs 吞吐量
  - 开发速度 vs 系统复杂度
## 第三部分：系统设计的实践步骤
### Step 1: 明确需求
问清楚：用户想要什么？规模多大？关键性能指标是什么？
### Step 2: 建立简单模型
首先用最简单的架构满足需求（单机 + 数据库）。
逐步增加复杂度，而不是一开始就设计"大规模分布式系统"。
### Step 3: 识别瓶颈
系统最薄弱的部分决定了扩展能力。常见瓶颈：
- 数据库读写
- 网络带宽
- 磁盘 IO
- 内存
### Step 4: 增量优化
针对瓶颈做出优化，而不是一次性大规模重构。常见手段：
- 缓存 (Cache)
- 分区/分片 (Partitioning, Sharding)
- 复制 (Replication)
- 队列 & 异步处理 (Queue, Async)
## 第四部分：常见设计模式
### 1. 缓存 (Caching)
- 提高性能、降低数据库压力。
- 要考虑缓存一致性。
### 2. 数据库扩展
#### 垂直扩展
- 升级硬件。
#### 水平扩展
- **复制 (Replication)**：提高可用性和读取性能。
- **分片 (Sharding)**：分散写入负载。
### 3. 队列 (Queues)
- 解耦系统、平滑流量高峰。
- 异步处理可以减少用户请求延迟。
### 4. 冗余 (Redundancy)
- 多副本、跨区部署，确保高可用。
### 5. 监控 & 报警
- 必须实时监控，快速发现问题。
- **没有监控的系统等于瞎子**。
## 第五部分：设计原则速查表
### 🥇 第一梯队（核心原则）

| 原则                                     | 一句话解释            | 正例            | 反例           |
| -------------------------------------- | ---------------- | ------------- | ------------ |
| **KISS** (Keep It Simple, Stupid)      | 保持简单，避免不必要复杂性    | 一个函数只做一件事     | 嵌套十层 if/else |
| **DRY** (Don't Repeat Yourself)        | 不要重复造轮子，提炼公共逻辑   | 公共方法抽取到 utils | 多处复制粘贴相同逻辑   |
| **YAGNI** (You Aren't Gonna Need It)   | 不要提前实现可能永远用不到的功能 | 按需开发          | 为"未来"写十个备用接口 |
| **SoC** (Separation of Concerns) 关注点分离 | 模块/层次职责单一        | MVC 模式        | 所有逻辑写在一个类里   |
| **SOLID**                              | 面向对象设计五大原则       | 单一职责、开闭、里氏替换等 | "万能类"承担所有功能  |
### 🥈 第二梯队（工程实践）

| 原则                                      | 一句话解释       | 正例                   | 反例                  |
| --------------------------------------- | ----------- | -------------------- | ------------------- |
| **Design for Change**                   | 代码要容易改动和扩展  | 插件化架构                | 改个字段要动全系统           |
| **CoC** (Convention over Configuration) | 遵循约定，减少配置负担 | Rails 默认约定路径         | 每个项目写几十份 config     |
| **Fail Fast**                           | 出错要尽早暴露     | 输入校验立即抛错             | 错误吞掉，运行到后面崩溃        |
| **LoD** Law of Demeter (迪米特法则)          | 模块只与直接朋友通信  | 封装好接口                | 层层调用 `.a().b().c()` |
| **POLA** 最小惊讶原则                         | API 行为要符合直觉 | `list.length` 返回元素个数 | `list.length` 返回字节数 |
### 🥉 第三梯队（哲学与高阶设计）

| 原则                           | 一句话解释               | 正例                | 反例                   |
| ---------------------------- | ------------------- | ----------------- | -------------------- |
| **组合优于继承**                   | 用组合扩展功能而非深继承        | Strategy 模式       | 深层继承链，改一处全崩          |
| **可读性优先** (Clean Code)       | 代码写给人看，机器只是顺便执行     | 有意义的变量名           | `a, b, c, d` 随机命名    |
| **Don't Make Me Think**      | API / UI 要直观，减少心智负担 | `user.isActive()` | `user.flagX()` 不知啥意思 |
| **You Build It, You Run It** | 开发者负责到上线运维          | DevOps 一条龙        | 写完交给 Ops，出问题甩锅       |
| **Worse is Better**          | 简单实用 > 完美复杂         | Unix 工具链          | 巨型"完美框架"没人用          |
## 第六部分：SOLID 原则详解
### S - Single Responsibility Principle (SRP)
单一职责原则 - 一个类应该只有一个改变的理由
### O - Open/Closed Principle (OCP)
开闭原则 - 对扩展开放，对修改关闭
### L - Liskov Substitution Principle (LSP)
里氏替换原则 - 子类应该能替换父类
### I - Interface Segregation Principle (ISP)
接口隔离原则 - 不要依赖不需要的接口
### D - Dependency Inversion Principle (DIP)
依赖倒置原则 - 依赖抽象而不是具体实现
## 第七部分：设计的通用模式
### 高内聚、低耦合
- 模块内部紧密相关
- 模块之间联系松散
### 关注点分离 (SoC)
- 将问题分解为独立的关注点
- 每个模块负责一个关注点
### 模块化与分层
- 明确的层次结构
- 层与层之间通过定义好的接口交互
### 可扩展性设计
- 使用插件化架构
- 支持配置驱动
## 第八部分：好系统设计的标准
- **简单**：能被新人快速理解。
- **健壮**：即使部分失败也能继续运行。
- **可扩展**：能随着用户和数据量的增加而演进。
- **可观测**：有良好的监控和日志，方便排查问题。
- **渐进式演化**：能根据需求逐步演进，而不是推倒重来。
## 第九部分：设计哲学的核心结论
1. **复杂度是最大敌人** - 始终优先考虑简化
2. **从需求出发** - 而不是从技术出发
3. **保持简单** - KISS 和 YAGNI 原则永不过时
4. **容忍失败** - 设计容错机制而不是试图完全避免失败
5. **逐步演化** - 而不是一步到位的完美设计
**最终的目标：好用、稳定、能扩展，而不是炫技。**
**本指南涵盖了系统设计的哲学、原则和实践，帮助你做出更好的架构决策。**
## 软件设计原则：CUPID 
 **好代码 5 特质:** 
1. C，Composable，可组合 
2. U，Unix，做好一件事 
3. P，Predictable，可预测 
4. I，Idiomatic，符合惯例的 
5. D，Domain Based，基于领域的
## 可组合特质（C）
在讨论面向对象程序设计的时候，越来越关注到“组合优于继承”这样的原则。作为面向对象程序设计的三大特征之一的“继承”，似乎正越来越受到挑战
1. 很多继承的设计是不合理的，比如不符合SOLID所指出的里氏代换原则
2. 过深的继承树带来了代码的可理解性问题，因为我们总是需要理解了基类才能理解子类。
其实继承也是很有用的，但其前提是设计合理的继承。“组合优于继承”就是告诉我们优先考虑用组合模式来进行设计。
**可组合还体现在以下三个方面：**
### 精巧的接口
1. 接口太多时，如何组合这些接口去完成功能，接口较少时，可以更容易学习并更少犯错。
2. 只对外公开一个模块来提供接口，比对外公开多个模块提供接口更好。只对外公开一个类来提供接口，比对外公开多个类提供接口更好。 
3. 正确的接口粒度设计比较困难，最佳的粒度是接口既不显得臃肿也不碎片化。 设计模式中有一种常见的模式Facade，即门面模式，其意图正是将对外公开的接口放到一个类中去提供，以便减少接口面，从而让接口更容易使用。
### 可体现意图的代码
可体现意图的代码是用业务语言编写且能反映业务过程的代码。可体现意图的代码可以使读者更容易弄清为什么代码要这么写，因此更容易组合使用。代码中的各类命名（比如变量、函数等）都可以用于将意图体现得更为明显。 
### 最小依赖
拥有最小依赖的代码是容易组合使用的。  面向对象程序设计有一个重要的原则，即迪米特法则（Law of Demeter），又被称为最小知识原则、不要和陌生人说话原则。其指导意义在于一个类不应该和与其不相关的类产生（依赖）关系。
## Unix哲学（U）
一个程序应该做一件事，并将其做好。比如ls程序只做列举文件的事，文件详情，则需要lstat，文件内容使用cat，搜索文件使用grep等。Unix操作系统中定义了一个强大的管道（Pipe）概念，一个程序的输出可以通过管道传输给另一个程序，从而简单而一致的实现了多个程序的组合使用。 只做好一件事与SOLID中的单一职责原则很像。 与Unix原则描述很相似的还有关注点分离的原则。关注点分离是指不同的模块应该关注不同的事情。
## 可预测性（P）
程序的可预测性是指它应该做它看起来要做的事情，一致且可靠，不隐藏任何出乎意料的行为。最佳的提升程序的可观测性的方式还是通过有意识的设计来在关键处输出程序的状态或行为。 可预测性包括三个方面：
1. **与期望一致的行为** 可以通过测试来定义所期望的程序的行为，精心的挑选名字，克制的编写逻辑，正确的处理异常这些都能使得程序与期望的行为一致。
2. **输出确定的结果** 易于推理的代码是好代码，具备确定性的就具备易于推理的特性。不确定性常常来自复杂且不确定的依赖，严格控制其依赖的外部模块，尽量做到无依赖，也可以增强程序的确定性。 具备确定性的代码通常是健壮、可靠而具备弹性的。
3. **内部行为可观测** 程序在运行时打印关键的内部状态或行为就可以让我们推测其当前状态
	观察程序内部状态可以分为以下几个级别：
	*   **信息仪表（Instrumentation）** : 程序告诉我们它正在干什么
	*   **遥测（Telemetry）** : 程序告诉我们的信息用接口暴露，使其可远程访问
	*   **监控（Monitoring）** : 将程序告诉我们的信息可视化出来
	*   **告警（Alerting）** : 从监控信息中识别异常，发出通知
	*   **预测（Predicting）** : 利用监控信息来预测即将发生的事件
	*   **自适应（Adapting）** : 通过告警的或者预测的信息动态调整系统以适应变化
## 符合惯例的（I）
编写“人类可读的代码”意味着为别人编写代码。这正是“符合惯例”的意义。 编写代码时，可以假定你的用户具备以下背景：
*   熟悉所使用的编程语言，及该语言对应的库、工具链和生态
*   懂软件开发的有经验的开发者, 还有一条，他们正努力的完成某件事情。
**语言惯例** 代码应该遵循编程语言的惯例。语言惯例出现在各个级别的代码中，函数名、类型、参数、模块、代码组织结构、模块组织结构、工具链选择、依赖选择、管理依赖的方式等。
**团队惯例** 当编程语言本身没有风格倾向，或者有多种风格可选的时候，用什么风格来写代码就由我们自己或者我们的团队来决定了。通常团队会自己定义一些惯例，比如用什么工具，如何缩进等。
## 基于领域的（D）
1. **基于领域的语言**
代码的读者通常对问题是清楚的，所以，代码应该用问题空间的语言来写，这样就能让代码的读者更容易的理解。问题空间语言即领域语言。
TDD可以用于帮助我们更多的用领域语言编写代码。TDD要求在还没有实现代码的时候写出测试代码。TDD是希望我们可以在看到问题后，先用自然语言描述测试过程，然后再将自然语言的测试过程翻译为编程语言。由于描述测试过程时，会站在用户的角度进行描述，所以将更多的使用领域语言。并且测试过程的描述将反映出程序应该有的公开接口，所以接口也会变成用领域语言描述的接口，这就很大程度上促进了用领域语言编写代码。
举个例子，在电商场景中，如果要实现购物车的功能，则分析购物车的业务需求之后，可以将测试过程描述如下： 
- 准备一个空的购物车
- 向购物车添加商品1，数量1
- 向购物车添加商品2，数量2
- 购物车中应该有两种商品，其中有1个商品1及2个商品2
- 向购物车添加商品1，数量1
- 购物车中应该有两种商品，其中有2个商品1及2个商品2
- 从购物车取出商品1，数量2 
- 购物车中应该有一种商品，即2个商品2 
翻译为Java语言的测试代码示例如下（部分）：
```
...
void testCart() {
    var cart = new Cart();
    var product1 = new Product();
    var product2 = new Product();

    cart.add(product1, 1);
    cart.add(product2, 2);

    assertTrue(cart.contains(product1));
    assertEquals(1, cart.productCount(product1));
    assertTrue(cart.contains(product2));
    assertEquals(2, cart.productCount(product2));

    cart.add(product1, 1);
    ......
}
...
```
可以看到，通过编写测试，我们用领域语言设计了Cart类，Product类，并且对Cart类设计了add contains productCount三个方法。除了促进使用领域语言编写代码，TDD还可以让我们提供的接口刚刚够用，不多不少，从而实现可组合性特质中的“精巧的接口”。 
使用领域语言编写代码的最佳状态是，我们的代码可以让没有技术背景的业务人员也能轻松看懂，整个代码读起来就像业务分析师在讲解业务逻辑一样。
2. **基于领域的结构**
除了使用领域语言编写代码，在模块的设计、代码目录结构（或包结构）也应该优先使用领域语言命名。  使用基于领域的结构，建议尽量将目录按照领域进行划分，而不是框架概念。
比如，如果是一个电商的场景，目录结构应该是user product order payment shipment等。
3. **基于领域的边界**
无论我们如何组织代码结构，目录（或模块）的边界变成了事实上的领域边界。一打开代码库就能看到目录结构，目录的层级和名字逐渐变成了大家最熟系的信息。所以，在设计上，一个重要的原则就是将领域划分和目录划分保持一致。这将有效降低团队的认知负载，开发者将因此而更不容易犯错，团队效率最终将得到提高。 这并不意味着需要组织成一个平坦（flat）的目录结构。领域以下可以有子领域，目录以下可以有子目录，模块以下可以有子模块。重要的是这一个一个层级需要能对应上。