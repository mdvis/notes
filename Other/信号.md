## 常见信号
在 Unix 和 Linux 系统中，信号是一种有限的异步通信机制，用于通知进程发生了某种事件。以下是一些常见的信号及其简要介绍：
### 1\. **SIGHUP (1)**
*   **名称**：挂起信号（Hangup）
*   **用途**：通常用于通知终端关闭。许多守护进程使用 SIGHUP 来重新加载配置文件或重新启动。
### 2\. **SIGINT (2)**
*   **名称**：中断信号（Interrupt）
*   **用途**：由用户从终端通过 `Ctrl+C` 组合键发送，用于中断一个进程。
### 3\. **SIGQUIT (3)**
*   **名称**：退出信号（Quit）
*   **用途**：由用户从终端通过 `Ctrl+\` 组合键发送，用于生成核心转储（core dump）并退出进程。
### 4\. **SIGILL (4)**
*   **名称**：非法指令信号（Illegal Instruction）
*   **用途**：当进程尝试执行非法或未定义的 CPU 指令时发送。
### 5\. **SIGABRT (6)**
*   **名称**：异常终止信号（Abort）
*   **用途**：由调用 `abort()` 函数的进程发送，通常用于指示严重错误。
### 6\. **SIGFPE (8)**
*   **名称**：浮点异常信号（Floating Point Exception）
*   **用途**：当进程执行的算术操作出现错误（如除以零或溢出）时发送。
### 7\. **SIGKILL (9)**
*   **名称**：杀死信号（Kill）
*   **用途**：强制终止进程。无法捕获、阻塞或忽略此信号。
### 8\. **SIGSEGV (11)**
*   **名称**：段错误信号（Segmentation Fault）
*   **用途**：当进程非法访问内存（如访问未分配的内存或尝试写入只读内存）时发送。
### 9\. **SIGPIPE (13)**
*   **名称**：管道破裂信号（Broken Pipe）
*   **用途**：当进程尝试向已被关闭的管道或套接字写入数据时发送。
### 10\. **SIGALRM (14)**
*   **名称**：定时器信号（Alarm）
*   **用途**：当定时器到期时发送，由 `alarm()` 函数设置的定时器触发。
### 11\. **SIGTERM (15)**
*   **名称**：终止信号（Termination）
*   **用途**：用于请求进程终止，可以被捕获并处理或忽略，是一种优雅的终止进程方式。
### 12\. **SIGUSR1 (10) 和 SIGUSR2 (12)**
*   **名称**：用户自定义信号 1 和 2（User-defined Signals）
*   **用途**：用户和应用程序自定义使用，行为由开发者定义。
### 13\. **SIGCHLD (17)**
*   **名称**：子进程状态变化信号（Child Status Change）
*   **用途**：当子进程停止或终止时发送给父进程。
### 14\. **SIGCONT (18)**
*   **名称**：继续执行信号（Continue）
*   **用途**：用于恢复一个已被停止（使用 SIGSTOP 或 SIGTSTP）进程的执行。
### 15\. **SIGSTOP (19)**
*   **名称**：停止执行信号（Stop）
*   **用途**：用于无条件地停止进程执行，无法捕获或忽略。
### 16\. **SIGTSTP (20)**
*   **名称**：终端停止信号（Terminal Stop）
*   **用途**：由用户从终端通过 `Ctrl+Z` 组合键发送，用于停止进程执行，可以捕获和处理。
### 17\. **SIGTTIN (21) 和 SIGTTOU (22)**
*   **名称**：后台读和写终端信号（Terminal Input/Output for Background Process）
*   **用途**：当后台进程尝试读写终端时发送，默认行为是停止进程。
### 18\. **SIGBUS (7)**
*   **名称**：总线错误信号（Bus Error）
*   **用途**：当进程发生内存访问错误时发送，如未对齐的内存访问。
## USR1
`USR1` 信号是一个用户自定义信号（用户信号 1），在 Unix 和 Linux 系统中，用户信号通常是由应用程序或用户定义的行为来处理的。`dd` 命令在设计时包含了对 `USR1` 信号的特殊处理，使得它在接收到该信号时，会输出当前的进度信息。 具体来说，当运行 `dd` 命令并发送 `USR1` 信号给其进程时，`dd` 会在标准错误输出中打印当前的 I/O 统计信息（例如，已经处理的字节数和速度）。这是一个实用的功能，特别是在 `dd` 长时间运行时，可以随时查看进度而不终止进程。
### `USR1` 信号的优点：

*   **非破坏性**：发送 `USR1` 信号不会中断或终止 `dd` 进程，它只是触发 `dd` 打印当前的进度信息。
*   **即时反馈**：可以在 `dd` 运行期间的任何时间点查看进度，而不需要修改原始命令或停止进程。 这种机制利用了 Unix 信号系统的灵活性，允许用户动态与运行中的进程交互，而无需事先配置或使用其他工具。
### 使用场景
`USR1` 信号可以用在许多其他场景中，通常用于触发进程执行某些用户定义的动作，而不终止或严重中断进程。以下是一些常见的应用场景：
#### 1\. **日志轮换**：
许多守护进程（如 web 服务器、数据库服务器等）使用 `USR1` 信号来触发日志文件轮换。在收到 `USR1` 信号时，这些进程会关闭当前日志文件并打开一个新的日志文件，通常是为了避免日志文件过大。
*   **Nginx**： `sudo kill -USR1 $(cat /var/run/nginx.pid)` Nginx 会在收到 `USR1` 信号时进行日志文件轮换。
#### 2\. **重新加载配置**：
一些应用程序使用 `USR1` 信号来触发重新加载配置文件，而无需完全重新启动进程。这对于需要频繁调整配置但不希望中断服务的场景非常有用。
*   **Apache HTTP Server**： `sudo apachectl -k graceful` Apache HTTP Server 可以在接收到 `USR1` 信号时以一种优雅的方式重新加载配置文件。
#### 3\. **自定义应用程序行为**：
开发人员可以在自己的应用程序中捕获 `USR1` 信号，并定义一组特定的动作。例如，可以用来生成调试信息、刷新缓存、更新统计数据等。
#### 4\. **进度报告和状态检查**：
类似于 `dd` 的用法，其他需要长时间运行的进程也可以利用 `USR1` 信号在不中断进程的情况下提供当前状态或进度报告。
### 如何在应用程序中处理 `USR1` 信号：
在编程中，可以使用信号处理机制来捕获和处理 `USR1` 信号。例如，在 Python 中：
```
import signal 
import os
import time
def handle_usr1(signum, frame):
	print(f"Received USR1 signal: {signum}")
    # 这里可以添加自定义的处理逻辑，例如打印状态信息  
    # 注册 USR1 信号处理程序 
    signal.signal(signal.SIGUSR1, handle_usr1)
    print(f"Process ID: {os.getpid()}")
    while True:
         print("Running...") 
         time.sleep(10)
```

运行上述代码后，可以在另一个终端发送 `USR1` 信号： `kill -USR1 <Python_script_PID>` 发送信号后，Python 脚本会调用 `handle_usr1` 函数并输出相应信息。 通过这种方式，`USR1` 信号可以在许多实际应用场景中用于动态控制和管理进程，而无需停止或重新启动它们。
## 其他
这些信号允许操作系统与进程之间进行简单而有效的通信，以处理错误、控制进程执行、进行进程间通信等。开发人员可以在程序中捕获和处理这些信号，以实现各种自定义行为。 这些方法可以帮助你在使用 `dd` 命令时实时查看进度。

1.  **使用 **​**​`status=progress`​**​ \*\* 选项\*\*（适用于较新的 `dd` 版本）：

```
dd if=/path/to/inputfile of=/path/to/outputfile bs=4M status=progress
```

1.  **使用 **​**​`pv`​**​ \*\* 工具\*\*（管道视图）： 先安装 `pv`：

```
sudo apt-get install pv   # 对于 Debian/Ubuntu
sudo yum install pv       # 对于 CentOS/RHEL
pv /path/to/inputfile | dd of=/path/to/outputfile bs=4M
```

1.  **使用 **​**​`kill -USR1`​**​ \*\* 信号\*\*： 如果 `dd` 已经在运行，可以向 `dd` 进程发送 `USR1` 信号来查看进度。首先找到 `dd` 的进程 ID（PID），然后发送信号：

```
ps aux | grep dd         # 找到 dd 的 PID
kill -USR1 <PID>
```

1.  **使用 GNU **​**​`ddrescue`​**​ \*\* 工具\*\*： `ddrescue` 是 `dd` 的增强版本，默认显示进度信息。安装并使用它：

```
sudo apt-get install gddrescue  # 对于 Debian/Ubuntu
sudo yum install ddrescue       # 对于 CentOS/RHEL
ddrescue /path/to/inputfile /path/to/outputfile
```

## SIGNAL (英文内容)

信号是一种简单且轻量级的进程间通信形式。是一种单向通知。可是是内核发给进程，一个进程发给另一个进程，一个进程发送给自己。
## 一些重要信号

| 信号名称    | 信号值 | 行为                                          |
| ------- | --- | ------------------------------------------- |
| SIGHUP  | 1   | 重启（Hang up or shut down and restart process |
| SIGINT  | 2   | 中断`<C-c>`                                   |
| SIGQUT  | 3   | 退出`<C-\>`                                   |
| SIGKILL | 9   | 强制终止                                        |
| SIGTERM | 15  | 终止，终端正常终止                                   |
| SIGCONT | 18  | 继续`fg/bg`                                   |
| SIGSTOP | 19  | 暂停`C-z`                                     |
| SIGTSTP | 20  |                                             |
*   1-31 31 个标准信号，命名是以“SIG”+后缀的形式
*   32-64 33 个实时信号，是以“SIGRTMIN+`<number>`"
## dd 执行进度
方法一：
```shell
watch -n 5 pkill -USR1 ^dd$
```
方法二：
```shell
watch -n 5 killall -USR1 dd
```
方法三：
```shell
# mac 用-INFO，linux 用 -USR1
while killall -USR1 dd; do sleep 5; done
```
方法四：
```shell
while (ps auxww |grep " dd " |grep -v grep |awk '{print $2}' |while read pid; do kill -USR1 $pid; done) ; do sleep 5; done
```
上述四种方法中使用三个命令：pkill、killall、kill向dd命令发送SIGUSR1信息，dd命令进程接收到信号之后就打印出自己当前的进度。