 **好代码 5 特质:** 
1. C，Composable，可组合 
2. U，Unix，做好一件事 
3. P，Predictable，可预测 
4. I，Idiomatic，符合惯例的 
5. D，Domain Based，基于领域的
## 可组合特质（C）
在讨论面向对象程序设计的时候，越来越关注到“组合优于继承”这样的原则。作为面向对象程序设计的三大特征之一的“继承”，似乎正越来越受到挑战
1. 很多继承的设计是不合理的，比如不符合SOLID所指出的里氏代换原则
2. 过深的继承树带来了代码的可理解性问题，因为我们总是需要理解了基类才能理解子类。
其实继承也是很有用的，但其前提是设计合理的继承。“组合优于继承”就是告诉我们优先考虑用组合模式来进行设计。
**可组合还体现在以下三个方面：**
### 精巧的接口
1. 接口太多时，如何组合这些接口去完成功能，接口较少时，可以更容易学习并更少犯错。
2. 只对外公开一个模块来提供接口，比对外公开多个模块提供接口更好。只对外公开一个类来提供接口，比对外公开多个类提供接口更好。 
3. 正确的接口粒度设计比较困难，最佳的粒度是接口既不显得臃肿也不碎片化。 设计模式中有一种常见的模式Facade，即门面模式，其意图正是将对外公开的接口放到一个类中去提供，以便减少接口面，从而让接口更容易使用。
### 可体现意图的代码
可体现意图的代码是用业务语言编写且能反映业务过程的代码。可体现意图的代码可以使读者更容易弄清为什么代码要这么写，因此更容易组合使用。代码中的各类命名（比如变量、函数等）都可以用于将意图体现得更为明显。 
### 最小依赖
拥有最小依赖的代码是容易组合使用的。  面向对象程序设计有一个重要的原则，即迪米特法则（Law of Demeter），又被称为最小知识原则、不要和陌生人说话原则。其指导意义在于一个类不应该和与其不相关的类产生（依赖）关系。
## Unix哲学（U）
一个程序应该做一件事，并将其做好。比如ls程序只做列举文件的事，文件详情，则需要lstat，文件内容使用cat，搜索文件使用grep等。Unix操作系统中定义了一个强大的管道（Pipe）概念，一个程序的输出可以通过管道传输给另一个程序，从而简单而一致的实现了多个程序的组合使用。 只做好一件事与SOLID中的单一职责原则很像。 与Unix原则描述很相似的还有关注点分离的原则。关注点分离是指不同的模块应该关注不同的事情。
## 可预测性（P）
程序的可预测性是指它应该做它看起来要做的事情，一致且可靠，不隐藏任何出乎意料的行为。最佳的提升程序的可观测性的方式还是通过有意识的设计来在关键处输出程序的状态或行为。 可预测性包括三个方面：
1. **与期望一致的行为** 可以通过测试来定义所期望的程序的行为，精心的挑选名字，克制的编写逻辑，正确的处理异常这些都能使得程序与期望的行为一致。
2. **输出确定的结果** 易于推理的代码是好代码，具备确定性的就具备易于推理的特性。不确定性常常来自复杂且不确定的依赖，严格控制其依赖的外部模块，尽量做到无依赖，也可以增强程序的确定性。 具备确定性的代码通常是健壮、可靠而具备弹性的。
3. **内部行为可观测** 程序在运行时打印关键的内部状态或行为就可以让我们推测其当前状态
	观察程序内部状态可以分为以下几个级别：
	*   **信息仪表（Instrumentation）** : 程序告诉我们它正在干什么
	*   **遥测（Telemetry）** : 程序告诉我们的信息用接口暴露，使其可远程访问
	*   **监控（Monitoring）** : 将程序告诉我们的信息可视化出来
	*   **告警（Alerting）** : 从监控信息中识别异常，发出通知
	*   **预测（Predicting）** : 利用监控信息来预测即将发生的事件
	*   **自适应（Adapting）** : 通过告警的或者预测的信息动态调整系统以适应变化
## 符合惯例的（I）
编写“人类可读的代码”意味着为别人编写代码。这正是“符合惯例”的意义。 编写代码时，可以假定你的用户具备以下背景：
*   熟悉所使用的编程语言，及该语言对应的库、工具链和生态
*   懂软件开发的有经验的开发者, 还有一条，他们正努力的完成某件事情。
**语言惯例** 代码应该遵循编程语言的惯例。语言惯例出现在各个级别的代码中，函数名、类型、参数、模块、代码组织结构、模块组织结构、工具链选择、依赖选择、管理依赖的方式等。
**团队惯例** 当编程语言本身没有风格倾向，或者有多种风格可选的时候，用什么风格来写代码就由我们自己或者我们的团队来决定了。通常团队会自己定义一些惯例，比如用什么工具，如何缩进等。
## 基于领域的（D）
1. **基于领域的语言**
代码的读者通常对问题是清楚的，所以，代码应该用问题空间的语言来写，这样就能让代码的读者更容易的理解。问题空间语言即领域语言。
TDD可以用于帮助我们更多的用领域语言编写代码。TDD要求在还没有实现代码的时候写出测试代码。TDD是希望我们可以在看到问题后，先用自然语言描述测试过程，然后再将自然语言的测试过程翻译为编程语言。由于描述测试过程时，会站在用户的角度进行描述，所以将更多的使用领域语言。并且测试过程的描述将反映出程序应该有的公开接口，所以接口也会变成用领域语言描述的接口，这就很大程度上促进了用领域语言编写代码。
举个例子，在电商场景中，如果要实现购物车的功能，则分析购物车的业务需求之后，可以将测试过程描述如下： 
- 准备一个空的购物车
- 向购物车添加商品1，数量1
- 向购物车添加商品2，数量2
- 购物车中应该有两种商品，其中有1个商品1及2个商品2
- 向购物车添加商品1，数量1
- 购物车中应该有两种商品，其中有2个商品1及2个商品2
- 从购物车取出商品1，数量2 
- 购物车中应该有一种商品，即2个商品2 
翻译为Java语言的测试代码示例如下（部分）：
```
...
void testCart() {
    var cart = new Cart();
    var product1 = new Product();
    var product2 = new Product();

    cart.add(product1, 1);
    cart.add(product2, 2);

    assertTrue(cart.contains(product1));
    assertEquals(1, cart.productCount(product1));
    assertTrue(cart.contains(product2));
    assertEquals(2, cart.productCount(product2));

    cart.add(product1, 1);
    ......
}
...
```
可以看到，通过编写测试，我们用领域语言设计了Cart类，Product类，并且对Cart类设计了add contains productCount三个方法。除了促进使用领域语言编写代码，TDD还可以让我们提供的接口刚刚够用，不多不少，从而实现可组合性特质中的“精巧的接口”。 
使用领域语言编写代码的最佳状态是，我们的代码可以让没有技术背景的业务人员也能轻松看懂，整个代码读起来就像业务分析师在讲解业务逻辑一样。
2. **基于领域的结构**
除了使用领域语言编写代码，在模块的设计、代码目录结构（或包结构）也应该优先使用领域语言命名。  使用基于领域的结构，建议尽量将目录按照领域进行划分，而不是框架概念。
比如，如果是一个电商的场景，目录结构应该是user product order payment shipment等。
3. **基于领域的边界**
无论我们如何组织代码结构，目录（或模块）的边界变成了事实上的领域边界。一打开代码库就能看到目录结构，目录的层级和名字逐渐变成了大家最熟系的信息。所以，在设计上，一个重要的原则就是将领域划分和目录划分保持一致。这将有效降低团队的认知负载，开发者将因此而更不容易犯错，团队效率最终将得到提高。 这并不意味着需要组织成一个平坦（flat）的目录结构。领域以下可以有子领域，目录以下可以有子目录，模块以下可以有子模块。重要的是这一个一个层级需要能对应上。