# DDD核心概念详解

## 概述

DDD的核心概念构成了领域建模的基础，理解这些概念对于成功实施DDD至关重要。这些概念包括实体、值对象、聚合、聚合根等，它们共同构成了领域模型的构建块。

## 一、实体（Entity）

### 定义
实体是指在业务中具有**唯一标识**的对象，实体的主要特征是**持续的身份**。即使属性发生变化，只要标识不变，它仍然是同一个实体。

### 核心特征
1. **唯一标识**：每个实体都有唯一的ID或标识符
2. **身份持续性**：标识在实体的整个生命周期中保持不变
3. **可变性**：实体的属性可以改变，但身份不变
4. **业务行为**：实体包含业务逻辑和行为

### 代码示例

```java
public class User {
    private Long id;        // 唯一标识
    private String name;
    private int age;
    private String email;

    // 业务行为
    public void updateProfile(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void changeEmail(String email) {
        // 验证邮箱格式的业务规则
        if (!isValidEmail(email)) {
            throw new IllegalArgumentException("Invalid email format");
        }
        this.email = email;
    }

    // 基于ID判断相等性，而不是属性
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        User user = (User) obj;
        return Objects.equals(id, user.id);
    }
}
```

### 实体的形态
- **业务形态**：业务现实中的对象，如用户、订单
- **代码形态**：包含属性和业务方法的类
- **运行形态**：内存中的对象实例
- **数据库形态**：持久化存储的数据记录

## 二、值对象（Value Object）

### 定义
值对象**没有唯一标识**，它是通过**属性值来判断相等性**的。值对象关注属性而非身份，属性是可替换的，不可变的！

### 核心特征
1. **无唯一标识**：通过属性值判断相等性
2. **不可变性**：创建后不能修改，只能整体替换
3. **可替换性**：属性相同的值对象可以相互替换
4. **业务概念整体**：将多个相关属性组合成一个概念整体

### 代码示例

```java
// 地址值对象 - 不需要id，创建后不能更改
public class Address {
    private final String province; // final修饰
    private final String city;     // final修饰
    private final String street;   // final修饰
    private final String zipCode;   // final修饰

    // 构造后不可修改
    public Address(String province, String city, String street, String zipCode) {
        this.province = Objects.requireNonNull(province);
        this.city = Objects.requireNonNull(city);
        this.street = Objects.requireNonNull(street);
        this.zipCode = Objects.requireNonNull(zipCode);
    }

    // 只有getter方法，没有setter方法
    public String getProvince() { return province; }
    public String getCity() { return city; }
    public String getStreet() { return street; }
    public String getZipCode() { return zipCode; }

    // 基于属性值判断相等性
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Address address = (Address) obj;
        return Objects.equals(province, address.province) &&
               Objects.equals(city, address.city) &&
               Objects.equals(street, address.street) &&
               Objects.equals(zipCode, address.zipCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(province, city, street, zipCode);
    }
}
```

### 为什么值对象要不可变？

1. **避免副作用**：不可变对象不会被意外修改，减少系统复杂度
2. **线程安全**：不可变对象天然线程安全，无需同步
3. **简化理解**：状态固定，更容易理解和维护
4. **缓存友好**：不可变对象可以被安全地缓存和共享

### 实体 vs 值对象对比

| 特征 | 实体 | 值对象 |
|------|------|--------|
| 标识 | 有唯一标识 | 无标识 |
| 相等性判断 | 基于标识 | 基于属性值 |
| 可变性 | 属性可变 | 不可变 |
| 替换性 | 不可替换 | 可整体替换 |
| 关注点 | 关注"是谁" | 关注"是什么" |

## 三、聚合（Aggregate）

### 定义
聚合就是将紧密相关的实体和值对象组织在一起，形成一个有边界的业务模块。聚合是一个**数据修改的原子单元**，确保聚合内数据的一致性。

### 聚合的核心组成

**聚合 = 聚合根 + 其他实体/值对象**

### 聚合根（Aggregate Root）
聚合根是聚合的**唯一入口**和**唯一标识**，只有通过聚合根才能访问或修改聚合内容的其他对象。

### 聚合的设计原则

1. **单一职责**：一个聚合对应一个核心业务概念
2. **一致性边界**：聚合内部保持业务规则的一致性
3. **外部不感知**：聚合外部不需要知道内部结构
4. **最小化关联**：聚合间通过ID引用，而非对象引用

### 代码示例

```java
// 订单聚合 - 聚合根
public class Order {
    private Long orderId;           // 聚合根的唯一标识
    private Long userId;
    private OrderStatus status;
    private Money totalAmount;
    private List<OrderItem> items;  // 子实体
    private Address address;        // 值对象
    private LocalDateTime createTime;

    // 聚合内部行为 - 封装内部对象的访问
    public void addItem(Product product, int quantity) {
        OrderItem item = new OrderItem(product, quantity);
        this.items.add(item);
        recalculateTotal();
    }

    public void removeItem(Long productId) {
        this.items.removeIf(item -> item.getProductId().equals(productId));
        recalculateTotal();
    }

    public void changeAddress(Address newAddress) {
        this.address = Objects.requireNonNull(newAddress);
    }

    // 聚合的业务规则保护
    public void confirm() {
        if (items.isEmpty()) {
            throw new BusinessException("订单不能为空");
        }
        if (status != OrderStatus.PENDING) {
            throw new BusinessException("只有待支付状态的订单才能确认");
        }
        this.status = OrderStatus.CONFIRMED;
    }

    public void pay() {
        if (status != OrderStatus.CONFIRMED) {
            throw new BusinessException("只有已确认的订单才能支付");
        }
        this.status = OrderStatus.PAID;
    }

    // 私有方法 - 内部业务逻辑
    private void recalculateTotal() {
        this.totalAmount = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
    }

    // 不暴露内部集合的直接引用
    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items);
    }
}

// 订单项 - 实体，只能通过Order访问
public class OrderItem {
    private Long productId;
    private String productName;
    private Money unitPrice;
    private int quantity;

    OrderItem(Product product, int quantity) {
        this.productId = product.getId();
        this.productName = product.getName();
        this.unitPrice = product.getPrice();
        this.quantity = quantity;
    }

    public Money getSubtotal() {
        return unitPrice.multiply(quantity);
    }

    // 只有getter方法，没有setter方法
    // 修改必须通过Order聚合根
}
```

### 聚合的使用规范

1. **访问控制**：只能通过聚合根访问聚合内部对象
2. **事务边界**：一个事务只能修改一个聚合
3. **跨聚合引用**：通过聚合根ID引用，而不是对象引用
4. **一致性保证**：聚合根负责维护内部一致性

### 聚合的持久化

```java
// 聚合的仓储操作
public interface OrderRepository {
    Order findById(Long id);           // 通过聚合根ID查询整个聚合
    void save(Order order);            // 保存整个聚合
    void delete(Long id);              // 删除整个聚合

    // 查询方法返回聚合根，而不是内部实体
    List<Order> findByUserId(Long userId);
}
```

## 四、领域服务（Domain Service）

### 定义
领域服务是DDD领域层的组成部分，用于封装**不属于单个实体或值对象的领域逻辑**，这些逻辑涉及多个领域对象的协作或无状态的操作。

### 何时使用领域服务

1. **跨实体协作**：涉及多个实体或值对象的复杂业务逻辑
2. **无状态操作**：执行业务计算或规则验证
3. **领域规则封装**：实现领域内的通用算法或策略

### 代码示例

```java
// 银行转账领域服务
@Service
public class TransferDomainService {
    private final AccountRepository accountRepository;

    public TransferDomainService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }

    // 跨实体的领域逻辑
    @Transactional
    public void transfer(Long fromAccountId, Long toAccountId, Money amount) {
        // 1. 账户存在性校验
        Account fromAccount = accountRepository.findById(fromAccountId)
            .orElseThrow(() -> new AccountNotFoundException(fromAccountId));
        Account toAccount = accountRepository.findById(toAccountId)
            .orElseThrow(() -> new AccountNotFoundException(toAccountId));

        // 2. 业务规则校验
        if (fromAccount.getBalance().lessThan(amount)) {
            throw new InsufficientBalanceException("账户余额不足");
        }

        // 3. 执行转账
        fromAccount.debit(amount);    // 账户扣款
        toAccount.credit(amount);      // 账户入账

        // 4. 保存聚合
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
    }

    // 计算利息的纯业务逻辑
    public Money calculateInterest(Account account, LocalDate startDate, LocalDate endDate) {
        // 复杂的利息计算逻辑
        Money principal = account.getBalance();
        double rate = getInterestRate(account.getAccountType());
        int days = Days.between(startDate, endDate);

        return principal.multiply(rate).multiply(days / 365.0);
    }

    // 验证转账限额的领域规则
    public boolean validateTransferLimit(Account account, Money amount) {
        Money dailyLimit = account.getDailyTransferLimit();
        Money todayTransferred = calculateTodayTransferredAmount(account.getId());

        return todayTransferred.add(amount).lessThanOrEqual(dailyLimit);
    }
}
```

### 领域服务 vs 应用服务

| 特征 | 领域服务 | 应用服务 |
|------|----------|----------|
| 位置 | 领域层 | 应用层 |
| 职责 | 业务逻辑 | 流程编排 |
| 状态 | 无状态 | 可能管理事务状态 |
| 依赖 | 只依赖领域层 | 依赖领域层和基础设施层 |
| 返回值 | 领域对象、值对象 | DTO、ID、状态 |

## 五、总结

DDD的核心概念通过清晰的职责分离和边界控制，帮助我们构建出更加内聚和可维护的领域模型：

1. **实体**：有身份标识的对象，关注"是谁"
2. **值对象**：无标识的属性组合，关注"是什么"，不可变
3. **聚合**：数据修改的原子单元，维护内部一致性
4. **聚合根**：聚合的入口和标识，控制内部对象访问
5. **领域服务**：跨对象的业务逻辑封装

通过合理运用这些概念，我们可以：
- 建立清晰的业务边界
- 保证数据一致性
- 提高代码的内聚性
- 降低系统的复杂度