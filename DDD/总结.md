## 一、DDD 的核心思想
**领域驱动设计（Domain-Driven Design，DDD）是一种软件设计方法论**，旨在应对复杂业务场景的系统设计和演化问题。其核心思想是：
- **以业务领域为中心**，通过领域建模把业务知识转化为软件模型。
- **驱动**：业务问题域驱动建模，领域模型驱动代码实现。
- **分离复杂性**：分离业务复杂性与技术复杂性；
- **分治思想**：通过界限上下文（Bounded Context）、子域拆分，分治复杂系统。
> **一句话总结：**DDD 是一种围绕业务核心概念进行建模和设计的方法，通过分层架构和统一语言，使代码能真实反映业务并可持续迭代。
## 二、DDD 的战略设计
### 1. 子域划分
根据业务价值和特点，将领域划分为不同子域：
- **核心域（Core Domain）**：公司的核心竞争力，必须自己掌握和实现。
- **支撑域（Supporting Domain）**：非核心，但无现成方案，需要自己开发。
- **通用域（Generic Domain）**：通用功能，可买现成方案或外包，如认证、权限。
### 2. 界限上下文（Bounded Context）
- **定义**：限定统一语言适用的范围，明确模型的边界。
- **作用**：
    - 避免术语混淆（如“商品”在销售阶段是“商品”，在物流阶段是“货物”）；
    - 确定系统和微服务的拆分边界。
- **实质**：问题空间（业务语义边界）与解决方案空间（系统设计边界）的桥梁。
### 3. 统一语言（Ubiquitous Language）
- 通过与领域专家的讨论达成共识，形成统一的领域语言。
- **组成**：
    - 名词：领域对象（如订单、用户）；
    - 动词：领域行为或事件（如支付、取消）；
    - 形容词：描述属性（如有效、过期）。
- **目标**：开发、测试、产品、领域专家之间无障碍沟通。
## 三、DDD 的战术设计（分层架构）
DDD 的落地通常采用分层架构：
### 1. 领域层（Domain Layer）——业务核心
- **实体（Entity）**：有唯一标识，身份不变，属性可变。如 `User`、`Order`。
- **值对象（Value Object）**：无唯一标识，通过属性判断相等性，通常不可变。如 `Address`。
- **聚合（Aggregate）**：一组相关实体和值对象组成的整体。
    - **聚合根（Aggregate Root）**：聚合的入口和唯一标识，保证聚合内部一致性。
- **领域服务（Domain Service）**：处理不适合放入单个实体的业务逻辑，封装跨对象协作的领域规则。
- **工厂（Factory）**：创建复杂对象或聚合。
- **仓储（Repository）**：领域对象的持久化抽象接口。

👉 推荐采用 **充血模型**（实体包含业务逻辑和数据），避免 **贫血模型**（只有属性，逻辑全在服务层）。
### 2. 应用层（Application Layer）——编排/服务层
- **职责**：
    - 协调领域对象，编排业务流程；
    - 管理事务、权限、日志；
    - 数据转换（DTO ↔ 领域对象 ↔ VO）。
- **特点**：
    - 不包含核心业务逻辑，仅做“胶水”；
    - 薄层，依赖领域层和基础设施层。
### 3. 基础设施层（Infrastructure Layer）——技术实现
- 实现仓储、适配器、消息队列、缓存、数据库等细节。
- 封装第三方系统调用，供领域层和应用层使用。
- 举例：`OrderRepositoryImpl`（MySQL + Redis 实现）、`AliyunSmsSender`（短信发送）。
### 4. 接口/触发器层（Interface/Trigger Layer）
- 作为外部系统入口：HTTP 接口、MQ 消息、定时任务、WebSocket 等。
- 职责：接收输入、调用应用服务，**不写业务逻辑**。
- 相当于传统 MVC 的 Controller 层。
## 四、DDD 核心概念解析

| 概念       | 定义/职责                    | 特点/要点                   |
| -------- | ------------------------ | ----------------------- |
| **实体**   | 有唯一标识的对象，属性可变，身份不变       | 如用户、订单；通过 ID 判断身份，不依赖属性 |
| **值对象**  | 无唯一标识，属性决定相等性，不可变        | 如地址、金额；可整体替换，不可部分修改     |
| **聚合根**  | 聚合的入口和代表，保证内部一致性         | 外部只能通过聚合根访问或修改聚合内部对象    |
| **领域服务** | 跨多个对象的领域逻辑，业务规则的无状态封装    | 如转账、结算；位于领域层            |
| **应用服务** | 外部入口与领域层的桥梁，负责编排、事务、权限   | 不含业务逻辑，仅调度              |
| **仓储**   | 面向领域的持久化接口，隐藏数据库/缓存等实现细节 | 领域层只定义接口，基础设施层实现        |
| **适配器**  | 与外部系统的桥梁，封装第三方 API 或外部依赖 | 领域层调用接口，基础设施层实现         |
| **充血模型** | 实体内聚数据和业务逻辑              | 符合 OO 思想，推荐使用           |
| **贫血模型** | 实体仅有数据，逻辑全在服务层           | 属于反模式，导致服务层臃肿           |
## 五、DDD 的设计过程
1. **建立统一语言**：与领域专家沟通，形成一致的业务术语。
2. **事件风暴 / 用例分析**：识别领域对象、行为、事件。
3. **划分子域与界限上下文**：确定领域边界，指导微服务拆分。
4. **建立领域模型**：识别实体、值对象、聚合、领域服务。
5. **分层实现**：应用层编排、领域层建模、基础设施层支撑、触发器层接入。
6. **持续迭代建模**：随着业务发展不断演化模型。
## 六、案例：用户开户并赠送优惠券
- **领域层**：
    - `User`（实体，开户逻辑）；
    - `Coupon`（实体，发券逻辑）；
    - `NotifyService`（领域服务，发短信）。
- **应用层**：
    - `OpenAccountOrchestrator`：编排开户 → 发券 → 发短信流程。
- **触发器层**：
    - `OpenAccountController`：HTTP 接口；
    - `OpenAccountListener`：MQ 监听；
    - `CouponExpireScheduler`：定时任务。
- **基础设施层**：
    - `UserRepositoryImpl`（数据库实现）；
    - `AliyunSmsSender`（短信服务适配器）。
## 七、DDD 的实践建议
1. **从战略到战术**：先识别子域和上下文，再设计实体和聚合。
2. **充血优先**：避免贫血模型，让业务逻辑自然落在领域对象内。
3. **聚合最小化**：聚合尽量小，避免过大跨聚合事务。
4. **分层清晰**：应用层不写业务逻辑，领域层不依赖基础设施。
5. **统一语言驱动**：领域专家与开发共享同一种语言。

✅ 总结下来，DDD 的核心就是：
- 用 **统一语言** 建模业务；
- 用 **界限上下文** 控制复杂性；
- 用 **分层架构** 保持清晰职责；
- 用 **充血模型 + 聚合根** 内聚业务逻辑；
- 最终实现一个 **可演化、可维护的复杂业务系统**。