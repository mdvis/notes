# 领域模型设计

## 概述

领域模型是DDD的核心，它是对业务领域核心概念的建模，承载业务规则和业务逻辑的核心对象。优秀的领域模型应该能够**反映现实世界的业务场景和规则**。

## 一、充血模型 vs 贫血模型

### 贫血模型（Anemic Domain Model）

贫血模型是传统开发中常见的**反模式**，**实体仅有数据（属性）和简单的Getter/Setter，业务逻辑完全剥离到服务层**，导致实体"贫血"。

#### 特点
1. **数据与行为分离**：实体仅作为数据载体，逻辑集中在服务层
2. **服务层臃肿**：大量业务逻辑堆积在服务层，形成"上帝类"
3. **封装性弱**：外部可直接修改实体属性，破坏领域规则

#### 代码示例

```java
// 贫血模型的Order实体
public class Order {
    private Long id;
    private Long userId;
    private List<OrderItem> items;
    private Money discount;
    private OrderStatus status;

    // 仅包含Getter/Setter
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }

    public List<OrderItem> getItems() { return items; }
    public void setItems(List<OrderItem> items) { this.items = items; }

    public Money getDiscount() { return discount; }
    public void setDiscount(Money discount) { this.discount = discount; }

    public OrderStatus getStatus() { return status; }
    public void setStatus(OrderStatus status) { this.status = status; }
}

// 业务逻辑在服务层 - 导致服务层臃肿
@Service
public class OrderService {
    private final OrderRepository orderRepository;

    // 计算订单总价
    public Money calculateTotal(Order order) {
        Money total = order.getItems().stream()
            .map(item -> item.getPrice().multiply(item.getQuantity()))
            .reduce(Money.ZERO, Money::add);
        return total.subtract(order.getDiscount());
    }

    // 应用折扣
    public void applyDiscount(Order order, Money discount) {
        // 重复计算逻辑，且未校验折扣规则
        Money total = calculateTotal(order);
        if (discount.greaterThan(total)) {
            throw new BusinessException("折扣不能超过订单总价");
        }
        order.setDiscount(discount);
    }

    // 确认订单
    public void confirmOrder(Order order) {
        if (order.getItems().isEmpty()) {
            throw new BusinessException("订单不能为空");
        }
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new BusinessException("只有待处理订单才能确认");
        }
        order.setStatus(OrderStatus.CONFIRMED);
    }
}
```

#### 贫血模型的劣势
- 违背OO设计原则，代码难以维护
- 逻辑分散，修改一处需要多处调整
- 领域语义模糊，方法命名偏离业务
- 封装性弱，容易破坏业务规则

### 充血模型（Rich Domain Model）

充血模型是DDD推荐的设计模式，**实体不仅包含数据（属性），还封装完整的业务逻辑（方法）**，体现"数据与行为合一"的面向对象思想。

#### 特点
1. **业务逻辑内聚**：实体方法实现领域规则
2. **封装性强**：外部通过接口调用实体方法，保护内部状态
3. **领域语义清晰**：方法命名基于业务术语

#### 代码示例

```java
// 充血模型的Order实体
public class Order {
    private Long id;
    private Long userId;
    private List<OrderItem> items;
    private Money discount;
    private OrderStatus status;
    private LocalDateTime createTime;

    // 充血模型：总价计算逻辑在实体内部
    public Money getTotalPrice() {
        Money total = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
        return total.subtract(discount);
    }

    // 充血模型：业务规则校验和状态变更在实体内部
    public void applyDiscount(Money discount) {
        Objects.requireNonNull(discount, "折扣不能为空");

        // 业务规则校验
        if (discount.lessThan(Money.ZERO)) {
            throw new DomainException("折扣不能为负数");
        }
        if (discount.greaterThan(getTotalPrice())) {
            throw new DomainException("折扣不能超过订单总价");
        }

        this.discount = discount;
    }

    // 充血模型：业务逻辑封装在实体内
    public void addItem(Product product, int quantity) {
        Objects.requireNonNull(product, "商品不能为空");
        if (quantity <= 0) {
            throw new DomainException("商品数量必须大于0");
        }

        OrderItem item = new OrderItem(product, quantity);
        this.items.add(item);
    }

    // 充血模型：状态变更逻辑
    public void confirm() {
        if (items.isEmpty()) {
            throw new DomainException("订单不能为空");
        }
        if (status != OrderStatus.PENDING) {
            throw new DomainException("只有待处理订单才能确认");
        }

        this.status = OrderStatus.CONFIRMED;
    }

    public void pay() {
        if (status != OrderStatus.CONFIRMED) {
            throw new DomainException("只有已确认订单才能支付");
        }

        this.status = OrderStatus.PAID;
    }

    public void cancel(String reason) {
        if (status == OrderStatus.CANCELLED) {
            throw new DomainException("订单已取消");
        }
        if (status == OrderStatus.COMPLETED) {
            throw new DomainException("已完成订单不能取消");
        }

        this.status = OrderStatus.CANCELLED;
        // 记录取消原因等业务逻辑
    }

    // 提供查询方法，不暴露内部集合的直接引用
    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items);
    }

    public boolean isEmpty() {
        return items.isEmpty();
    }

    public boolean canConfirm() {
        return status == OrderStatus.PENDING && !isEmpty();
    }
}

// 简化的服务层 - 只负责协调和事务管理
@Service
public class OrderApplicationService {
    private final OrderRepository orderRepository;
    private final ProductService productService;

    @Transactional
    public OrderId createOrder(CreateOrderCommand command) {
        Order order = new Order(command.getUserId());

        // 通过实体的方法添加商品项
        for (OrderItemCommand itemCommand : command.getItems()) {
            Product product = productService.getById(itemCommand.getProductId());
            order.addItem(product, itemCommand.getQuantity());
        }

        // 应用折扣
        if (command.getDiscount() != null) {
            order.applyDiscount(command.getDiscount());
        }

        // 确认订单
        order.confirm();

        // 保存聚合
        orderRepository.save(order);

        return order.getId();
    }
}
```

### 充血模型 vs 贫血模型对比

| 特征 | 充血模型 | 贫血模型 |
|------|----------|----------|
| **业务逻辑位置** | 实体内部 | 服务层 |
| **封装性** | 强，保护内部状态 | 弱，暴露内部属性 |
| **代码内聚性** | 高，逻辑集中 | 低，逻辑分散 |
| **领域语义** | 清晰，基于业务术语 | 模糊，技术导向 |
| **测试复杂度** | 单元测试简单 | 集成测试复杂 |
| **维护成本** | 低，修改集中 | 高，涉及多处 |

## 二、领域模型的构建方法

### 1. 名词分析法

从用例和业务描述中识别名词作为候选的领域对象：

```java
// 用例描述：
// "管理员创建了北京和上海两个校区"
// "管理员创建了Linux、Python、Go 3个课程"
// "管理员创建了北京校区的Python 16期班级"
// "管理员创建了学员小晴，并将其分配在Python 16期班级"

// 识别出的名词：
// 管理员、校区、课程、班级、学员
```

### 2. 动词分析法

从业务操作中识别实体应该包含的方法：

```java
// 业务操作：
// "学员提交作业" -> Student.submitHomework()
// "讲师批改作业" -> Teacher.gradeHomework()
// "学员报名课程" -> Student.enrollCourse()
// "班级分配讲师" -> Class.assignTeacher()
```

### 3. 领域关系建模

识别对象之间的关系：

```java
public class Campus {
    private String name;
    private List<SchoolClass> classes;
    private List<Course> offeredCourses;
}

public class SchoolClass {
    private String className;
    private Campus campus;
    private Course course;
    private Teacher teacher;
    private List<Student> students;
}

public class Course {
    private String courseName;
    private Duration duration;
    private Money price;
}

public class Student {
    private String name;
    private List<SchoolClass> enrolledClasses;
    private List<Homework> submittedHomeworks;
}

public class Teacher {
    private String name;
    private List<SchoolClass> assignedClasses;
}
```

## 三、领域模型的设计原则

### 1. 单一职责原则
每个实体应该只负责一个明确的业务概念

```java
// 好的设计 - 职责分离
public class Order {           // 负责订单业务逻辑
    // 订单相关逻辑
}

public class Payment {          // 负责支付业务逻辑
    // 支付相关逻辑
}

// 避免 - 职责混乱
public class Order {
    // 订单逻辑
    public void calculateTotal() { ... }

    // 支付逻辑 - 不应该在这里
    public void processPayment(PaymentMethod method) { ... }

    // 物流逻辑 - 不应该在这里
    public void arrangeShipping(Address address) { ... }
}
```

### 2. 高内聚低耦合
- **高内聚**：相关的业务逻辑应该放在同一个实体内
- **低耦合**：实体之间的依赖关系应该尽量少

### 3. 封装变化
将可能变化的业务逻辑封装在实体内部

```java
public class Order {
    private OrderPricingStrategy pricingStrategy;

    // 定价策略可以变化，但接口保持稳定
    public Money calculatePrice() {
        return pricingStrategy.calculatePrice(this);
    }
}
```

### 4. 基于业务而不是技术
模型设计应该基于业务概念，而不是技术实现

```java
// 好的设计 - 基于业务
public class Student {
    public void enrollCourse(Course course) { ... }
    public void submitHomework(Homework homework) { ... }
}

// 避免 - 基于技术
public class Student {
    public void saveToDatabase() { ... }      // 技术关注点
    public void serializeToJson() { ... }     // 技术关注点
}
```

## 四、领域模型的演进

### 1. 从简单到复杂
初期从简单的属性和方法开始，随着业务理解深入逐步丰富

```java
// 初期版本
public class Order {
    private Long id;
    private Money amount;
}

// 演进版本
public class Order {
    private Long id;
    private List<OrderItem> items;
    private Address address;
    private OrderStatus status;

    public Money calculateTotal() { ... }
    public void applyDiscount(Money discount) { ... }
    public void confirm() { ... }
}
```

### 2. 持续重构
随着业务发展不断重构模型，保持模型的准确性

### 3. 验证和测试
通过单元测试验证领域模型的正确性

```java
@Test
void should_calculate_order_total_correctly() {
    // Given
    Order order = new Order();
    order.addItem(new Product("Book", new Money("10.00")), 2);
    order.addItem(new Product("Pen", new Money("2.00")), 3);

    // When
    Money total = order.calculateTotal();

    // Then
    assertEquals(new Money("26.00"), total);
}

@Test
void should_throw_exception_when_discount_exceeds_total() {
    // Given
    Order order = new Order();
    order.addItem(new Product("Book", new Money("10.00")), 1);

    // When & Then
    assertThrows(DomainException.class, () ->
        order.applyDiscount(new Money("15.00")));
}
```

## 五、总结

优秀的领域模型设计需要：

1. **使用充血模型**：让实体承担业务逻辑，避免贫血反模式
2. **基于业务建模**：模型反映真实业务概念，而非技术实现
3. **保持封装性**：保护内部状态，通过方法提供业务功能
4. **单一职责**：每个实体专注于明确的业务概念
5. **持续演进**：随着业务理解深入不断优化模型
6. **充分测试**：通过测试验证模型的正确性

通过这些原则和实践，我们可以构建出**清晰、可维护、业务导向**的领域模型，为整个系统的成功实施奠定坚实基础。