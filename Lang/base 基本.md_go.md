# base 基本
综合基础

* * *

\[TOC\]

关键字

* * *

| 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- |
| break | default | func | interface | select | case | defer |
| go  | map | struct | chan | else | goto | package |
| switch | const | fallthrough | if  | range | type | continue |
| for | import | return | var |     |     |     |

变量
--

变量是一段或多段用来存储数据的内存。变量的生命和初始化是分开的，运行时内存分配操作会确保变量自动初始化为二进制零值，避免不可预测行为发生。显示提供初始值可省略类型由编译器推断

### 变量声明

支持类型推断，明确的基础类型划分有助于编写跨平台应用。

var 关键字

```go
var <variable_name> <type>
var v1 int
var v2 string
var v3 [10]int
var v4 []int
var v5 struct {
    f int
}
var v6 *int
var v7 map[string]int
var v8 func(a int)int
var (
    v9 int
    v10 string
)
```

### 变量初始化

go 指定类型不是必须的，可以根据右值推导出 ==只能用在函数内部== ==只能用在函数内部== ==只能用在函数内部==

```go
var v1 int = 10
// 一下两种可以自动推导类型
var v2 = 10

// 简短模式
// 冒号和等号的组合 :=
// 用于明确表达同时进行变量声明和初始化的工作。
// 定义变量，同时显示初始化
// 不能提供数据类型
// 只能用在函数内部
v3 := 10
```

#### 退化为赋值操作

\==退化赋值的前提条件是：最少有一个新变量被定义，且必须为同一作用域==

\==在处理函数错误时，退化赋值允许我们重复使用err变量==

```
// 退化为赋值操作
// 退化赋值的前提条件是：最少有一个新变量被定义，且必须为同一作用域
x := 1
x, y:=2,4 // 由于前面以声明x，这里x退化为赋值操作，只有y是变量定义，

x:=1
x:=2 // err: no new variables on left side of :=

x:=1
{
x, y := 3,4 // err: 不同作用域，全部为新变量定义
}
```

### 变量赋值

多重赋值

```go
var v1,v2 int = val1, val2
var v1,v2 = val1, val2
```

### 匿名变量, 空标识符

\_ 是特殊变量，所有赋给 \_ 的值都会被丢弃，无法读取内容

用来临时规避编译器对未使用变量和导入包的错误检查

\==预置成员，不能重新定义==

```go
func GetName() (firstName, lastName, nickName string){
    return 'May', 'Chan', 'Chibi' //多重返回
}

_, _, nickName := GetName() //匿名变量
```

### 类型转换

```go
[]byte(s) // 将s转换为[]byte类型
srting(c) 将c转换为string类型
```

### 类型断言

`v.(T)` v 不为 nil，且 v 可以转换为 T 类型，就断言==成功，返回 T 类型的值==，如果 T 不是接口类型，则要求 x 的类型就是 T，如果 T 是一个接口，要求 x 实现了 T 接口。

常量
--

常量通常是一些字面量，常量值必须是编译期可确定的字符、字符串、数字或布尔值，或者编译器可以计算出结果的表达式。不曾使用的常量不会引发编译错误。

不同于变量在运行期分配存储内存（非优化内存），常量通常会被编译器在预处理阶段直接展开，做为指令数据使用。

```go
const y = 0x200

pringln(&y) // error: cannot take the address of y

// 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址
```

```go
const x=100         // 无类型声明的常量
const y byte=x       // 直接展开x，相当于const y byte=100

const a int=100      // 显式指定常量类型，编译器会做强类型检查
const b byte=a       // 错误:cannot use a(type int)as type byte in const initializer
```

常量组初始化时如果不指定类型，则与上一行非空常量右值相同

```go
const (
x int = 1
y  // 与上一行x类型右值相同 也是int
z = "a"
s // string
)
```

### 字面常量 literal

所谓字面常量（literal），是指程序中硬编码的常量，如：

\-12 3.14159265358979323846 // 浮点类型的常量 3.2+12i // 复数类型的常量 true // 布尔类型的常量 "foo" // 字符串常量

### 常量定义

const 关键字

```go
const Pi float64 = 3.141592654
```

常量定义的右值也可以是一个在编译期运算的常量表达式，比如`const mask = 1 << 3`

由于常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达 式，比如试图以如下方式定义常量就会导致编译错误：`const Home = os.GetEnv("HOME")`原因很简单，os.GetEnv()只有在运行期才能知道返回结果，在编译期并不能确定，所以 无法作为常量定义的右值。

### 预定义常量

Go语言预定义了这些常量：true、false和iota

iota比较特殊，可以被认为是一个可被编译器修改的常量，在每一个const关键字出现时被 重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字会自动增1。

```go
const (
    c0 = iota // iota被重设为0
    c1 = iota
    c2 = iota
)

const (
    a = 1 << iota //iota 每个const开头被重置成0
    b = 1 << iota
    c = 1 << iota
)
```

如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。因此，上面的两个const语句可简写为：

```go
const (
    c0 = iota // iota被重设为0
    c1
    c2
)

const (
    a = 1 << iota //iota 每个const开头被重置成0
    b
    c
)
```

### 枚举

枚举指一系列相关的常量，可以用在const后跟一对圆括号的方式定义一组常量，这种定义法在Go语言中通常用于定义枚举值。Go语言并不支持众多其他语言明确支持的enum关键字。需要借助**iota**标识符实现一组自增常量值来实现枚举功能。

下面是一个常规的枚举表示法，其中定义了一系列整型常量：

```go
const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    numberOfDays // 这个常量没有导出
)
```

同Go语言的其他符号（symbol）一样，**以大写字母开头的常量在包外可见**。 以上例子中numberOfDays为包内私有，其他符号则可被其他包访问。

```go
const (
    _,_ = iota, iota*10 // 0, 0*10
    a,b  // 1, 1*10
    c,d  // 2, 2*10
)

// 默认int
const (
a = iota //int
b float32 = iota
c = iota // 名有明确指定类型和b一样
)

// 自定义类型
type color  byte

const (
black color = iota
red
)
```

类型
--

| 类型  | 长度  | 默认  | 说明  |
| --- | --- | --- | --- |
| bool | 1   | false |     |
| byte | 1   | unit8 |     |
| int,uint | 4,8 | 默认整数类型，平台相关 |     |
| int8,uint8 | 1   | \-128-127，0-255 |     |
| int16,uint16 | 2   | \-32768-32767，0-65535 |     |
| int32,uint32 | 4   | \-21亿-21亿，0-42亿 |     |
| int64,uint64 | 8   |     |     |
| float32 | 4   | 0.0 |     |
| float64 | 8   | 0.0 | 默认浮点数类型 |
| complex64 | 8   |     |     |
| complex128 | 16  |     |     |
| rune | 4   | 0   | Unicode Code Point，int32 |
| uintptr | 4,8 | 0   | 足以存储指针的uint |
| string |     | ""  | 字符串，默认为空字符串，而非NULL |
| array |     |     | 数组  |
| struct |     |     | 结构体 |
| function |     | nil | 函数  |
| interface |     | nil | 接口  |
| map |     | nil | 字典，引用类型 |
| slice |     | nil | 字典，引用类型 |
| channel |     | nil | 字典，引用类型 |

**strconv 库可在不同进制（字符串）间转换**,静态类型，强类型（类型决定内存长度和存储格式）

*   基础类型
    *   布尔类型：bool
    *   整型：int8、byte、int16、int、uint、uintptr等
    *   浮点类型：float32、float64
    *   复数类型：complex64、complex128
    *   字符串：string
    *   字符类型：rune
    *   错误类型：error
*   复合类型
    *   指针（pointer）
    *   数组（array）
    *   切片（slice）
    *   字典（map）
    *   通道（chan）
    *   结构体（struct）
    *   接口（interface）

对于常规的开发来说，用int 和uint就可以了，没必要用int8之类明确指定长度的类型，以免导致移植困难。

### 别名

专门提到两个别名

*   byte alias for uint8
*   rune alias for int32

别名类型无需转换，可直接赋值

```go
var a byte = 0x11
var b uint8 = a
```

### 引用类型

所为引用类型特指slice map channel这三种预定义类型

**相比数字、数组等类型，引用类型拥有更复杂的存储结构。除分配内存外，它们还须初始化一系列属性，诸如指针、长度，甚至包括哈希分布、数据队列等。**

内置函数new按指定类型长度分配零值内存，返回指针，并不关心内部构造和初始化方式。而引用类型必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。

除new/make函数外，也可使用初始化表达式，编译器生成的指令基本相同。

当然，new函数也可为引用类型分配内存，但这是不完整创建。以字典（map）为例，它仅分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。

### 转换类型

除常量、别名类型以及未命名类型外，Go要求强制使用显示类型转换。加上不支持重载，所以总能明确确定语句及表达式的明确含义。

### 语法歧义

如果转换的目标是指针、单向通道或没有返回值的函数类型，那么必须使用括号，以避免造成语法分解错误。

```go
(*int)(p)          --> 如果没有括号 -->  *(int(p))
(<-chan int)(c)                <-(chan int(c))
(func())(x)                       func()x

func()int(x)           --> 有返回值的函数类型可省略括号，但依然建议使用。
(func()int)(x)                  使用括号后，更易阅读
```

### 自定义类型

使用 type 关键字定义用户自定义类型，包括基于现有基础类型创建，或者是结构体，函数类型等。

```go
type flag byte
```

type 类型像var const 一样，也可以合并成组

```go
type (
    user struct {}
    event func(string) bool
)
```

即便指定了基础类型，也只表明它们有相同底层数据结构，两者间不存在任何关系，属完全不同的两种类型。除操作符外，自定义类型不会继承基础类型的其他信息（包括方法）。不能视作别名，不能隐式转换，不能直接用于比较表达式。

```go
func main() {
   type data int
   var d data=10

   var x int=d       // 错误:cannot use d(type data)as type int in assignment
   println(x)

   println(d==x)      // 错误:invalid operation:d==x(mismatched types data and int)
}
```

### 未命名类型

与有明确标识符的bool、int、string等类型相比，**数组、切片、字典、通道等类型与具体元素类型或长度等属性有关，故称作未命名类型（unnamed type）** 。当然，可用type为其提供具体名称，将其改变为命名类型（named type）。

具有相同声明命的未名类型被视作同一类型

*   具有相同基类型的指针
*   具有相同元素类型和长度的数组
*   具有相同元素类型的切片
*   具有相同键值类型的字典
*   具有相同数据类型及操作方向的通道
*   具有相同字段序列（字段名 字段类型 标签 及字段顺序）的结构体
*   具有相同签名（参数和返回值列表，不包括参数名）的函数
*   具有相同方法集（方法名 方法签名 不包括顺序）的接口

需要注意的是struct tag也属于类型组成部分，不只是数据描述。函数的参数顺序也属于签名组成部分

```go
var a struct {x string 'tag'} // 匿名结构体
var b struct {x string}

a=b //error->tag

var a func(int,string)
var b func(string,int)

a=b //error->顺序
```

未命名转换规则

*   所属类型相同
*   基础类型相同，且其中一个是未命名类型
*   基础类型相同，将双向通道赋值给双向通道，且其中一个为未命名类型
*   将默认值nil赋值给切片 字典 通道 指针 函数或接口
*   对象实现了目标接口

### 整型

| 类型  | 长度（字节） | 值范围 |
| --- | --- | --- |
| int8 | 1   | 128 ~ 127 |
| uint8（即byte） | 1   | 0 ~ 255 |
| int16 | 2   | 32768 ~ 32767 |
| uint16 | 2   | 0 ~ 65535 |
| int32 | 4   | 2147483 648 ~ 2147483 647 |
| uint32 | 4   | 0 ~ 4294967295 |
| int64 | 8   | 9223372036854775808~9223372036854775807 |
| uint64 | 8   | 0 ~ 18446744073709551615 |
| int | 平台相关 | 平台相关 |
| uint | 平台相关 | 平台相关 |
| uintptr | 同指针 | 在32位平台下为4字节，64位平台下为8字节 |

### 类型表示

### 数值运算 (+,-,\*,/,%)

### 比较运算 (>,<,==,>=,<=,!=)

两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但 各种类型的整型变量都可以直接与字面常量（literal）进行比较

```go
var i int32
var j int64

i,j = 1,2

if i == j {} //编译错误 类型不同
if i == 1 {} //编译通过 字面量
```

### 位运算

*   <<
*   ^ 异或 x ^ y
*   &
*   |
*   ^ 取反 ^x

### 浮点类型

表示包含小数点的数据 go语言中的float32 float64分别对应c语言的float double 类型推导会将浮点类型自动推导为float64

#### 浮点数比较

因为浮点数不是一种精确的表达方式，所以像整型那样直接用==来判断两个浮点数是否相等 是不可行的，这可能会导致不稳定的结果。推荐使用

```go
import math

// p 为自定义的比较精度, 如 0.00001
func IsEqual(f1,f2,p float 64) bool {
    return math.Fdim(v1,v2) < p
}
```

### 复数类型

#### 复数表示

复数实际上由两个实数(在计算机中用浮点数表示)构成，一个表示实部(real)，一个表示虚部(imag)

我们把形如 z=a+bi（a、b均为实数）的数称为复数。其中，a 称为实部，b 称为虚部，i 称为虚数单位。当 z 的虚部 b＝0 时，则 z 为实数；当 z 的虚部 b≠0 时，实部 a＝0 时，常称 z 为纯虚数。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。

```go
v1 := 3.2 + 12i  // v1是complex128类型
v2 := complex(3.2, 12) // 同上
```

#### 实部与虚部

```go
z = complex(x,y)
real(z) // 获得实部x
imag(z) // 获得虚部y
```

### 字符串

双引号或反引号包裹

*   len
*   Printf
*   Println

#### 字符串操作

*   x + y
*   len
*   s\[ind\]

#### 字符串遍历

```go
for i := 0; i < n; i++ {
    ch := str[i]
    fmt.Println(i, ch)
}

// 中文在utf-8中站三个字节长度是3

for i, ch := range str {
    fmt.Println(i, ch)
}
```

### 字符类型

在Go语言中支持两个字符类型

*   一个是byte（实际上是uint8的别名），代表UTF-8字符串
*   一个是rune，代表单个Unicode字符

### 数组

#### 声明方法

*   \[32\] byte // 长度32的数组，每个元素一字节
*   \[2 \* N\] struct {x, y init32} // 复杂类型数组
*   \[1000\] \* float64 // 指针数组
*   \[3\] \[5\] int // 二维数组
*   \[2\] \[2\] \[2\] float64 // 等同 \[2\] ( \[2\] ( \[2\] float64))

在Go语言中，数组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量 表达式（常量表达式是指在编译期即可计算结果的表达式）。数组的长度是该数组类型的一个内 置常量，可以用Go语言的内置函数len()来获取。

#### 元素访问

*   下标
*   range 关键字

```go
array := [2] int

for i, v := range array {}
```

需要特别注意的是，在Go语言中数组是一个值类型（value type）。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。

### 数组切片

每次传递都将产生一份副本。显然这种数据结构无法完全满足开发者的真实需求。

切片拥有自己的数据结构，而不仅仅是个指针。数组切片的数据结构可以抽象为以下3个变量：

*   一个指向原生数组的指针
*   数组切片中的元素个数
*   数组切片已分配的存储空间

数组切片实际上仍然使用数组来管理元素，基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致所管理的元素被重复复制。

#### 创建数组切片

1.  基于数组 `var myslice []int = myarray[:5]`
2.  直接创建

```go
    // make 内置函数 可以用于创建切片
    myslice := make([]int, 5) // 初始元素个数为5的数组切片，元素初始值为0
    myslice := make([]int, 5, 10)  // 初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间
    myslice := []int{1,2,3,4,5}  // 初始化包含5个元素的数组切片
```

#### 遍历

#### 动态增减

与数组相比，数组切片多了一个存储能 力（capacity）的概念，即元素个数和分配的空间可以是两个不同的值。

*   cap // 分配空间的大小
*   len // 存储元素的个数
*   append // 追加元素

```go
myslice = append(myslic, 1,2,3)

myslice2 := []int{1,2,3}
myslice = append(myslice, myslice2...) // 数组后面三个点...打散数组
```

#### 基于切片创建切片

#### 内容复制

*   copy 数组切片支持Go语言的另一个内置函数copy()，用于将内容从一个数组切片复制到另一个 数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行 复制。