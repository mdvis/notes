# 面向对象
method

* * *

### 声明

func (r ReceiverType) funcName (paramters) (result) 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这 种类型上，即相当于为这种类型定义了一个独占的方法。

*   可以为当前包内除了接口和指针以外的任何类型定义方法；在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样
*   如果方法内不引用实例，可省略参数名，仅保留类型

```go
type N int

func (n N)toString()string{
    return fmt.Printf(n)
}

func (N)test(){
    fmt.Printf("hi")
}
```

reveiver 叫做方法的接收器，早期的面向对象语言留下的遗产将 调用一个方法称为“向一个对象发送消息 在Go语言中，我们并不会像其它语言那样用this或者self作为接收器;我们可以任意的选择接收器的名字。==由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错 的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。== p.Distance 这种表达式叫做选择器，选择合适的对应 p 的 Distance 方法来执行

```go
package main
import (
    "fmt"
)
const (
    WHITE = iota
    BLACK
    BLUE
    RED
    YELLOW
)
type Color byte
type Box struct {
    width,height,depth float64
    color Color
}
type BoxList []Box
func (b Box) Volume() float64 {
    return b.width * b.height * b.depth
}
func (b *Box) SetColor(c Color){
    b.color = c
}
func (bl BoxList) BiggestsColor() Color {
    v := 0.00
    k := Color(WHITE)
    for _,b := range bl {
        if b.Volume() > v {
            v = b.Volume()
            k = b.color
        }
    }
    return k
}
func (c Color) String() string {
    strings := []string{ "WHITE", "BLACK", "BLUE", "RED", "YELLOW" }
    return strings[c]
}
func main(){...}
```

### 基于指针对象的方法

当调用一个函数时，会对其==每一个参数值进行拷贝==，如果一个函数需要==更新一个变量==，或者函数的其中一个参数实在太大我们希望能够==避免进行这种默认的拷贝==，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个==接受者变量本身比较大时==，我们就==可以用其指针而不是对象==来声明方法

```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
// 方法名为 (*Point).ScaleBy,必须要有(),否则可能会被理解成*(Point.ScaleBy)
```

\==在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方 法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。==

*   只有类型`(Point)`和指向他们的指针`(*Point)`，才是可能会出现在接收器声明里的两种接收器。
*   此 外，为了避免歧义，在声明方法时，如果一个==类型名本身是一个指针==的话，是不允许其出现在接收器中的 方法可使用实例值或指针调用方法，编译器会根据方法 reveiver 类型自动在基础类型和指针类型间转换 对象是否特别大不适合拷贝，内存地址指针适合拷贝

#### nil 也是一个合法的接收器类型

接收器对象值为零值，零值是 nil 是，接收器的类型就是 nil,当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是 很有必要的

```go
type IntList struct {
    valut int
    Tail *IntList
}
func (list *IntList)Sum()int{
if list == nil {
return 0
}
return list.Value + list.Tail.Sum()
}
```

#### 通过嵌入结构体来扩展类型

```go
import "image/color"

type Point struct{ X, Y float64 }

type ColoredPoint struct { 
Point
Color color.RGBA
}
```

```

type ColoredPoint struct {

Point

Color color.RGBA

}

type ColoredPoint struct {

*Point

Color color.RGBA

}

type ColoredPoint struct {

Point

color.RGBA

}
```

如果选择器有二义性的话编译器会报错，比如你在同一级里 有两个同名的方法。 方法只能在命名类型(像Point)或者指向类型的指针上定义，内嵌使得我们给匿名 struct类型来定义方法也有了手段

#### 方法值和方法表达式

p.Distance叫作“选择器”，选择器会返回一个方法"值"­>一个将方法 (Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用;即 调用时不需要指定接收器(译注:因为已经在前文中指定过了)，只要传入函数的参数即可 当T是一个类型时，方法表达式可能会写作T.f或者(\*T).f，会返回一个函数"值"，这种函数会将其第 一个参数用作接收器，所以可以用通常(译注:不写选择器)的方式来对其进行调用

```

p := Point{1, 2}

distanceFromP := p.Distance // 方法值

distanceFromP(q)

Distance:=Point.Distance //方法表达式

Distance(p,q)
```

#### 封装

一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。 Go语言只有一种控制可见性的手段:大写首字母的标识符会从定义它们的包中被导出，小写字母 的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封 装一个对象，我们必须将其定义为一个struct。

封装有三方面优点

1.  调用方不能直接修改对象的变量值，只需关注少量语句且只要弄懂少量变量的可能的值即可
2.  隐藏实现细节，可以防止调用方依赖那些可能变化的具体实现，这样使包设计者在不破坏对外api的情况下得到更大的自由
3.  阻止了外部调用方对对象内部的值任意的进行修改

```go
var a N
p:=&a
a.value()
p.value()
```

选择receiver类型参考

*   要修改实例状态， 用\*T
*   无需修改状态的小对象或固定值，建议用T
*   大对象建议用\*T，以减少复制成本
*   引用类型、字符串、函数等指针包装对象，直接用T
*   若包含Mutex等同步字段，用\*T，避免因复制造成锁操作无效
*   其他无法确定的情况，都用\*T

### 匿名字段

可以像访问匿名字段成员那样调用其方法，由编译器负责查找

```go
type data struct {
    sync.Mutex
}
d:=data{}
d.Lock() // 会处理为 sync.(*mutex).Lock()
```

可以访问匿名成员及方法但是他们却不属于继承关系

### 方法集

类型有一个与之相关联的方法集，这决定类型是否实现了某个接口。可以使用反射检测这些规则

*   类型 T 方法包含所有 receiver T 方法
*   类型 \*T 方法集包含所有 receiver T + \*T 方法
*   匿名嵌入 S，T 方法集包含所有 receiver S 方法
*   匿名嵌入 \*S，T 方法集包含所有 receiver S + \*S 方法
*   匿名嵌入 S 或 \*S，\*T 方法集包含所有 receiver S + \*S 方法

方法集仅影响接口实现和方法表达式转换，与通过实例指针调用方法无关。实例并不使用方法集，而直接调用。匿名字段就是为方法集准备的。方法和实例以匿名嵌入方式组合到一起共同实现对外接口。

### 表达式

方法根据引用方式不同，可分为expression和value两种状态。

#### Method Expression

通过类型引用的 method expression 会被还原为普通函数样式，receiver 是第一参数，调用时需显示传参。类型可以是T或\*T，只要目标方法存在于该类型方法集中即可

```go
type N int

func (n N)test(){}

f:=N.test
f(n)
f:=(*N).test
f(&n)

(*N).test(&n)
```

### Method Value

基于实例或指针引用的method value，参数签名不会改变，依旧按正常方式调用。**但当 method value 被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需要的 receiver 对象，与其绑定，以便在稍后执行时，能隐式传入 receiver 对象。**

```go
type N int

func (n N) test { }

var n N = 10
p:=&n

n++
f1:=n.test // 复制n 11

n++
f2:=p.test // 复制*p 12

n++

f1() // 11
f2() // 12
```

编译器会为 method value 生成一个包装函数，实现间接调用。至于receiver复制，和闭包的实现方法基本相同，打包成funcvval，经由DX寄存器传递。当method value作为参数时，会复制含receiver在内的整个method value

```go
func call(m func()){
    m()
}

var n N =10
p:=&n

print p n // 10

n++
call(n.test) // 11

n++
call(p.test) // 12
```

```go
type N int

// receiver 指针类型
func (n *N) test {
print n *n
}

var n N = 10
p:=&n

n++
f1:=n.test

n++
f2:=p.test

n++
print p n // 13

f1() // 13
f2() // 11
```