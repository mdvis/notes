# 流程控制
if
--

*   无需括号将条件包裹
*   {}必须存在
*   左{必须与if else 处于同一行
*   if 后，条件前，可以添加变量初始化语句，使用；间隔
*   有返回值的函数，不允许将“最终的”return语句包含在if...else...结构中

```go
if x > 10 {}
if x > 10 {} else {}
// Go语言的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了
if x := sum(); x > 10 {}
if x == 3 {} else if x < 3 {} else {}
```

for

* * *

Go语言中的循环语句只支持for关键字，而不支持while和do-while 结构

```
for [变量声明或函数调用的返回值（开始时）];[条件判断];[变量声明或函数调用的返回值（结束时）] {

}
```

```go
sun := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

无限循环(while)

```go
sum := 0
for {
    sum++
    if sum > 100 {
        break
    }
}

for a < 5 {...}
```

条件多重赋值

```go
a := []init{1,2,3}
for i,j := 0, len(a) -1; i<j; i,j=i+1,j-1 {
a[i],a[j] = a[j], a[i]
}
```

*   左花括号{必须与for处于同一行
*   Go语言中的for循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量
*   Go语言的for循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环

```go
for j := 0; j<5;j++{
    for i := 0; i<10; i++ {
        if i>5{
            break JLoop
        }
        fmt.Println(i)
    }
}
JLoop:
```

```go
for i,v := range varible {...}
```

switch

* * *

*   左花括号{必须与switch处于同一行
*   条件表达式不限制为常量或者整数
*   单个case中，可以出现多个结果选项
*   与C语言等规则相反，Go语言不需要用break来明确退出一个case
*   **只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case**
*   可以不设定 switch 之后的条件表达式， 在此种情况下， 整个 switch 结构与多个 if...else...的逻辑作用等同。

```go
switch sExpr {
  case expr 1:
      ...
  case expr 1:
      ...
  default:
      ...
}
```

每个case后默认自带 break

```go
switch i {
  case 1:
      ...
  case 2,3,4:
      ...
  default:
      ...
}
```

可以使用 fallthrough 强制执行后续

```go
switch i {
  case 1:
      ...
      fallthrough
  case 2,3,4:
      ...
      fallthrough
  default:
      ...
}
```

switch 后可以没有表达式

```go
switch {
    case a==0:
        fmt.Printf()
    default:
        fmt.Printf()
}
```