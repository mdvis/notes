# 接口
接口是一组 method 的组合，用来定义对象的一组行为 接口类型是对其它类型行为的抽象和概括;因为接口类型不会和特定的实现细节绑定在一起，通过 这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型;简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义;当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。

接口约定

* * *

接口类型是一种抽象类型，他不会暴露它所代表的对象的内部值的结构和这个对象支持的基础操作的集合

接口类型

* * *

接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。 io.Writer 类型是用的最广泛的接口之一，因为它提供了所有的类型写入bytes的抽象，包括文件类 型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。 io.Reader 可以代表任意可以读取bytes的类型 io.Closer 可以是任意可以关闭的值，例如一 个文件或是网络链接。

实现接口的条件

* * *

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。 接口指定的规则非常简单:表达一个类型属于某个接口只要这个类型实现这个接口,这个规则甚至适用于等式右边本身也是一个接口类型

```go
var w io.Writer
w = os.Stdout  // has Write method
w = new(bytes.Buffer) // has Write method
w = time.Second // error: lacks Write method

var rwc io.ReaderWriterCloser
rwc = os.Stdout // *os.File had Read, Write, Close method
rwc = new(bytes.Buffer) // error: lacks Close Method

w = rwc
rwc = w // error: lacks Close method
```

对于每一个命名过的具体类型 T；它一些方法的接收者是类型 T 本身然而另一些则是一个 T 的指针。在 T 类型的参数上调用一个 `*T` 的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了他的地址。这仅仅是一个语法糖：T 类型的值不拥有所有 `*T` 指针的方法，那这样他就可能只实现更少的接口。 interface{}类型，它没有任何方法，被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。 对于创建的一个interface{}值持有一个boolean，float，string，map，pointer，或者任意其它的类 型;我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法。

flag.Value 接口

* * *

定义
--

接口代表一种契约，是多个方法声明的集合。有些动态语言也被称作协议。

*   需要共同遵守的实现约定的规则，无需知道对方身份协作
*   实现的是做什么，而不是怎么做，谁来做
*   解除类型依赖
*   有助于减少用户可视方法
*   屏蔽实现细节
*   会有运行期开销
*   包内，货值不频繁变化的内部模块并不需要抽象接口强行分离
*   最常见是对包外提供访问，或预留拓展空间
*   无需显示声明，只要包含接口声明全部方法即视为实现
*   可以先实现类型，后抽象所需接口（重构时，模块拆分时等）

```go
// 接口也是一种结构
// 不能有字段
// 不能定义自己的方法
// 只能声明方法，不能实现
// 可嵌入其他接口类型
type iface struct {
    tab *itab
    data unsafe.Pointer
}
```

*   通常以er做名称后缀
*   方法名是声名组成部分
*   参数名可不同或省略

```go
type tester interface {
    test()
    string()string

    type d strict{} 

    func (*data)test(){} // 只有指针才有test方法
    func (data)string()string{return ""}

    var d data
    var t tester = &d

    t = d // error
    t = &d
}
```

执行机制

* * *

接口使用一个名为itab的结构存储运行期所需要的相关类型信息。

```go
type iface struct {
    tab *itab // 类型信息
    data unsafe.Pointer // 实际对象指针
}

type itab struct {
    inter *interfacetype // 接口类型
    _type *_type // 实际对象类型
    fun [1]uintptr // 实际对象方法地址
}
```

将对象赋值给接口变量时，会复制该对象。无法修改接口存储的复制品，因为他是unaddressagle的 接口内部两个指针（itab，data)都为nil时，接口才等于nil。再返回错误信息时容易出问题，应该明确返回nil

类型转换

* * *

类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型。 使用ok-idiom模式，几遍转换失败也不会引发panic。还可用switch语句在多种类型间做出推断匹配，这样空接口皆有更多发挥空间。

技巧
--

*   让编译器检查，确保类型实现了指定接口

```go
var _ InterfaceName = struct{}
```

*   定义函数类型，让相同签名的函数自动实现某个接口

```go
type FuncString func()string

func (f FuncString) String()string {
    return f()
}

var t fmt.Stringer = FuncString(
    func()string{
        return ""
    }
)
```

接口机理

* * *

### 类型赋值给接口

接口包含的方法列表是类型包含方法的子集

### 接口查询

接口查询即接口方法查询，类型实现了接口所有方法。就认为类型实现了接口。

### 接口赋值

接口查询的一种优化

```go
var a interface{} = 1

a.(int)
a.(string)
```

interface 变量存储的类型

* * *

interface 里的变量可以是任意类型的数值（实现了 interface），如何知道变量实际保存的是哪个类型的对象

*   Comma-ok 断言 `value, ok = element.(T)` value 是变量的值，ok 是一个 bool 类型，element 是 interface 变量，T 是断言类型
*   switch 测试

```go
type Element interface{}
type List []Element

type Person struct {
    name string
    age int
}

func (p Person) String() string { }
list := make(List, 3)
list[0] = 1
list[1] = "Hello"
list[2] = Person{"Dennis",8}

for i,v := range list {
    if val,ok := v.(int);ok{}
    else if val,ok := v.(string);ok{}
    else if val,ok := v.(Person);ok{}
    else{}
}


for i,v := range list {
    switch val:=v.(type){
        case int:
        case string:
        case Person:
        default:
    }
}
```

嵌入 interface

* * *

```go
// sort package
type Interface interface {
    Len() int
    Less(i,j int) bool
}

// heap package
type Interface interface {
    sort.Interface
    Push(x interface{}) interface{}
}
```

```go
type inter1 interface{}
type inter2 interface{}
type inter3 interface{
    inter1
    inter2
}
```

```go
package main
import (
    "fmt"
)
type Human struct {
    name string
    age int
    phone string
}
type Student struct {
    Human
    school string
    loan float32
}
type Employee struct {
    Human
    company string
    money float32
}
func (h Human) SayHi(){ }
func (h Human) Sing(lyrics string){}
func (e Employee) SayHi(){}

type Men interface {
    SayHi()
    Sing(lyrics string)
}

mike := Student{Human{"",34,""},"",34.4}
sam:= Employee{Human{"",43,""},"",3.44}

ls := make([]Men,2)
ls[0], ls[1] := mike, sam
```

反射
--

1.  首先把值转换为 reflect 对象，根据情况选择 reflect.Type 或 reflect.Value

```go
t := reflect.TypeOf(i) // 得到类型的元数据
v := reflect.ValueOf(i) // 得到实际值
```

1.  将 reflect 对象转化成相应的值，可以返回相应的类型和数值

```go
tag := t.Elem().Field(0).Tag
name := v.Elem().Field(0).String()
```

1.  反射的字段必须是可修改的

反射就是动态运行时的状态 Go语言提供了一种机制，在编译时不知道类型的情况下，可更新变量、在运行时查看 值、调用方法以及直接对它们的布局进行操作，这种机制称为反射(reflection)

*   在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作
*   不需要在编译时就知道这些变量的具体类型
*   可以让我们将类型本身作为第一类的值类型处理(把类型当作头等值)

why

* * *

我们需要一个有能力==统一处理各种值类型==的函数

*   处理的多种类型无法共享同一个接口
*   处理的类型布局未知
*   处理的类型在设计函数时还不存在
*   以上三条同时存在

reflect.Type 和 reflect.Value

* * *

```go
func TypeOf(i interface{}) reflect.Type
func ValueOf(i interface{}) reflect.Value
```

*   reflect 包定义两个重要类型，Type 和 Value。
*   Type 和 Value 接口均满足 `fmt.Stringer` 接口
*   一个 Type 表示一个 Go 类型，是一个接口，有一系列用来区分类型及检查他们组成部分的方法
*   reflect.TypeOf(interface{}) 接受任意类型，并返回 reflect.Type 形式的动态类型，reflect.TypeOf 总是返回具体类型

1.  反射能在运行期探知对象的类型信息和内存结构，一定程度上弥补了静态语言在动态行为上的不足。
2.  反射还是实现元编程的重要手段。
3.  Go对象头部并没有类型指针，通过其自身是无法在运行期获知任何类型相关信息的。
4.  反射操作所需的全部信息都源自接口变量。接口变量除存储自身类型外，还会保存实际对象的类型数据。 对所有接口进行反射都可以得到一个包含Type和Value的信息结构。Type表达的是被反射的这个变量本身的类型信息，Value表达的是变量实例本身的信息

```go
// switch 类型分支
switch x.(type) {
case type1:
  ...
case type2:
  ...
default:
  ...
}
```

```go
// 将一个具体的值转为接口类型会有一个隐式的接口转换操作
// 它会创建一个包含两个信息的接口值: 
// 操作数的动态类型(这里是int)和它的动态的值(这里是3)
t := reflect.TypeOf(3)
t.String() // "int"
t // "int"
```

```go
// reflect.TypeOf 总是返回具体类型
// io.Writer 是 interface，os.File 是类型
var w io.Writer = os.Stdout
reflect.TypeOf(w) // "*os.File"
```

*   一个 Value 可以装载任意类型的值
*   reflect.ValueOf(interface{}) 返回一个装载其动态值的 reflect.Value
*   reflect.Value 可以持有一个接口值
*   除非 Value 持有的是字符串, 否 则 String 方法只返回其类型. 而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理.
*   对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type
*   reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法. 它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值

```go
v := reflect.ValueOf(3) // a flect.Value
fmt.Println(v) // "3"  
fmt.Printf("%v\n", v) // "3"  
fmt.Println(v.String()) // NOTE: "<int Value>"

v.Type() // a reflect.Type
```

```go
type order struct {
    ordID int
    customID int
}

o:=order{456,56}

reflect.TypeOf(o) // main.order
reflect.ValueOf(o) // {456 56}
```

```go
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface()  // an interface{}
i := x.(int) // an int
fmt.Printf("%d\n", i) // "3"
```

reflect.Kind 和 reflect.Name

* * *

*   reflect.Type
    *   reflect.Type.Kind`func Kind() reflect.Kind`
    *   reflect.Type.Name`func Name() string` 这两个反射入口函数，会将任何传入的对象转换为接口类型。面对类型时，需要区分Type和Kind。前者表示真实类型（静态类型），后者表示其基础结构（底层类型）类别

### 理解反射的类型（Type）与种类（Kind）

在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。

#### 1) 反射种类（Kind）的定义

Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。 Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。 type A struct{} 定义的结构体属于 Struct 种类，\*A 属于 Ptr。

#### 2) 从类型对象中获取类型名称和种类

Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。 类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。

```go
t:=reflect.TypeOf(o) // main.orider
t.Kind() // struct
t.Name() // orider
```

reflect.NumField 和 reflect.Field

* * *

*   reflect.Value
    *   reflect.Value.NumField`func NumField() int`
    *   reflect.Value.Field`func Field(n int) reflect.StructField` `NumField()`方法返回结构中的字段数，`Field(i int)`方法返回字段 `i` 的 `reflect.Value`。 NumField 只能用于结构体，用前判断reflect.ValueOf(o).Kind() === reflect.Struct

```go
v:=reflect.ValueOf(o) // {456 56}
v.NumField() // 2
v.Field(0) // 456
v.Field(1) // 56
```

reflect.Int 和 reflect.String

* * *

*   reflect.ValueOf
    *   reflect.Value.Int `func Int() int64`
    *   reflect.Value.String `func String() string` 构造复合类型

```go
reflect.ArrayOf(10, reflect.TypeOf(byte(0)))
reflect.MapOf(relect.TypeOf(""),reflect.TypeOf(0))
```

*   reflect.ArrayOf
*   reflect.MapOf
*   reflect.TypeOf(&n).Elem // 返回指针、数组、切片、字典（值）或通道**的**基类型 获取结构体指针的基类型后，才能遍历他的字段。
*   reflect.Ptr
*   reflect.TypeOf().NumField
*   reflect.TypeOf().Field
*   reflect.TypeOf().Field().Type
*   reflect.TypeOf().Field().Offset
*   reflect.TypeOf().Field().Name
*   reflect.TypeOf().Field().Type.NumberField
*   reflect.TypeOf().Field().Type.Field
*   reflect.TypeOf().Field().Anonymoust
*   Reflect.Ptr
*   reflect.TypeOf().FieldByName
*   reflect.Typeof().FieldByIndex 匿名字段可用多级索引（按定义顺序）直接访问。 相对于reflect而言，当前包和外包都是“外包”，可用反射提取struct tag，还能自动分解。其常用于ORM映射，或数据格式验证 辅助判断方法Implements、ConvertibleTo、AssignableTo都是运行期进行动态调用和赋值所必需的。
*   reflect.TypeOf().Implements
*   reflect.TypeOf().ConvertibleTo
*   reflect.TypeOf().AssignableTo

值
-

Value 专注于对象实例数据读写。接口变量会复制对象，且是unaddressable的，所以要修改目标对象，就必须使用指针。

*   reflect.ValueOf().Elem // 传入指针也需要Elem获取目标对象，被接口存储的指针本身是不能寻址和进行设置操作的
*   reflect.ValueOf().CannAddr
*   reflect.ValueOf().CanSet 不能对非导出字段直接进行设置操作，无论是当前包还是外包

```go
type User struct {
    Name string
    code int
}

func main(){
    p:=new(User)
    v:=reflect.ValueOf(p).Elem()

    name:=v.FieldByName("Name")
    code:=v.FieldByName("code")

    fmt.Printf(name.CanAddr(), name.CanSet())
    fmt.Printf(code.CanAddr(), code.CanSet())

    if name.CanSet() {
        name.SetString("Tom")
    }

    if code.CanAddr() {
        *(*int)(unsafe.Pointer(code.UnsafeAddr())) = 100
    }

    fmt.Printf(*p)
}
```

*   Value.Pointer // 返回该字段所保存的地址
*   Value.Int
*   Value.data
*   Value.UnsafeAddr // 返回该字段自身的地址（结构对象地址+偏移量）
*   Value.Interface // 进行类型推断和转换
*   Value.TrySend
*   Value.TryRecv

```go
type user struct{
    Name string
    Age int
}
u:=user{
    "mage",
    60
}

v:=reflect.ValueOf(&u)

p,ok:=v.Interface().(*user)
```

接口有两种nil状态，使用IsNil判断是否为nil

```go
var a interface{}=nil
var b interface()=(*int)(nil)

a==nil
reflect.ValueOf(b).IsNil()
```

方法
--

*   Value.MethodByName
*   Value.MethodByName().Call

```go
type X struct {}

func (X) Test(x,y int) (int,error){
    return x+y, fmt.Errorf("%d",x+y)
}

func main(){
    var a X
    v:=reflect.ValueOf(&a)
    m:=v.MethodByName("Test")

    in:=[]reflect.Value{
        reflect.ValueOf(1),
        reflect.ValueOf(2),
    }

    out:=m.Call(in)
    for _,v:= range out{
        fmt.Println(v)
    }
}
```

变参使用CallSlice更方便

```go
type X struct {}

func (X) Format(s string, a...interface{})string{
    return fmt.Sprintf(s,a...)
}

func main(){
    var a X
    v:=reflect.ValueOf(&a)
    m:=v.MethodByName("Format")

    out:=m.Call([]reflect.Value{
        reflect.ValueOf("%d"),
        reflect.ValueOf("x"),
        reflect.ValueOf("100"),
    })

    fmt.Println(out)

    out=m.CallSlice([]reflect.Value{
        reflect.ValueOf("%d"),
        reflect.ValueOf([]interface{}{"x",100})
    })
}
```

构建
--

*   make
*   new

性能
--

反射在带来“方便”的同时，也造成了很大的困扰。很多人对反射避之不及，因为它会造成很大的性能损失。需谨慎使用

用法
--

获取类型信息

* * *

```go
var x float64 = 3.4

v.TypeOf() // float64

v:=reflect.ValueOf(x)
v.Kind() == reflect.Float64 // true
v.Float() // 3.4
```

获取值类型

* * *

> 类型 Type 中有个成员函数 CanSet，Go语言中所有的类型都是值类型，即这些变量在传递给函数的时候将发生一次复制。基于这个原则，我们再次看一下下面的语句:

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
v.Set(4,1)
```

> 首先要理清 v 和 x 的关系。在调用 ValueOf() 的地方，需要注意到 x 将会产生一个副本，因此 ValueOf() 内部对 x 的操作其实都是对着 x 的一个副本。假如 v 允许调用 Set()，那么我们也可以想象出，被修改的将是这个 x 的副本，而不是 x 本身。如果允许这样的行为，那么执行结果将会非常困惑。调用明明成功了，为 什么 x 的值还是原来的呢?为了解决这个问题Go语言，引入了可设属性这个概念(Settability)。 如果 CanSet() 返回 false，表示你不应该调用 Set() 和 Set\_Xxx\_() 方法，否则会收到这样的错误: `panic: reflect.Value.SetFloat using unaddressable value`

```go
var x float64 = 3.4
p := reflect.ValueOf(&x)
v := p.Elem()
v.CanSet()
```

对结构的反射操作

* * *

```go
type T struct { 
  A int
  B string
}

t := T{203, "mh203"}
s := reflect.ValueOf(&t).Elem()
typeOfT := s.Type()

for i := 0; i < s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf("%d: %s %s = %v\n", i, typeOfT.Field(i).Name, f.Type(), f.Interface())
}
```