# 结构体
聚合的数据类型，由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。成员可以通过点操作符访问.其成员也是变量,可以直接赋值也可以通过指针访问 结构体成员的顺序也有重要意义，不同顺序就是不同类型；如果结构体成员名字是以大写字母开头的，那么该成员就是导出的;这是Go语言导出规则决定 的。一个结构体可能同时包含导出和未导出的成员k。

*   一个命名为S的结构体类型将不能再包含S类型的成员:因为一个聚合的值不能包含它自身。(该限制同样适应于数组。)
*   S类型的结构体可以包含 `*S` 指针类型的成员，这可以让我们创建递归 的数据结构
*   结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。
*   结构体没有任何成员的话就是空结构体，写作`struct{}`。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些 Go 语言程序员用 map 来模拟 set 数据结构时，用它来代替 map 中布尔类型的 value，只是强调 key 的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们 通常会避免这样的用法。

```go
type Person struct {
    name string
    age int
}

var p Person
p.name = "Astaxie"
p.age = 32

p:=Person{"Astaxie", 32}
p:=Person{name:"Astaxie", age: 32}

seen := make(map[string]struct{})
if _,ok := seen[s];!ok {
    seen[s] = struct{}{}
}
```

### 结构体面值

1.  按成员顺序（要记住成员类型和顺序，成员调整会导致错误，只在定义包内部使用，或者在排列比较规则的小结构体中使用`image.Point{x, y}` `color.RGBA{red, green, blue, alpha}`）
2.  以成员名字加值（常用）

```go
type Point struct {x, Y int}

p := Point{1, 2} // 按成员定义顺序为每个成员指定一个面值
Point{Y:2} // 以成员名字和值来初始化
```

考虑效率，较大结构体通常会用指针方式传入和返回 如果要在函数内部修改结构体成员的话，用指针传入是必须的;因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。

```go
pp := &Point{1, 2}
// 等价
pp := new(Point)
*pp = Point{1, 2}
```

### 结构体比较

*   结构体全部成员可比较结构体就可以比较
*   可比较的结构体类型和其他比较类型一样，可以用于 map 的 key 类型

### 结构体嵌入和匿名成员(匿名字段/嵌入字段)

*   命名结构体包含另一个结构体类型的匿名成员，通过点运算符访问匿名成员链中嵌套的成员
*   声明一个成员的数据类型而不指明成员的名字，这类成员就叫匿名成员
*   匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针

```go
type Point struct { X, Y int}
type Circle struct { 
    Center Point
    Radius int
}
type Wheel struct {
    Circle Circle
    Spokes int
}

var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20

type Circle struct {
    Point // 匿名成员，Point 类型被嵌入到 Circle 结构体
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}

var w Wheel
w.X = 8        // equivalent to w.Circle.Point.X = 8 
w.Y = 8        // equivalent to w.Circle.Point.Y = 8 
w.Radius = 5   // equivalent to w.Circle.Radius = 5
w.Spokes = 20
```

*   右边的注释中给出的显式形式`w.Circle.Point.X`访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法 访问了
*   匿名成员 Circle、Point 都有自己的名字（即命名类型的名字，但这些名字再点操作符中是可选的）
*   结构体的字面值没有简短表示匿名成员的语法
*   匿名成员有隐式名字，所以不能同时包含两个同类型的匿名成员，名称会冲突
*   成员的名字是有其类型隐式决定的，所有匿名成员也有可见性的规则约束
*   任何命名类型都可作为结构体的匿名成员

但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢?

答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访 问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该 类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。组 合是Go语言中面向对象编程的核心

```go
// 以下均无法通过
w = Wheel{8, 8, 5, 20}
w = Wheel{X:8, Y:8, Radius:5, Spokes:20}

// 字面值必须遵循形状类型声明时的结构
w = Wheel{Circle{Point{8, 8}, 5}, 20}
w = Wheel{
    Circle: Circle{
        Point: Point{X:8, Y:8},
        Radius: 5,
    },
    Spokes:20
}

fmt.Printf("%#v\n", w)
// Wheel{ Circle: Circle{ Point: Point{X:8, Y:8}, Radius: 5 }, Spokes:20 }
```